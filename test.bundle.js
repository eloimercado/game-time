/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
	mocha.setup({"ui":"bdd"});
	__webpack_require__(13)
	__webpack_require__(14);
	if(false) {
		module.hot.accept();
		module.hot.dispose(function() {
			mocha.suite.suites.length = 0;
			var stats = document.getElementById('mocha-stats');
			var report = document.getElementById('mocha-report');
			stats && stats.parentNode.removeChild(stats);
			report && report.parentNode.removeChild(report);
		});
	}

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }
	
	__webpack_require__(5);
	__webpack_require__(10);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// Prepare cssTransformation
	var transform;
	
	var options = {"hmr":true}
	options.transform = transform
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, options);
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../mocha-loader/node_modules/css-loader/index.js!./mocha.css", function() {
				var newContent = require("!!../mocha-loader/node_modules/css-loader/index.js!./mocha.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)(false);
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);
	
	// exports


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function(useSourceMap) {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			return this.map(function (item) {
				var content = cssWithMappingToString(item, useSourceMap);
				if(item[2]) {
					return "@media " + item[2] + "{" + content + "}";
				} else {
					return content;
				}
			}).join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};
	
	function cssWithMappingToString(item, useSourceMap) {
		var content = item[1] || '';
		var cssMapping = item[3];
		if (!cssMapping) {
			return content;
		}
	
		if (useSourceMap && typeof btoa === 'function') {
			var sourceMapping = toComment(cssMapping);
			var sourceURLs = cssMapping.sources.map(function (source) {
				return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
			});
	
			return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
		}
	
		return [content].join('\n');
	}
	
	// Adapted from convert-source-map (MIT)
	function toComment(sourceMap) {
		// eslint-disable-next-line no-undef
		var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
		var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
	
		return '/*# ' + data + ' */';
	}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	
	var stylesInDom = {};
	
	var	memoize = function (fn) {
		var memo;
	
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	};
	
	var isOldIE = memoize(function () {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	});
	
	var getElement = (function (fn) {
		var memo = {};
	
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				var styleTarget = fn.call(this, selector);
				// Special case to return head of iframe instead of iframe itself
				if (styleTarget instanceof window.HTMLIFrameElement) {
					try {
						// This will throw an exception if access to iframe is blocked
						// due to cross-origin restrictions
						styleTarget = styleTarget.contentDocument.head;
					} catch(e) {
						styleTarget = null;
					}
				}
				memo[selector] = styleTarget;
			}
			return memo[selector]
		};
	})(function (target) {
		return document.querySelector(target)
	});
	
	var singleton = null;
	var	singletonCounter = 0;
	var	stylesInsertedAtTop = [];
	
	var	fixUrls = __webpack_require__(9);
	
	module.exports = function(list, options) {
		if (false) {
			if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
	
		options.attrs = typeof options.attrs === "object" ? options.attrs : {};
	
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();
	
		// By default, add <style> tags to the <head> element
		if (!options.insertInto) options.insertInto = "head";
	
		// By default, add <style> tags to the bottom of the target
		if (!options.insertAt) options.insertAt = "bottom";
	
		var styles = listToStyles(list, options);
	
		addStylesToDom(styles, options);
	
		return function update (newList) {
			var mayRemove = [];
	
			for (var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
	
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
	
			if(newList) {
				var newStyles = listToStyles(newList, options);
				addStylesToDom(newStyles, options);
			}
	
			for (var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
	
				if(domStyle.refs === 0) {
					for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
	
					delete stylesInDom[domStyle.id];
				}
			}
		};
	};
	
	function addStylesToDom (styles, options) {
		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
	
			if(domStyle) {
				domStyle.refs++;
	
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
	
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
	
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
	
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles (list, options) {
		var styles = [];
		var newStyles = {};
	
		for (var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = options.base ? item[0] + options.base : item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
	
			if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
			else newStyles[id].parts.push(part);
		}
	
		return styles;
	}
	
	function insertStyleElement (options, style) {
		var target = getElement(options.insertInto)
	
		if (!target) {
			throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
		}
	
		var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
	
		if (options.insertAt === "top") {
			if (!lastStyleElementInsertedAtTop) {
				target.insertBefore(style, target.firstChild);
			} else if (lastStyleElementInsertedAtTop.nextSibling) {
				target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				target.appendChild(style);
			}
			stylesInsertedAtTop.push(style);
		} else if (options.insertAt === "bottom") {
			target.appendChild(style);
		} else if (typeof options.insertAt === "object" && options.insertAt.before) {
			var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
			target.insertBefore(style, nextSibling);
		} else {
			throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
		}
	}
	
	function removeStyleElement (style) {
		if (style.parentNode === null) return false;
		style.parentNode.removeChild(style);
	
		var idx = stylesInsertedAtTop.indexOf(style);
		if(idx >= 0) {
			stylesInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement (options) {
		var style = document.createElement("style");
	
		options.attrs.type = "text/css";
	
		addAttrs(style, options.attrs);
		insertStyleElement(options, style);
	
		return style;
	}
	
	function createLinkElement (options) {
		var link = document.createElement("link");
	
		options.attrs.type = "text/css";
		options.attrs.rel = "stylesheet";
	
		addAttrs(link, options.attrs);
		insertStyleElement(options, link);
	
		return link;
	}
	
	function addAttrs (el, attrs) {
		Object.keys(attrs).forEach(function (key) {
			el.setAttribute(key, attrs[key]);
		});
	}
	
	function addStyle (obj, options) {
		var style, update, remove, result;
	
		// If a transform function was defined, run it on the css
		if (options.transform && obj.css) {
		    result = options.transform(obj.css);
	
		    if (result) {
		    	// If transform returns a value, use that instead of the original css.
		    	// This allows running runtime transformations on the css.
		    	obj.css = result;
		    } else {
		    	// If the transform function returns a falsy value, don't add this css.
		    	// This allows conditional loading of css
		    	return function() {
		    		// noop
		    	};
		    }
		}
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
	
			style = singleton || (singleton = createStyleElement(options));
	
			update = applyToSingletonTag.bind(null, style, styleIndex, false);
			remove = applyToSingletonTag.bind(null, style, styleIndex, true);
	
		} else if (
			obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function"
		) {
			style = createLinkElement(options);
			update = updateLink.bind(null, style, options);
			remove = function () {
				removeStyleElement(style);
	
				if(style.href) URL.revokeObjectURL(style.href);
			};
		} else {
			style = createStyleElement(options);
			update = applyToTag.bind(null, style);
			remove = function () {
				removeStyleElement(style);
			};
		}
	
		update(obj);
	
		return function updateStyle (newObj) {
			if (newObj) {
				if (
					newObj.css === obj.css &&
					newObj.media === obj.media &&
					newObj.sourceMap === obj.sourceMap
				) {
					return;
				}
	
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
	
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag (style, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (style.styleSheet) {
			style.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = style.childNodes;
	
			if (childNodes[index]) style.removeChild(childNodes[index]);
	
			if (childNodes.length) {
				style.insertBefore(cssNode, childNodes[index]);
			} else {
				style.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag (style, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			style.setAttribute("media", media)
		}
	
		if(style.styleSheet) {
			style.styleSheet.cssText = css;
		} else {
			while(style.firstChild) {
				style.removeChild(style.firstChild);
			}
	
			style.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink (link, options, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		/*
			If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
			and there is no publicPath defined then lets turn convertToAbsoluteUrls
			on by default.  Otherwise default to the convertToAbsoluteUrls option
			directly
		*/
		var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;
	
		if (options.convertToAbsoluteUrls || autoFixUrls) {
			css = fixUrls(css);
		}
	
		if (sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = link.href;
	
		link.href = URL.createObjectURL(blob);
	
		if(oldSrc) URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	
	/**
	 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
	 * embed the css on the page. This breaks all relative urls because now they are relative to a
	 * bundle instead of the current page.
	 *
	 * One solution is to only use full urls, but that may be impossible.
	 *
	 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
	 *
	 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
	 *
	 */
	
	module.exports = function (css) {
	  // get current location
	  var location = typeof window !== "undefined" && window.location;
	
	  if (!location) {
	    throw new Error("fixUrls requires window.location");
	  }
	
		// blank or null?
		if (!css || typeof css !== "string") {
		  return css;
	  }
	
	  var baseUrl = location.protocol + "//" + location.host;
	  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
	
		// convert each url(...)
		/*
		This regular expression is just a way to recursively match brackets within
		a string.
	
		 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
		   (  = Start a capturing group
		     (?:  = Start a non-capturing group
		         [^)(]  = Match anything that isn't a parentheses
		         |  = OR
		         \(  = Match a start parentheses
		             (?:  = Start another non-capturing groups
		                 [^)(]+  = Match anything that isn't a parentheses
		                 |  = OR
		                 \(  = Match a start parentheses
		                     [^)(]*  = Match anything that isn't a parentheses
		                 \)  = Match a end parentheses
		             )  = End Group
	              *\) = Match anything and then a close parens
	          )  = Close non-capturing group
	          *  = Match anything
	       )  = Close capturing group
		 \)  = Match a close parens
	
		 /gi  = Get all matches, not the first.  Be case insensitive.
		 */
		var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
			// strip quotes (if they exist)
			var unquotedOrigUrl = origUrl
				.trim()
				.replace(/^"(.*)"$/, function(o, $1){ return $1; })
				.replace(/^'(.*)'$/, function(o, $1){ return $1; });
	
			// already a full url? no change
			if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			  return fullMatch;
			}
	
			// convert the url to a full url
			var newUrl;
	
			if (unquotedOrigUrl.indexOf("//") === 0) {
			  	//TODO: should we add protocol?
				newUrl = unquotedOrigUrl;
			} else if (unquotedOrigUrl.indexOf("/") === 0) {
				// path should be relative to the base url
				newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
			} else {
				// path should be relative to current directory
				newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
			}
	
			// send back the fixed url(...)
			return "url(" + JSON.stringify(newUrl) + ")";
		});
	
		// send back the fixed css
		return fixedCss;
	};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(11)(__webpack_require__(12))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		function log(error) {
			(typeof console !== "undefined")
			&& (console.error || console.log)("[Script Loader]", error);
		}
	
		// Check for IE =< 8
		function isIE() {
			return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
		}
	
		try {
			if (typeof execScript !== "undefined" && isIE()) {
				execScript(src);
			} else if (typeof eval !== "undefined") {
				eval.call(null, src);
			} else {
				log("EvalError: No eval function available");
			}
		} catch (error) {
			log(error);
		}
	}


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')();\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function (e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function () {};\n    }\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function (e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function (err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice () {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function (callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function (err) {\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function (ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function (opts) {\n  if (typeof opts === 'string') {\n    opts = { ui: opts };\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function (fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function (err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":14,\"_process\":82,\"browser-stdout\":41}],2:[function(require,module,exports){\n'use strict';\n\nfunction noop () {}\n\nmodule.exports = function () {\n  return noop;\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check if a value is an array.\n *\n * @api private\n * @param {*} val The value to test.\n * @return {boolean} true if the value is an array, otherwise false.\n */\nfunction isArray (val) {\n  return objToString.call(val) === '[object Array]';\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\nfunction EventEmitter () {}\n\n/**\n * Add a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.on = function (name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.once = function (name, fn) {\n  var self = this;\n\n  function on () {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  }\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Remove a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeListener = function (name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners for an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeAllListeners = function (name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Get all listeners for a given event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.listeners = function (name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emit an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {boolean} true if at least one handler was invoked, else false.\n */\nEventEmitter.prototype.emit = function (name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  if (typeof handler === 'function') {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress () {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function (size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function (text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function (size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function (family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function (n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function (ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],5:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty () {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize () {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar JSON = require('json3');\n\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context () {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context}\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function (enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @return {Context} self\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n  return this;\n};\n\n/**\n * Allow a number of retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @api private\n * @return {string}\n */\nContext.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    return key === 'runnable' || key === 'test' ? undefined : val;\n  }, 2);\n};\n\n},{\"json3\":69}],7:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook (title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":33,\"./utils\":38}],8:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function (title) {\n      context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function (n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],9:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite (suite) {\n      return function run () {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only (opts) {\n        mocha.options.hasOnly = true;\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip (opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create (opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n          mocha.options.hasOnly = true;\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.');\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        mocha.options.hasOnly = true;\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":35}],10:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit (obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":35,\"../test\":36}],11:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":8,\"./exports\":10,\"./qunit\":12,\"./tdd\":13}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],13:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],14:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image (name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\nfunction Mocha (options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function (reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1 ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n          }\n        } else {\n          console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function (name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function (runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function () {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function (str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function (ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.checkLeaks = function () {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.fullTrace = function () {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.growl = function () {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function (globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function (colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function (inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function (timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.retries = function (n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function (slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function (enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.asyncOnly = function () {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.allowUncaught = function () {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay () {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function () {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function () {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @api public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function (fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.hasOnly = options.hasOnly;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done (failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":6,\"./hook\":7,\"./interfaces\":11,\"./reporters\":21,\"./runnable\":33,\"./runner\":34,\"./suite\":35,\"./test\":36,\"./utils\":38,\"_process\":82,\"escape-string-regexp\":61,\"growl\":63,\"path\":42}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @api public\n * @param {string|number} val\n * @param {Object} options\n * @return {string|number}\n */\nmodule.exports = function (val, options) {\n  options = options || {};\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  // https://github.com/mochajs/mocha/pull/1035\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse (str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction shortFormat (ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction longFormat (ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n *\n * @api private\n * @param {number} ms\n * @param {number} n\n * @param {string} name\n */\nfunction plural (ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending (message) {\n  this.message = message;\n}\n\n},{}],17:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Output the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function (failures) {\n  console.log();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n    var actual = err.actual;\n    var expected = err.expected;\n    var escape = true;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\n      escape = false;\n      if (!(utils.isString(actual) && utils.isString(expected))) {\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base (runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function () {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function (suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function () {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function (test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function (test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function () {\n    stats.end = new Date();\n    stats.duration = new Date() - stats.start;\n  });\n\n  runner.on('pending', function () {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') +\n      color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad (str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} Diff\n */\nfunction inlineDiff (err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function (str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings.\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} The diff.\n */\nfunction unifiedDiff (err, escape) {\n  var indent = '      ';\n  function cleanUp (line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return null;\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank (line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      ' +\n    colorLines('diff added', '+ expected') + ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {Error} err\n * @param {string} type\n * @param {boolean} escape\n * @return {string}\n */\nfunction errorDiff (err, type, escape) {\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function (str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @api private\n * @param {string} line\n * @return {string}\n */\nfunction escapeInvisibles (line) {\n  return line.replace(/\\t/g, '<tab>')\n    .replace(/\\r/g, '<CR>')\n    .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines (name, str) {\n  return str.split('\\n').map(function (str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType (a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":15,\"../utils\":38,\"_process\":82,\"diff\":55,\"supports-color\":42,\"tty\":5}],18:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\nfunction Doc (runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function (test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function (test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":38,\"./base\":17}],19:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Dot (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var n = -1;\n\n  runner.on('start', function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.on('end', function () {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],20:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTML (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function (test) {\n    var url = self.testURL(test);\n    var markup = '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' + playIcon + '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function (test) {\n    var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' + playIcon + '</a></h2></li>',\n      test.title, self.testURL(test));\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n        test.err.htmlMessage, stackString));\n    } else if (test.err.htmlMessage) {\n      el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n    } else {\n      el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function (test) {\n    var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack (el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats () {\n    // TODO: add to stats\n    var percent = stats.tests / runner.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl (s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error (msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment (html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout (classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide () {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text (el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on (el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":4,\"../utils\":38,\"./base\":17,\"escape-string-regexp\":61}],21:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":17,\"./doc\":18,\"./dot\":19,\"./html\":20,\"./json\":23,\"./json-stream\":22,\"./landing\":24,\"./list\":25,\"./markdown\":26,\"./min\":27,\"./nyan\":28,\"./progress\":29,\"./spec\":30,\"./tap\":31,\"./xunit\":32}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar JSON = require('json3');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function () {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function (test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function () {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":82,\"json3\":69}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function (test) {\n    pending.push(test);\n  });\n\n  runner.on('end', function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: errorJSON(test.err || {})\n  };\n}\n\n/**\n * Transform `error` into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON (err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":82}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Landing (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '✈');\n  var crashed = -1;\n  var n = 0;\n\n  function runway () {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('test', function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = color('checkmark', '  -') +\n      color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function (test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function (test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown (runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title (str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC (suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC (obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC (suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function () {\n    --level;\n  });\n\n  runner.on('pass', function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Min (runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function () {\n    self.draw();\n  });\n\n  runner.on('pass', function () {\n    self.draw();\n  });\n\n  runner.on('fail', function () {\n    self.draw();\n  });\n\n  runner.on('end', function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw (type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write (string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],29:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress (runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],30:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Spec (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('suite', function (suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function () {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function (test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":38,\"./base\":17}],31:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction TAP (runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function () {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function () {\n    ++n;\n  });\n\n  runner.on('pending', function (test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function (test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function (test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.on('end', function () {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title (test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":17}],32:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit (runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  if (options && options.reporterOptions && options.reporterOptions.output) {\n    if (!fs.createWriteStream) {\n      throw new Error('file output not supported in browser');\n    }\n    mkdirp.sync(path.dirname(options.reporterOptions.output));\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('end', function () {\n    self.write(tag('testsuite', {\n      name: 'Mocha Tests',\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\n' + escape(err.stack))));\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag (name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":38,\"./base\":17,\"_process\":82,\"fs\":42,\"mkdirp\":79,\"path\":42}],33:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar JSON = require('json3');\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\nvar create = require('lodash.create');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n * @param {string} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times');\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nRunnable.prototype = create(EventEmitter.prototype, {\n  constructor: Runnable\n});\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Set number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist a list of globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n    if (finished) {\n      return multiple(err || self._trace);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.');\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":15,\"./pending\":16,\"./utils\":38,\"debug\":2,\"events\":3,\"json3\":69,\"lodash.create\":75}],34:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar some = utils.some;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @api public\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner (suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function () {\n  var props = keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  try {\n    err.stack = (this.fullStackTrace || !err.stack)\n      ? err.stack\n      : stackFilter(err.stack);\n  } catch (ignored) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next (i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            utils.forEach(suite.tests, function (test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next (suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr (_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next (err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (test.isPending()) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next (errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done (errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err === (function () {\n      return this;\n    }.call(err)) ? (err.message || err) : err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete or pending\n  if (runnable.state || runnable.isPending()) {\n    return;\n  }\n  this.fail(runnable, err);\n\n  // recover from test\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n // recover from hooks\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences (suite) {\n  function cleanArrReferences (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  // If there is an `only` filter\n  if (this.hasOnly) {\n    filterOnly(rootSuite);\n  }\n\n  fn = fn || function () {};\n\n  function uncaught (err) {\n    self.uncaught(err);\n  }\n\n  function start () {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function () {\n    if (self.forbidOnly && self.hasOnly) {\n      self.failures += self.stats.tests;\n    }\n    if (self.forbidPending) {\n      self.failures += self.stats.pending;\n    }\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly (suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    utils.forEach(suite._onlySuites, function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = filter(suite.suites, function (childSuite) {\n      return indexOf(suite._onlySuites, childSuite) !== -1 || filterOnly(childSuite);\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly (suite) {\n  return suite._onlyTests.length || suite._onlySuites.length || some(suite.suites, hasOnly);\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks (ok, globals) {\n  return filter(globals, function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals () {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function (a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":16,\"./runnable\":33,\"./utils\":38,\"_process\":82,\"debug\":2,\"events\":3}],35:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`.\n *\n * @api private\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite (title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error('Suite `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  this.title = title;\n  function Context () {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) {\n      return full + ' ' + this.title;\n    }\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return utils.reduce(this.suites, function (sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run () {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":7,\"./ms\":15,\"./utils\":38,\"debug\":2,\"events\":3}],36:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar create = require('lodash.create');\nvar isString = require('./utils').isString;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test (title, fn) {\n  if (!isString(title)) {\n    throw new Error('Test `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nTest.prototype = create(Runnable.prototype, {\n  constructor: Test\n});\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":33,\"./utils\":38,\"lodash.create\":75}],37:[function(require,module,exports){\n'use strict';\n\n/**\n * Pad a `number` with a ten's place zero.\n *\n * @param {number} number\n * @return {string}\n */\nfunction pad(number) {\n  var n = number.toString();\n  return n.length === 1 ? '0' + n : n;\n}\n\n/**\n * Turn a `date` into an ISO string.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\n *\n * @param {Date} date\n * @return {string}\n */\nfunction toISOString(date) {\n  return date.getUTCFullYear()\n    + '-' + pad(date.getUTCMonth() + 1)\n    + '-' + pad(date.getUTCDate())\n    + 'T' + pad(date.getUTCHours())\n    + ':' + pad(date.getUTCMinutes())\n    + ':' + pad(date.getUTCSeconds())\n    + '.' + String((date.getUTCMilliseconds()/1000).toFixed(3)).slice(2, 5)\n    + 'Z';\n}\n\n/*\n * Exports.\n */\n\nmodule.exports = toISOString;\n\n},{}],38:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar JSON = require('json3');\nvar basename = require('path').basename;\nvar debug = require('debug')('mocha:watch');\nvar exists = require('fs').existsSync || require('path').existsSync;\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar readdirSync = require('fs').readdirSync;\nvar statSync = require('fs').statSync;\nvar watchFile = require('fs').watchFile;\nvar lstatSync = require('fs').lstatSync;\nvar toISOString = require('./to-iso-string');\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), { useNamedReferences: false });\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n */\nexports.forEach = function (arr, fn, scope) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    fn.call(scope, arr[i], i);\n  }\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n * @return {Array}\n */\nexports.map = function (arr, fn, scope) {\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    result.push(fn.call(scope, arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Object} obj to find index of\n * @param {number} start\n * @return {number}\n */\nvar indexOf = exports.indexOf = function (arr, obj, start) {\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} val Initial value.\n * @return {*}\n */\nvar reduce = exports.reduce = function (arr, fn, val) {\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.filter = function (arr, fn) {\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) {\n      ret.push(val);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Array#some (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.some = function (arr, fn) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (fn(arr[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Array} keys\n */\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function (obj) {\n  var keys = [];\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function (files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function (file) {\n    debug('file %s', file);\n    watchFile(file, options, function (curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Boolean}\n */\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexports.isArray = isArray;\n\n/**\n * Buffer.prototype.toJSON polyfill.\n *\n * @type {Function}\n */\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored (path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function (dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  readdirSync(dir)\n    .filter(ignored)\n    .forEach(function (path) {\n      path = join(dir, path);\n      if (lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(/^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/, '$1$2$3');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.trim = function (str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function (qs) {\n  return reduce(qs.replace('?', '').split('&'), function (obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    // Due to how the URLSearchParams API treats spaces\n    obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight (js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function (name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation (value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = exports.type = function type (value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = type(value);\n\n  if (!~indexOf(['object', 'array', 'function'], typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = value.toJSON();\n      // Based on the toJSON result\n      return jsonStringify(json.data && json.type ? json.data : json, 2)\n        .replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = reduce(value.split(''), function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify (object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = isArray(object) ? '[' : '{';\n  var end = isArray(object) ? ']' : '}';\n  var length = typeof object.length === 'number' ? object.length : exports.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat (s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify (val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate;\n        if (isNaN(val.getTime())) { // Invalid date\n          sDate = val.toString();\n        } else {\n          sDate = val.toISOString ? val.toISOString() : toISOString(val);\n        }\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space) +\n      (isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) +                    // value\n      (length ? ',' : '');                       // comma\n  }\n\n  return str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Test if a value is a buffer.\n *\n * @api private\n * @param {*} value The value to test.\n * @return {boolean} True if `value` is a buffer, otherwise false\n */\nexports.isBuffer = function (value) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n};\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize (value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack (value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = exports.map(value, function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        exports.forEach(exports.keys(value).sort(), function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @api public\n * @param {string} path Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles (path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = statSync(path);\n    if (stat.isFile()) {\n      return path;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  readdirSync(path).forEach(function (file) {\n    file = join(path, file);\n    try {\n      var stat = statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function () {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function (err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||\n      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||\n      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||\n      (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:')) ||\n      (~line.indexOf('(node.js:')) ||\n      (~line.indexOf('(module.js:')) ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false;\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = reduce(stack, function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace(cwd, '');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise (value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function () {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./to-iso-string\":37,\"_process\":82,\"buffer\":43,\"debug\":2,\"fs\":42,\"glob\":42,\"he\":64,\"json3\":69,\"path\":42,\"util\":102}],39:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],40:[function(require,module,exports){\n\n},{}],41:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"stream\":96,\"util\":102}],42:[function(require,module,exports){\narguments[4][40][0].apply(exports,arguments)\n},{\"dup\":40}],43:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"base64-js\":39,\"ieee754\":65,\"isarray\":68}],44:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":67}],45:[function(require,module,exports){\n/*istanbul ignore start*/\"use strict\";\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n\n\n},{}],46:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\nfunction convertChangesToXML(changes) {\n  var ret = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n\n  return n;\n}\n\n\n},{}],47:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.arrayDiff = undefined;\nexports. /*istanbul ignore end*/diffArrays = diffArrays;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\narrayDiff.tokenize = arrayDiff.join = function (value) {\n  return value.slice();\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\n\n},{\"./base\":48}],48:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports['default'] = /*istanbul ignore end*/Diff;\nfunction Diff() {}\n\nDiff.prototype = { /*istanbul ignore start*/\n  /*istanbul ignore end*/diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{ value: this.join(newString), count: newString.length }]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({ count: 1, added: added, removed: removed });\n    }\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n    return left === right;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n    return value;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored. For this case we merge the\n  // terminal into the prior string and drop the change.\n  var lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n\n\n},{}],49:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.characterDiff = undefined;\nexports. /*istanbul ignore end*/diffChars = diffChars;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nfunction diffChars(oldStr, newStr, callback) {\n  return characterDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],50:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.cssDiff = undefined;\nexports. /*istanbul ignore end*/diffCss = diffCss;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],51:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.jsonDiff = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports. /*istanbul ignore end*/diffJson = diffJson;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_line = require('./line') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/\n\nvar objectPrototypeToString = Object.prototype.toString;\n\nvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff. /*istanbul ignore end*/tokenize;\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement;\n\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {\n    if (typeof v === 'undefined') {\n      return undefinedReplacement;\n    }\n\n    return v;\n  }, '  ');\n};\njsonDiff.equals = function (left, right) {\n  return (/*istanbul ignore start*/_base2['default']. /*istanbul ignore end*/prototype.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n  );\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n}\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed.\nfunction canonicalize(obj, stack, replacementStack) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    var sortedKeys = [],\n        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n\n\n},{\"./base\":48,\"./line\":52}],52:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.lineDiff = undefined;\nexports. /*istanbul ignore end*/diffLines = diffLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\n\n},{\"../util/params\":60,\"./base\":48}],53:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.sentenceDiff = undefined;\nexports. /*istanbul ignore end*/diffSentences = diffSentences;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],54:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.wordDiff = undefined;\nexports. /*istanbul ignore end*/diffWords = diffWords;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\nvar reWhitespace = /\\S/;\n\nvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nwordDiff.equals = function (left, right) {\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\nwordDiff.tokenize = function (value) {\n  var tokens = value.split(/(\\s+|\\b)/);\n\n  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, callback) {\n  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, callback) {\n  return wordDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"../util/params\":60,\"./base\":48}],55:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_base = require('./diff/base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_character = require('./diff/character') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_word = require('./diff/word') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_line = require('./diff/line') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_sentence = require('./diff/sentence') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_css = require('./diff/css') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_json = require('./diff/json') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_array = require('./diff/array') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_apply = require('./patch/apply') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_parse = require('./patch/parse') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_create = require('./patch/create') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_dmp = require('./convert/dmp') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_xml = require('./convert/xml') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports. /*istanbul ignore end*/Diff = _base2['default'];\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize; /* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n\n\n},{\"./convert/dmp\":45,\"./convert/xml\":46,\"./diff/array\":47,\"./diff/base\":48,\"./diff/character\":49,\"./diff/css\":50,\"./diff/json\":51,\"./diff/line\":52,\"./diff/sentence\":53,\"./diff/word\":54,\"./patch/apply\":56,\"./patch/create\":57,\"./patch/parse\":58}],56:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/applyPatch = applyPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\nvar /*istanbul ignore start*/_parse = require('./parse') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_distanceIterator = require('../util/distance-iterator') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n    return (/*istanbul ignore end*/line === patchContent\n    );\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line[0],\n          content = line.substr(1);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.offset + _hunk.newStart - 1;\n    if (_hunk.newLines == 0) {\n      _toPos++;\n    }\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line[0],\n          content = line.substr(1),\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n  }\n\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n\n\n},{\"../util/distance-iterator\":59,\"./parse\":58}],57:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\nvar /*istanbul ignore start*/_line = require('../diff/line') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n  /*istanbul ignore start*/\n  var _loop = function _loop( /*istanbul ignore end*/i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      /*istanbul ignore start*/\n      var _curRange;\n\n      /*istanbul ignore end*/\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      })));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          /*istanbul ignore start*/\n          var _curRange2;\n\n          /*istanbul ignore end*/\n          // Overlapping\n          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n        } else {\n          /*istanbul ignore start*/\n          var _curRange3;\n\n          /*istanbul ignore end*/\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            if (lines.length == 0 && !oldEOFNewline) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            } else if (!oldEOFNewline || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    /*istanbul ignore start*/\n    _loop( /*istanbul ignore end*/i);\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n  var ret = [];\n  if (oldFileName == newFileName) {\n    ret.push('Index: ' + oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i];\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n\n},{\"../diff/line\":52}],58:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/parsePatch = parsePatch;\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      var line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      }\n\n      // Diff index\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    var headerPattern = /^(---|\\+\\+\\+)\\s+([\\S ]*)(?:\\t(.*?)\\s*)?$/;\n    var fileHeader = headerPattern.exec(diffstr[i]);\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      index[keyPrefix + 'FileName'] = fileHeader[2];\n      index[keyPrefix + 'Header'] = fileHeader[3];\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: +chunkHeader[2] || 1,\n      newStart: +chunkHeader[3],\n      newLines: +chunkHeader[4] || 1,\n      lines: [],\n      linedelimiters: []\n    };\n\n    var addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n      var operation = diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n\n},{}],59:[function(require,module,exports){\n/*istanbul ignore start*/\"use strict\";\n\nexports.__esModule = true;\n\nexports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text lenght, then\n    // hunk can't fit on the text. Return undefined\n  };\n};\n\n\n},{}],60:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/generateOptions = generateOptions;\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n\n\n},{}],61:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],62:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],63:[function(require,module,exports){\n(function (process){\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Module dependencies.\n */\n\nvar exec = require('child_process').exec\n  , fs = require('fs')\n  , path = require('path')\n  , exists = fs.existsSync || path.existsSync\n  , os = require('os')\n  , quote = JSON.stringify\n  , cmd;\n\nfunction which(name) {\n  var paths = process.env.PATH.split(':');\n  var loc;\n\n  for (var i = 0, len = paths.length; i < len; ++i) {\n    loc = path.join(paths[i], name);\n    if (exists(loc)) return loc;\n  }\n}\n\nswitch(os.type()) {\n  case 'Darwin':\n    if (which('terminal-notifier')) {\n      cmd = {\n          type: \"Darwin-NotificationCenter\"\n        , pkg: \"terminal-notifier\"\n        , msg: '-message'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , icon: '-appIcon'\n        , sound:  '-sound'\n        , url: '-open'\n        , priority: {\n              cmd: '-execute'\n            , range: []\n          }\n      };\n    } else {\n      cmd = {\n          type: \"Darwin-Growl\"\n        , pkg: \"growlnotify\"\n        , msg: '-m'\n        , sticky: '--sticky'\n        , priority: {\n              cmd: '--priority'\n            , range: [\n                -2\n              , -1\n              , 0\n              , 1\n              , 2\n              , \"Very Low\"\n              , \"Moderate\"\n              , \"Normal\"\n              , \"High\"\n              , \"Emergency\"\n            ]\n          }\n      };\n    }\n    break;\n  case 'Linux':\n    if (which('growl')) {\n      cmd = {\n          type: \"Linux-Growl\"\n        , pkg: \"growl\"\n        , msg: '-m'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , host: {\n            cmd: '-H'\n          , hostname: '192.168.33.1'\n        }\n      };\n    } else {\n      cmd = {\n          type: \"Linux\"\n        , pkg: \"notify-send\"\n        , msg: ''\n        , sticky: '-t 0'\n        , icon: '-i'\n        , priority: {\n            cmd: '-u'\n          , range: [\n              \"low\"\n            , \"normal\"\n            , \"critical\"\n          ]\n        }\n      };\n    }\n    break;\n  case 'Windows_NT':\n    cmd = {\n        type: \"Windows\"\n      , pkg: \"growlnotify\"\n      , msg: ''\n      , sticky: '/s:true'\n      , title: '/t:'\n      , icon: '/i:'\n      , url: '/cu:'\n      , priority: {\n            cmd: '/p:'\n          , range: [\n              -2\n            , -1\n            , 0\n            , 1\n            , 2\n          ]\n        }\n    };\n    break;\n}\n\n/**\n * Expose `growl`.\n */\n\nexports = module.exports = growl;\n\n/**\n * Node-growl version.\n */\n\nexports.version = '1.4.1'\n\n/**\n * Send growl notification _msg_ with _options_.\n *\n * Options:\n *\n *  - title   Notification title\n *  - sticky  Make the notification stick (defaults to false)\n *  - priority  Specify an int or named key (default is 0)\n *  - name    Application name (defaults to growlnotify)\n *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x\n *  - image\n *    - path to an icon sets --iconpath\n *    - path to an image sets --image\n *    - capitalized word sets --appIcon\n *    - filename uses extname as --icon\n *    - otherwise treated as --icon\n *\n * Examples:\n *\n *   growl('New email')\n *   growl('5 new emails', { title: 'Thunderbird' })\n *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' })\n *   growl('Email sent', function(){\n *     // ... notification sent\n *   })\n *\n * @param {string} msg\n * @param {object} options\n * @param {function} fn\n * @api public\n */\n\nfunction growl(msg, options, fn) {\n  var image\n    , args\n    , options = options || {}\n    , fn = fn || function(){};\n\n  if (options.exec) {\n    cmd = {\n        type: \"Custom\"\n      , pkg: options.exec\n      , range: []\n    };\n  }\n\n  // noop\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\n  args = [cmd.pkg];\n\n  // image\n  if (image = options.image) {\n    switch(cmd.type) {\n      case 'Darwin-Growl':\n        var flag, ext = path.extname(image).substr(1)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, quote(image))\n        break;\n      case 'Darwin-NotificationCenter':\n        args.push(cmd.icon, quote(image));\n        break;\n      case 'Linux':\n        args.push(cmd.icon, quote(image));\n        // libnotify defaults to sticky, set a hint for transient notifications\n        if (!options.sticky) args.push('--hint=int:transient:1');\n        break;\n      case 'Windows':\n        args.push(cmd.icon + quote(image));\n        break;\n    }\n  }\n\n  // sticky\n  if (options.sticky) args.push(cmd.sticky);\n\n  // priority\n  if (options.priority) {\n    var priority = options.priority + '';\n    var checkindexOf = cmd.priority.range.indexOf(priority);\n    if (~cmd.priority.range.indexOf(priority)) {\n      args.push(cmd.priority, options.priority);\n    }\n  }\n\n  //sound\n  if(options.sound && cmd.type === 'Darwin-NotificationCenter'){\n    args.push(cmd.sound, options.sound)\n  }\n\n  // name\n  if (options.name && cmd.type === \"Darwin-Growl\") {\n    args.push('--name', options.name);\n  }\n\n  switch(cmd.type) {\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Darwin-NotificationCenter':\n      args.push(cmd.msg);\n      var stringifiedMsg = quote(msg);\n      var escapedMsg = stringifiedMsg.replace(/\\\\n/g, '\\n');\n      args.push(escapedMsg);\n      if (options.title) {\n        args.push(cmd.title);\n        args.push(quote(options.title));\n      }\n      if (options.subtitle) {\n        args.push(cmd.subtitle);\n        args.push(quote(options.subtitle));\n      }\n      if (options.url) {\n        args.push(cmd.url);\n        args.push(quote(options.url));\n      }\n      break;\n    case 'Linux-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(quote(options.title));\n      if (cmd.host) {\n        args.push(cmd.host.cmd, cmd.host.hostname)\n      }\n      break;\n    case 'Linux':\n      if (options.title) {\n        args.push(quote(options.title));\n        args.push(cmd.msg);\n        args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      } else {\n        args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      }\n      break;\n    case 'Windows':\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(cmd.title + quote(options.title));\n      if (options.url) args.push(cmd.url + quote(options.url));\n      break;\n    case 'Custom':\n      args[0] = (function(origCommand) {\n        var message = options.title\n          ? options.title + ': ' + msg\n          : msg;\n        var command = origCommand.replace(/(^|[^%])%s/g, '$1' + quote(message));\n        if (command === origCommand) args.push(quote(message));\n        return command;\n      })(args[0]);\n      break;\n  }\n\n  // execute\n  exec(args.join(' '), fn);\n};\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"child_process\":42,\"fs\":42,\"os\":80,\"path\":42}],64:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless it’s part of a tag or an\n\t\t// unquoted attribute value. We’re only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer ≤ 8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.”\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that they’re not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we’re still here, it’s a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],65:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],66:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],67:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],68:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],69:[function(require,module,exports){\n(function (global){\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = false;\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],70:[function(require,module,exports){\n/**\n * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseCopy = require('lodash._basecopy'),\n    keys = require('lodash.keys');\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n},{\"lodash._basecopy\":71,\"lodash.keys\":78}],71:[function(require,module,exports){\n/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n},{}],72:[function(require,module,exports){\n/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      object.prototype = prototype;\n      var result = new object;\n      object.prototype = undefined;\n    }\n    return result || {};\n  };\n}());\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = baseCreate;\n\n},{}],73:[function(require,module,exports){\n/**\n * lodash 3.9.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = getNative;\n\n},{}],74:[function(require,module,exports){\n/**\n * lodash 3.0.9 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isIterateeCall;\n\n},{}],75:[function(require,module,exports){\n/**\n * lodash 3.1.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseAssign = require('lodash._baseassign'),\n    baseCreate = require('lodash._basecreate'),\n    isIterateeCall = require('lodash._isiterateecall');\n\n/**\n * Creates an object that inherits from the given `prototype` object. If a\n * `properties` object is provided its own enumerable properties are assigned\n * to the created object.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} prototype The object to inherit from.\n * @param {Object} [properties] The properties to assign to the object.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * function Shape() {\n *   this.x = 0;\n *   this.y = 0;\n * }\n *\n * function Circle() {\n *   Shape.call(this);\n * }\n *\n * Circle.prototype = _.create(Shape.prototype, {\n *   'constructor': Circle\n * });\n *\n * var circle = new Circle;\n * circle instanceof Circle;\n * // => true\n *\n * circle instanceof Shape;\n * // => true\n */\nfunction create(prototype, properties, guard) {\n  var result = baseCreate(prototype);\n  if (guard && isIterateeCall(prototype, properties, guard)) {\n    properties = undefined;\n  }\n  return properties ? baseAssign(result, properties) : result;\n}\n\nmodule.exports = create;\n\n},{\"lodash._baseassign\":70,\"lodash._basecreate\":72,\"lodash._isiterateecall\":74}],76:[function(require,module,exports){\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isArguments;\n\n},{}],77:[function(require,module,exports){\n/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isArray;\n\n},{}],78:[function(require,module,exports){\n/**\n * lodash 3.1.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar getNative = require('lodash._getnative'),\n    isArguments = require('lodash.isarguments'),\n    isArray = require('lodash.isarray');\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n},{\"lodash._getnative\":73,\"lodash.isarguments\":76,\"lodash.isarray\":77}],79:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"fs\":42,\"path\":42}],80:[function(require,module,exports){\nexports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n},{}],81:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n}).call(this,require('_process'))\n},{\"_process\":82}],82:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],83:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":84}],84:[function(require,module,exports){\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n},{\"./_stream_readable\":86,\"./_stream_writable\":88,\"core-util-is\":44,\"inherits\":66,\"process-nextick-args\":81}],85:[function(require,module,exports){\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":87,\"core-util-is\":44,\"inherits\":66}],86:[function(require,module,exports){\n(function (process){\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = Buffer.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":84,\"./internal/streams/BufferList\":89,\"./internal/streams/stream\":90,\"_process\":82,\"core-util-is\":44,\"events\":62,\"inherits\":66,\"isarray\":68,\"process-nextick-args\":81,\"safe-buffer\":95,\"string_decoder/\":97,\"util\":40}],87:[function(require,module,exports){\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":84,\"core-util-is\":44,\"inherits\":66}],88:[function(require,module,exports){\n(function (process){\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = Buffer.isBuffer(chunk);\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":84,\"./internal/streams/stream\":90,\"_process\":82,\"core-util-is\":44,\"inherits\":66,\"process-nextick-args\":81,\"safe-buffer\":95,\"util-deprecate\":99}],89:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nmodule.exports = BufferList;\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;\n}\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;\n};\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;\n};\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;\n};\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;\n  }return ret;\n};\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return Buffer.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = Buffer.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;\n  }\n  return ret;\n};\n},{\"safe-buffer\":95}],90:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":62}],91:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":92}],92:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":84,\"./lib/_stream_passthrough.js\":85,\"./lib/_stream_readable.js\":86,\"./lib/_stream_transform.js\":87,\"./lib/_stream_writable.js\":88}],93:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":92}],94:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":88}],95:[function(require,module,exports){\nmodule.exports = require('buffer')\n\n},{\"buffer\":43}],96:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":62,\"inherits\":66,\"readable-stream/duplex.js\":83,\"readable-stream/passthrough.js\":91,\"readable-stream/readable.js\":92,\"readable-stream/transform.js\":93,\"readable-stream/writable.js\":94}],97:[function(require,module,exports){\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":98}],98:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":43}],99:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],100:[function(require,module,exports){\narguments[4][66][0].apply(exports,arguments)\n},{\"dup\":66}],101:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],102:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":101,\"_process\":82,\"inherits\":100}]},{},[1]);\n"

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	"use strict";

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
		delete __webpack_require__.c[module.id];
		if(typeof window !== "undefined" && window.mochaPhantomJS)
			mochaPhantomJS.run();
		else
			mocha.run();
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGI4ZjE0YzE0ZjMyMTgxZTFhOGQ/MTMyZSIsIndlYnBhY2s6Ly8vLi90ZXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL3dlYi5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmNzcz83NWQwIiwid2VicGFjazovLy8uL34vbW9jaGEvbW9jaGEuY3NzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmpzP2QxOGUiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmpzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL3N0YXJ0LmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0EsaUVBQWdFLDZCQUE2QjtBQUM3RixjQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRTs7Ozs7Ozs7O0FDZEEsMENBQXlD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Q0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBLDhCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVSIsImZpbGUiOiJ0ZXN0LmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDhiOGYxNGMxNGYzMjE4MWUxYThkIiwicmVxdWlyZShcIiEhL1VzZXJzL3RtYXJxL3R1cmluZy8ybW9kL3BhaXJlZC1wcm9qZWN0cy9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5pZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKSB7IHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTsgfVxubW9jaGEuc2V0dXAoe1widWlcIjpcImJkZFwifSk7XG5yZXF1aXJlKFwiISEvVXNlcnMvdG1hcnEvdHVyaW5nLzJtb2QvcGFpcmVkLXByb2plY3RzL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEvVXNlcnMvdG1hcnEvdHVyaW5nLzJtb2QvcGFpcmVkLXByb2plY3RzL2dhbWUtdGltZS90ZXN0L2luZGV4LmpzXCIpXG5yZXF1aXJlKFwiISEvVXNlcnMvdG1hcnEvdHVyaW5nLzJtb2QvcGFpcmVkLXByb2plY3RzL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzXCIpO1xuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdCgpO1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG5cdFx0bW9jaGEuc3VpdGUuc3VpdGVzLmxlbmd0aCA9IDA7XG5cdFx0dmFyIHN0YXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXN0YXRzJyk7XG5cdFx0dmFyIHJlcG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1yZXBvcnQnKTtcblx0XHRzdGF0cyAmJiBzdGF0cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXRzKTtcblx0XHRyZXBvcnQgJiYgcmVwb3J0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVwb3J0KTtcblx0fSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlciEuL3Rlc3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiaWYgKCEgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2NoYVwiKSkgeyBkb2N1bWVudC53cml0ZShcIjxkaXYgaWQ9XFxcIm1vY2hhXFxcIj48L2Rpdj5cIik7IH1cblxucmVxdWlyZShcIiFzdHlsZS1sb2FkZXIhY3NzLWxvYWRlciFtb2NoYS9tb2NoYS5jc3NcIik7XG5yZXF1aXJlKFwiIXNjcmlwdC1sb2FkZXIhbW9jaGEvbW9jaGEuanNcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbW9jaGEtbG9hZGVyL3dlYi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIhLi9+L21vY2hhLWxvYWRlci9+L2Nzcy1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmNzc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwidXRmLThcXFwiO1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOjA7XFxufVxcblxcbiNtb2NoYSB7XFxuICBmb250OiAyMHB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgbWFyZ2luOiA2MHB4IDUwcHg7XFxufVxcblxcbiNtb2NoYSB1bCxcXG4jbW9jaGEgbGkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuI21vY2hhIHVsIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMSxcXG4jbW9jaGEgaDIge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jbW9jaGEgaDEge1xcbiAgbWFyZ2luLXRvcDogMTVweDtcXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgZm9udC13ZWlnaHQ6IDIwMDtcXG59XFxuXFxuI21vY2hhIGgxIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYSBoMSBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIC5zdWl0ZSBoMSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgZm9udC1zaXplOiAuOGVtO1xcbn1cXG5cXG4jbW9jaGEgLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDIge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6aG92ZXIgaDI6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcocGVuZGluZyknO1xcbiAgZm9udC1mYW1pbHk6IGFyaWFsLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5tZWRpdW0gLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNjMDk4NTM7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLnNsb3cgLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNiOTRhNDg7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNzEzJztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjMDBkNmIyO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcyAuZHVyYXRpb24ge1xcbiAgZm9udC1zaXplOiA5cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgcGFkZGluZzogMnB4IDVweDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtbXMtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW8tYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5mYXN0IC5kdXJhdGlvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZyB7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI1RTYnO1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsIHtcXG4gIGNvbG9yOiAjYzAwO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCBwcmUge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjcxNic7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHByZS5lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGNvbG9yOiBibGFjaztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiAtbW96LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciBwcmUuZXJyb3Ige1xcbiAgYm9yZGVyOiBub25lO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMDtcXG4gIC1tb3otYm94LXNoYWRvdzogMDtcXG4gIGJveC1zaGFkb3c6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgbWFyZ2luLXRvcDogMThweDtcXG4gIG1heC1oZWlnaHQ6IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqICgxKTogYXBwcm94aW1hdGUgZm9yIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIGNhbGNcXG4gKiAoMik6IDQyID0gMioxNSArIDIqMTAgKyAyKjEgKHBhZGRpbmcgKyBtYXJnaW4gKyBib3JkZXIpXFxuICogICAgICBeXiBzZXJpb3VzbHlcXG4gKi9cXG4jbW9jaGEgLnRlc3QgcHJlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQ6IDEycHgvMS41IG1vbmFjbywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiA1cHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1heC13aWR0aDogODUlOyAvKigxKSovXFxuICBtYXgtd2lkdGg6IC13ZWJraXQtY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IC1tb3otY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDQycHgpOyAvKigyKSovXFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCBoMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbiNtb2NoYSAudGVzdCBhLnJlcGxheSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDNweDtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBsaW5lLWhlaWdodDogMTVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICAtbW96LXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIC1vLXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XFxuICBvcGFjaXR5OiAwLjM7XFxuICBjb2xvcjogIzg4ODtcXG59XFxuXFxuI21vY2hhIC50ZXN0OmhvdmVyIGEucmVwbGF5IHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGFzcyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQuZmFpbCAudGVzdC5wYXNzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLFxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLnBlbmRpbmcge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbiNtb2NoYS1lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIGZvbnQtc2l6ZTogMS41ZW07XFxuICBmb250LXdlaWdodDogMTAwO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMTVweDtcXG4gIHJpZ2h0OiAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgY29sb3I6ICM4ODg7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgLnByb2dyZXNzIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHBhZGRpbmctdG9wOiAwO1xcblxcbiAgLyoqXFxuICAgKiBTZXQgc2FmZSBpbml0aWFsIHZhbHVlcywgc28gbW9jaGFzIC5wcm9ncmVzcyBkb2VzIG5vdCBpbmhlcml0IHRoZXNlXFxuICAgKiBwcm9wZXJ0aWVzIGZyb20gQm9vdHN0cmFwIC5wcm9ncmVzcyAod2hpY2ggY2F1c2VzIC5wcm9ncmVzcyBoZWlnaHQgdG9cXG4gICAqIGVxdWFsIGxpbmUgaGVpZ2h0IHNldCBpbiBCb290c3RyYXApLlxcbiAgICovXFxuICBoZWlnaHQ6IGF1dG87XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAtbW96LWJveC1zaGFkb3c6IG5vbmU7XFxuICBib3gtc2hhZG93OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5pdGlhbDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGVtIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhLXN0YXRzIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhOmhvdmVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwIDVweDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nLXRvcDogMTFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGNhbnZhcyB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuI21vY2hhIGNvZGUgLmNvbW1lbnQgeyBjb2xvcjogI2RkZDsgfVxcbiNtb2NoYSBjb2RlIC5pbml0IHsgY29sb3I6ICMyZjZmYWQ7IH1cXG4jbW9jaGEgY29kZSAuc3RyaW5nIHsgY29sb3I6ICM1ODkwYWQ7IH1cXG4jbW9jaGEgY29kZSAua2V5d29yZCB7IGNvbG9yOiAjOGE2MzQzOyB9XFxuI21vY2hhIGNvZGUgLm51bWJlciB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1kZXZpY2Utd2lkdGg6IDQ4MHB4KSB7XFxuICAjbW9jaGEge1xcbiAgICBtYXJnaW46IDYwcHggMHB4O1xcbiAgfVxcblxcbiAgI21vY2hhICNzdGF0cyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9+L2Nzcy1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmNzc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbW9jaGEtbG9hZGVyL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJyZXF1aXJlKFwiISEvVXNlcnMvdG1hcnEvdHVyaW5nLzJtb2QvcGFpcmVkLXByb2plY3RzL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL3RtYXJxL3R1cmluZy8ybW9kL3BhaXJlZC1wcm9qZWN0cy9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL3RtYXJxL3R1cmluZy8ybW9kL3BhaXJlZC1wcm9qZWN0cy9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9tb2NoYS9tb2NoYS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK28rXFxcIidcXFwiKTt0aHJvdyBmLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IG9mZiAqL1xcbi8qIGVzbGludC1lbnYgY29tbW9uanMgKi9cXG5cXG4vKipcXG4gKiBTaGltIHByb2Nlc3Muc3Rkb3V0LlxcbiAqL1xcblxcbnByb2Nlc3Muc3Rkb3V0ID0gcmVxdWlyZSgnYnJvd3Nlci1zdGRvdXQnKSgpO1xcblxcbnZhciBNb2NoYSA9IHJlcXVpcmUoJy4vbGliL21vY2hhJyk7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgTW9jaGEgaW5zdGFuY2UuXFxuICpcXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XFxuICovXFxuXFxudmFyIG1vY2hhID0gbmV3IE1vY2hhKHsgcmVwb3J0ZXI6ICdodG1sJyB9KTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG5cXG52YXIgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycyA9IFtdO1xcblxcbnZhciBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyID0gZ2xvYmFsLm9uZXJyb3I7XFxuXFxuLyoqXFxuICogUmVtb3ZlIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqIFJldmVydCB0byBvcmlnaW5hbCBvbmVycm9yIGhhbmRsZXIgaWYgcHJldmlvdXNseSBkZWZpbmVkLlxcbiAqL1xcblxcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSwgZm4pIHtcXG4gIGlmIChlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XFxuICAgIGlmIChvcmlnaW5hbE9uZXJyb3JIYW5kbGVyKSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24gKCkge307XFxuICAgIH1cXG4gICAgdmFyIGkgPSBNb2NoYS51dGlscy5pbmRleE9mKHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMsIGZuKTtcXG4gICAgaWYgKGkgIT09IC0xKSB7XFxuICAgICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5zcGxpY2UoaSwgMSk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEltcGxlbWVudHMgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXFxuICovXFxuXFxucHJvY2Vzcy5vbiA9IGZ1bmN0aW9uIChlLCBmbikge1xcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcXG4gICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyLCB1cmwsIGxpbmUpIHtcXG4gICAgICBmbihuZXcgRXJyb3IoZXJyICsgJyAoJyArIHVybCArICc6JyArIGxpbmUgKyAnKScpKTtcXG4gICAgICByZXR1cm4gIW1vY2hhLmFsbG93VW5jYXVnaHQ7XFxuICAgIH07XFxuICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMucHVzaChmbik7XFxuICB9XFxufTtcXG5cXG4vLyBUaGUgQkREIFVJIGlzIHJlZ2lzdGVyZWQgYnkgZGVmYXVsdCwgYnV0IG5vIFVJIHdpbGwgYmUgZnVuY3Rpb25hbCBpbiB0aGVcXG4vLyBicm93c2VyIHdpdGhvdXQgYW4gZXhwbGljaXQgY2FsbCB0byB0aGUgb3ZlcnJpZGRlbiBgbW9jaGEudWlgIChzZWUgYmVsb3cpLlxcbi8vIEVuc3VyZSB0aGF0IHRoaXMgZGVmYXVsdCBVSSBkb2VzIG5vdCBleHBvc2UgaXRzIG1ldGhvZHMgdG8gdGhlIGdsb2JhbCBzY29wZS5cXG5tb2NoYS5zdWl0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ByZS1yZXF1aXJlJyk7XFxuXFxudmFyIGltbWVkaWF0ZVF1ZXVlID0gW107XFxudmFyIGltbWVkaWF0ZVRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gdGltZXNsaWNlICgpIHtcXG4gIHZhciBpbW1lZGlhdGVTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgd2hpbGUgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCAmJiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBpbW1lZGlhdGVTdGFydCkgPCAxMDApIHtcXG4gICAgaW1tZWRpYXRlUXVldWUuc2hpZnQoKSgpO1xcbiAgfVxcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfSBlbHNlIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IG51bGw7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEhpZ2gtcGVyZm9ybWFuY2Ugb3ZlcnJpZGUgb2YgUnVubmVyLmltbWVkaWF0ZWx5LlxcbiAqL1xcblxcbk1vY2hhLlJ1bm5lci5pbW1lZGlhdGVseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgaW1tZWRpYXRlUXVldWUucHVzaChjYWxsYmFjayk7XFxuICBpZiAoIWltbWVkaWF0ZVRpbWVvdXQpIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZ1bmN0aW9uIHRvIGFsbG93IGFzc2VydGlvbiBsaWJyYXJpZXMgdG8gdGhyb3cgZXJyb3JzIGRpcmVjdGx5IGludG8gbW9jaGEuXFxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiBydW5uaW5nIHRlc3RzIGluIGEgYnJvd3NlciBiZWNhdXNlIHdpbmRvdy5vbmVycm9yIHdpbGxcXG4gKiBvbmx5IHJlY2VpdmUgdGhlICdtZXNzYWdlJyBhdHRyaWJ1dGUgb2YgdGhlIEVycm9yLlxcbiAqL1xcbm1vY2hhLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICBNb2NoYS51dGlscy5mb3JFYWNoKHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMsIGZ1bmN0aW9uIChmbikge1xcbiAgICBmbihlcnIpO1xcbiAgfSk7XFxuICB0aHJvdyBlcnI7XFxufTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSB1aSB0byBlbnN1cmUgdGhhdCB0aGUgdWkgZnVuY3Rpb25zIGFyZSBpbml0aWFsaXplZC5cXG4gKiBOb3JtYWxseSB0aGlzIHdvdWxkIGhhcHBlbiBpbiBNb2NoYS5wcm90b3R5cGUubG9hZEZpbGVzLlxcbiAqL1xcblxcbm1vY2hhLnVpID0gZnVuY3Rpb24gKHVpKSB7XFxuICBNb2NoYS5wcm90b3R5cGUudWkuY2FsbCh0aGlzLCB1aSk7XFxuICB0aGlzLnN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBudWxsLCB0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0dXAgbW9jaGEgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZyBvcHRpb25zLlxcbiAqL1xcblxcbm1vY2hhLnNldHVwID0gZnVuY3Rpb24gKG9wdHMpIHtcXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcXG4gICAgb3B0cyA9IHsgdWk6IG9wdHMgfTtcXG4gIH1cXG4gIGZvciAodmFyIG9wdCBpbiBvcHRzKSB7XFxuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG9wdCkpIHtcXG4gICAgICB0aGlzW29wdF0ob3B0c1tvcHRdKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gbW9jaGEsIHJldHVybmluZyB0aGUgUnVubmVyLlxcbiAqL1xcblxcbm1vY2hhLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIG9wdGlvbnMgPSBtb2NoYS5vcHRpb25zO1xcbiAgbW9jaGEuZ2xvYmFscygnbG9jYXRpb24nKTtcXG5cXG4gIHZhciBxdWVyeSA9IE1vY2hhLnV0aWxzLnBhcnNlUXVlcnkoZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCB8fCAnJyk7XFxuICBpZiAocXVlcnkuZ3JlcCkge1xcbiAgICBtb2NoYS5ncmVwKHF1ZXJ5LmdyZXApO1xcbiAgfVxcbiAgaWYgKHF1ZXJ5LmZncmVwKSB7XFxuICAgIG1vY2hhLmZncmVwKHF1ZXJ5LmZncmVwKTtcXG4gIH1cXG4gIGlmIChxdWVyeS5pbnZlcnQpIHtcXG4gICAgbW9jaGEuaW52ZXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gTW9jaGEucHJvdG90eXBlLnJ1bi5jYWxsKG1vY2hhLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIC8vIFRoZSBET00gRG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2Vycy5cXG4gICAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xcbiAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykgJiYgb3B0aW9ucy5ub0hpZ2hsaWdodGluZyAhPT0gdHJ1ZSkge1xcbiAgICAgIE1vY2hhLnV0aWxzLmhpZ2hsaWdodFRhZ3MoJ2NvZGUnKTtcXG4gICAgfVxcbiAgICBpZiAoZm4pIHtcXG4gICAgICBmbihlcnIpO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0aGUgcHJvY2VzcyBzaGltLlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvOTE2XFxuICovXFxuXFxuTW9jaGEucHJvY2VzcyA9IHByb2Nlc3M7XFxuXFxuLyoqXFxuICogRXhwb3NlIG1vY2hhLlxcbiAqL1xcblxcbmdsb2JhbC5Nb2NoYSA9IE1vY2hhO1xcbmdsb2JhbC5tb2NoYSA9IG1vY2hhO1xcblxcbi8vIHRoaXMgYWxsb3dzIHRlc3QvYWNjZXB0YW5jZS9yZXF1aXJlZC10b2tlbnMuanMgdG8gcGFzczsgdGh1cyxcXG4vLyB5b3UgY2FuIG5vdyBkbyBgY29uc3QgZGVzY3JpYmUgPSByZXF1aXJlKCdtb2NoYScpLmRlc2NyaWJlYCBpbiBhXFxuLy8gYnJvd3NlciBjb250ZXh0IChhc3N1bWluZyBicm93c2VyaWZpY2F0aW9uKS4gIHNob3VsZCBmaXggIzg4MFxcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbGliL21vY2hhXFxcIjoxNCxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJicm93c2VyLXN0ZG91dFxcXCI6NDF9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuZnVuY3Rpb24gbm9vcCAoKSB7fVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIG5vb3A7XFxufTtcXG5cXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGV4cG9ydHMuXFxuICovXFxuXFxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nIHJlZmVyZW5jZS5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdC5cXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlLlxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXkgKHZhbCkge1xcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcXG59XFxuXFxuLyoqXFxuICogRXZlbnQgZW1pdHRlciBjb25zdHJ1Y3Rvci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyICgpIHt9XFxuXFxuLyoqXFxuICogQWRkIGEgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgaWYgKCF0aGlzLiRldmVudHMpIHtcXG4gICAgdGhpcy4kZXZlbnRzID0ge307XFxuICB9XFxuXFxuICBpZiAoIXRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBmbjtcXG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLiRldmVudHNbbmFtZV0pKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXS5wdXNoKGZuKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IFt0aGlzLiRldmVudHNbbmFtZV0sIGZuXTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XFxuXFxuLyoqXFxuICogQWRkcyBhIHZvbGF0aWxlIGxpc3RlbmVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIuXFxuICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBFbWl0dGVyIGluc3RhbmNlLlxcbiAqL1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gb24gKCkge1xcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKG5hbWUsIG9uKTtcXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIG9uLmxpc3RlbmVyID0gZm47XFxuICB0aGlzLm9uKG5hbWUsIG9uKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlIGEgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgaWYgKHRoaXMuJGV2ZW50cyAmJiB0aGlzLiRldmVudHNbbmFtZV0pIHtcXG4gICAgdmFyIGxpc3QgPSB0aGlzLiRldmVudHNbbmFtZV07XFxuXFxuICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XFxuICAgICAgdmFyIHBvcyA9IC0xO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIGlmIChsaXN0W2ldID09PSBmbiB8fCAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBmbikpIHtcXG4gICAgICAgICAgcG9zID0gaTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3MgPCAwKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuXFxuICAgICAgbGlzdC5zcGxpY2UocG9zLCAxKTtcXG5cXG4gICAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XFxuICAgICAgICBkZWxldGUgdGhpcy4kZXZlbnRzW25hbWVdO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChsaXN0ID09PSBmbiB8fCAobGlzdC5saXN0ZW5lciAmJiBsaXN0Lmxpc3RlbmVyID09PSBmbikpIHtcXG4gICAgICBkZWxldGUgdGhpcy4kZXZlbnRzW25hbWVdO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhbiBldmVudC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBpZiAodGhpcy4kZXZlbnRzICYmIHRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYWxsIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgaWYgKCF0aGlzLiRldmVudHMpIHtcXG4gICAgdGhpcy4kZXZlbnRzID0ge307XFxuICB9XFxuXFxuICBpZiAoIXRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBbXTtcXG4gIH1cXG5cXG4gIGlmICghaXNBcnJheSh0aGlzLiRldmVudHNbbmFtZV0pKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IFt0aGlzLiRldmVudHNbbmFtZV1dO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuJGV2ZW50c1tuYW1lXTtcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgYW4gZXZlbnQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgaGFuZGxlciB3YXMgaW52b2tlZCwgZWxzZSBmYWxzZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgaWYgKCF0aGlzLiRldmVudHMpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLiRldmVudHNbbmFtZV07XFxuXFxuICBpZiAoIWhhbmRsZXIpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcblxcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XFxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBpbmRpY2F0b3IuXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MgKCkge1xcbiAgdGhpcy5wZXJjZW50ID0gMDtcXG4gIHRoaXMuc2l6ZSgwKTtcXG4gIHRoaXMuZm9udFNpemUoMTEpO1xcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBwcm9ncmVzcyBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXh0IHRvIGB0ZXh0YC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xcbiAgdGhpcy5fdGV4dCA9IHRleHQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgdGhpcy5fZm9udFNpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCB0byBgZmFtaWx5YC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbiAoZmFtaWx5KSB7XFxuICB0aGlzLl9mb250ID0gZmFtaWx5O1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBVcGRhdGUgcGVyY2VudGFnZSB0byBgbmAuXFxuICpcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMucGVyY2VudCA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgb24gYGN0eGAuXFxuICpcXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XFxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcXG4gICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcXG4gICAgdmFyIHggPSBoYWxmO1xcbiAgICB2YXIgeSA9IGhhbGY7XFxuICAgIHZhciByYWQgPSBoYWxmIC0gMTtcXG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XFxuXFxuICAgIGN0eC5mb250ID0gZm9udFNpemUgKyAncHggJyArIHRoaXMuX2ZvbnQ7XFxuXFxuICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyICogKHBlcmNlbnQgLyAxMDApO1xcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xcblxcbiAgICAvLyBvdXRlciBjaXJjbGVcXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyM5ZjlmOWYnO1xcbiAgICBjdHguYmVnaW5QYXRoKCk7XFxuICAgIGN0eC5hcmMoeCwgeSwgcmFkLCAwLCBhbmdsZSwgZmFsc2UpO1xcbiAgICBjdHguc3Ryb2tlKCk7XFxuXFxuICAgIC8vIGlubmVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2VlZSc7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQgLSAxLCAwLCBhbmdsZSwgdHJ1ZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gdGV4dFxcbiAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQgfHwgKHBlcmNlbnQgfCAwKSArICclJztcXG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XFxuXFxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4IC0gdyAvIDIgKyAxLCB5ICsgZm9udFNpemUgLyAyIC0gMSk7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgLy8gZG9uJ3QgZmFpbCBpZiB3ZSBjYW4ndCByZW5kZXIgcHJvZ3Jlc3NcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLmlzYXR0eSA9IGZ1bmN0aW9uIGlzYXR0eSAoKSB7XFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbmV4cG9ydHMuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uIGdldFdpbmRvd1NpemUgKCkge1xcbiAgaWYgKCdpbm5lckhlaWdodCcgaW4gZ2xvYmFsKSB7XFxuICAgIHJldHVybiBbZ2xvYmFsLmlubmVySGVpZ2h0LCBnbG9iYWwuaW5uZXJXaWR0aF07XFxuICB9XFxuICAvLyBJbiBhIFdlYiBXb3JrZXIsIHRoZSBET00gV2luZG93IGlzIG5vdCBhdmFpbGFibGUuXFxuICByZXR1cm4gWzY0MCwgNDgwXTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBKU09OID0gcmVxdWlyZSgnanNvbjMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYENvbnRleHRgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDb250ZXh0YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIENvbnRleHQgKCkge31cXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRoZSBjb250ZXh0IGBSdW5uYWJsZWAgdG8gYHJ1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXFxuICogQHJldHVybiB7Q29udGV4dH1cXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5ydW5uYWJsZSA9IGZ1bmN0aW9uIChydW5uYWJsZSkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9ydW5uYWJsZTtcXG4gIH1cXG4gIHRoaXMudGVzdCA9IHRoaXMuX3J1bm5hYmxlID0gcnVubmFibGU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS50aW1lb3V0KCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkudGltZW91dChtcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IHRpbWVvdXQgYGVuYWJsZWRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIHRoaXMucnVubmFibGUoKS5lbmFibGVUaW1lb3V0cyhlbmFibGVkKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3Qgc2xvd25lc3MgdGhyZXNob2xkIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xcbiAgdGhpcy5ydW5uYWJsZSgpLnNsb3cobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBNYXJrIGEgdGVzdCBhcyBza2lwcGVkLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLnJ1bm5hYmxlKCkuc2tpcCgpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBbGxvdyBhIG51bWJlciBvZiByZXRyaWVzIG9uIGZhaWxlZCB0ZXN0c1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSW5zcGVjdCB0aGUgY29udGV4dCB2b2lkIG9mIGAuX3J1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xcbiAgICByZXR1cm4ga2V5ID09PSAncnVubmFibGUnIHx8IGtleSA9PT0gJ3Rlc3QnID8gdW5kZWZpbmVkIDogdmFsO1xcbiAgfSwgMik7XFxufTtcXG5cXG59LHtcXFwianNvbjNcXFwiOjY5fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhvb2tgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gSG9vaztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBIb29rICh0aXRsZSwgZm4pIHtcXG4gIFJ1bm5hYmxlLmNhbGwodGhpcywgdGl0bGUsIGZuKTtcXG4gIHRoaXMudHlwZSA9ICdob29rJztcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKEhvb2ssIFJ1bm5hYmxlKTtcXG5cXG4vKipcXG4gKiBHZXQgb3Igc2V0IHRoZSB0ZXN0IGBlcnJgLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7RXJyb3J9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Ib29rLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBlcnIgPSB0aGlzLl9lcnJvcjtcXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xcbiAgICByZXR1cm4gZXJyO1xcbiAgfVxcblxcbiAgdGhpcy5fZXJyb3IgPSBlcnI7XFxufTtcXG5cXG59LHtcXFwiLi9ydW5uYWJsZVxcXCI6MzMsXFxcIi4vdXRpbHNcXFwiOjM4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogQkRELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgZGVzY3JpYmUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgICAgLy8gLi4uXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKiAgICAgICAgfSk7XFxuICogICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgXFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xcbiAgICAgKiBhbmQvb3IgdGVzdHMuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LmRlc2NyaWJlID0gY29udGV4dC5jb250ZXh0ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgZGVzY3JpYmUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhkZXNjcmliZSA9IGNvbnRleHQueGNvbnRleHQgPSBjb250ZXh0LmRlc2NyaWJlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5za2lwKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSBzdWl0ZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuZGVzY3JpYmUub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdCA9IGNvbnRleHQuc3BlY2lmeSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XFxuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0Lml0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhpdCA9IGNvbnRleHQueHNwZWNpZnkgPSBjb250ZXh0Lml0LnNraXAgPSBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICBjb250ZXh0Lml0KHRpdGxlKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIE51bWJlciBvZiBhdHRlbXB0cyB0byByZXRyeS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuaXQucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgY29udGV4dC5yZXRyaWVzKG4pO1xcbiAgICB9O1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vdGVzdFxcXCI6MzYsXFxcIi4vY29tbW9uXFxcIjo5fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XFxuXFxuLyoqXFxuICogRnVuY3Rpb25zIGNvbW1vbiB0byBtb3JlIHRoYW4gb25lIGludGVyZmFjZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGVbXX0gc3VpdGVzXFxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XFxuICogQHBhcmFtIHtNb2NoYX0gbW9jaGFcXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbW1vbiBmdW5jdGlvbnMuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSkge1xcbiAgcmV0dXJuIHtcXG4gICAgLyoqXFxuICAgICAqIFRoaXMgaXMgb25seSBwcmVzZW50IGlmIGZsYWcgLS1kZWxheSBpcyBwYXNzZWQgaW50byBNb2NoYS4gSXQgdHJpZ2dlcnNcXG4gICAgICogcm9vdCBzdWl0ZSBleGVjdXRpb24uXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFRoZSByb290IHN1aXRlLlxcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB3aGljaCBydW5zIHRoZSByb290IHN1aXRlXFxuICAgICAqL1xcbiAgICBydW5XaXRoU3VpdGU6IGZ1bmN0aW9uIHJ1bldpdGhTdWl0ZSAoc3VpdGUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcnVuICgpIHtcXG4gICAgICAgIHN1aXRlLnJ1bigpO1xcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGFmdGVyOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmVFYWNoOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlRWFjaChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXJFYWNoOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgc3VpdGU6IHtcXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGUgYW4gZXhjbHVzaXZlIFN1aXRlOyBjb252ZW5pZW5jZSBmdW5jdGlvblxcbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgb25seTogZnVuY3Rpb24gb25seSAob3B0cykge1xcbiAgICAgICAgbW9jaGEub3B0aW9ucy5oYXNPbmx5ID0gdHJ1ZTtcXG4gICAgICAgIG9wdHMuaXNPbmx5ID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRzKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZSBhIFN1aXRlLCBidXQgc2tpcCBpdDsgY29udmVuaWVuY2UgZnVuY3Rpb25cXG4gICAgICAgKiBTZWUgZG9jc3RyaW5nIGZvciBjcmVhdGUoKSBiZWxvdy5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXFxuICAgICAgICogQHJldHVybnMge1N1aXRlfVxcbiAgICAgICAqL1xcbiAgICAgIHNraXA6IGZ1bmN0aW9uIHNraXAgKG9wdHMpIHtcXG4gICAgICAgIG9wdHMucGVuZGluZyA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGVzIGEgc3VpdGUuXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uc1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRpdGxlIFRpdGxlIG9mIFN1aXRlXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZm5dIFN1aXRlIEZ1bmN0aW9uIChub3QgYWx3YXlzIGFwcGxpY2FibGUpXFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wZW5kaW5nXSBJcyBTdWl0ZSBwZW5kaW5nP1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5maWxlXSBGaWxlcGF0aCB3aGVyZSB0aGlzIFN1aXRlIHJlc2lkZXNcXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmlzT25seV0gSXMgU3VpdGUgZXhjbHVzaXZlP1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAob3B0cykge1xcbiAgICAgICAgdmFyIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwgb3B0cy50aXRsZSk7XFxuICAgICAgICBzdWl0ZS5wZW5kaW5nID0gQm9vbGVhbihvcHRzLnBlbmRpbmcpO1xcbiAgICAgICAgc3VpdGUuZmlsZSA9IG9wdHMuZmlsZTtcXG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICAgIGlmIChvcHRzLmlzT25seSkge1xcbiAgICAgICAgICBzdWl0ZS5wYXJlbnQuX29ubHlTdWl0ZXMgPSBzdWl0ZS5wYXJlbnQuX29ubHlTdWl0ZXMuY29uY2F0KHN1aXRlKTtcXG4gICAgICAgICAgbW9jaGEub3B0aW9ucy5oYXNPbmx5ID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBvcHRzLmZuLmNhbGwoc3VpdGUpO1xcbiAgICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICd1bmRlZmluZWQnICYmICFzdWl0ZS5wZW5kaW5nKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VpdGUgXFxcIicgKyBzdWl0ZS5mdWxsVGl0bGUoKSArICdcXFwiIHdhcyBkZWZpbmVkIGJ1dCBubyBjYWxsYmFjayB3YXMgc3VwcGxpZWQuIFN1cHBseSBhIGNhbGxiYWNrIG9yIGV4cGxpY2l0bHkgc2tpcCB0aGUgc3VpdGUuJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gc3VpdGU7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICB0ZXN0OiB7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2NoYVxcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3RcXG4gICAgICAgKiBAcmV0dXJucyB7Kn1cXG4gICAgICAgKi9cXG4gICAgICBvbmx5OiBmdW5jdGlvbiAobW9jaGEsIHRlc3QpIHtcXG4gICAgICAgIHRlc3QucGFyZW50Ll9vbmx5VGVzdHMgPSB0ZXN0LnBhcmVudC5fb25seVRlc3RzLmNvbmNhdCh0ZXN0KTtcXG4gICAgICAgIG1vY2hhLm9wdGlvbnMuaGFzT25seSA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGVzdDtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFBlbmRpbmcgdGVzdCBjYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICAgICAgICovXFxuICAgICAgc2tpcDogZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgICBjb250ZXh0LnRlc3QodGl0bGUpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxcbiAgICAgICAqL1xcbiAgICAgIHJldHJpZXM6IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICBjb250ZXh0LnJldHJpZXMobik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNX1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIEV4cG9ydHMtc3R5bGUgKGFzIE5vZGUuanMgbW9kdWxlKSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgZXhwb3J0cy5BcnJheSA9IHtcXG4gKiAgICAgICAnI2luZGV4T2YoKSc6IHtcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIC0xIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH0sXFxuICpcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IGluZGV4IHdoZW4gdGhlIHZhbHVlIGlzIHByZXNlbnQnOiBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgfVxcbiAqICAgICAgIH1cXG4gKiAgICAgfTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3JlcXVpcmUnLCB2aXNpdCk7XFxuXFxuICBmdW5jdGlvbiB2aXNpdCAob2JqLCBmaWxlKSB7XFxuICAgIHZhciBzdWl0ZTtcXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhciBmbiA9IG9ialtrZXldO1xcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYWZ0ZXInOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckFsbChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2JlZm9yZUVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYWZ0ZXJFYWNoJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KGtleSwgZm4pO1xcbiAgICAgICAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwga2V5KTtcXG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICAgIHZpc2l0KG9ialtrZXldLCBmaWxlKTtcXG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNSxcXFwiLi4vdGVzdFxcXCI6MzZ9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuYmRkID0gcmVxdWlyZSgnLi9iZGQnKTtcXG5leHBvcnRzLnRkZCA9IHJlcXVpcmUoJy4vdGRkJyk7XFxuZXhwb3J0cy5xdW5pdCA9IHJlcXVpcmUoJy4vcXVuaXQnKTtcXG5leHBvcnRzLmV4cG9ydHMgPSByZXF1aXJlKCcuL2V4cG9ydHMnKTtcXG5cXG59LHtcXFwiLi9iZGRcXFwiOjgsXFxcIi4vZXhwb3J0c1xcXCI6MTAsXFxcIi4vcXVuaXRcXFwiOjEyLFxcXCIuL3RkZFxcXCI6MTN9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogUVVuaXQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIHN1aXRlKCdBcnJheScpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMSkgPT0gMCk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMikgPT0gMSk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjbGVuZ3RoJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSBTdWl0ZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZhbHNlXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXFxuICAgICAqIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmBcXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNixcXFwiLi9jb21tb25cXFwiOjl9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogVERELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgc3VpdGUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgc3VpdGVTZXR1cChmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBzdWl0ZVRlYXJkb3duKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcXG5cXG4gICAgY29udGV4dC5zZXR1cCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LnRlYXJkb3duID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5zdWl0ZVNldHVwID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5zdWl0ZVRlYXJkb3duID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nXFxuICAgICAqIG5lc3RlZCBzdWl0ZXMgYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHN1aXRlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5za2lwID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuc2tpcCh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kXFxuICAgICAqIGNhbGxiYWNrIGBmbmAgYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0LnRlc3QodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIGNvbnRleHQudGVzdC5za2lwID0gY29tbW9uLnRlc3Quc2tpcDtcXG4gICAgY29udGV4dC50ZXN0LnJldHJpZXMgPSBjb21tb24udGVzdC5yZXRyaWVzO1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vdGVzdFxcXCI6MzYsXFxcIi4vY29tbW9uXFxcIjo5fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsX19kaXJuYW1lKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyohXFxuICogbW9jaGFcXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxcbiAqIE1JVCBMaWNlbnNlZFxcbiAqL1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgcmVwb3J0ZXJzID0gcmVxdWlyZSgnLi9yZXBvcnRlcnMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBNb2NoYWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XFxuXFxuLyoqXFxuICogVG8gcmVxdWlyZSBsb2NhbCBVSXMgYW5kIHJlcG9ydGVycyB3aGVuIHJ1bm5pbmcgaW4gbm9kZS5cXG4gKi9cXG5cXG5pZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XFxuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBpbnRlcm5hbHMuXFxuICovXFxuXFxuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xcbmV4cG9ydHMuaW50ZXJmYWNlcyA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcycpO1xcbmV4cG9ydHMucmVwb3J0ZXJzID0gcmVwb3J0ZXJzO1xcbmV4cG9ydHMuUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxuZXhwb3J0cy5Db250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XFxuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xcbmV4cG9ydHMuU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XFxuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XFxuZXhwb3J0cy5UZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGltYWdlIGBuYW1lYCBwYXRoLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gaW1hZ2UgKG5hbWUpIHtcXG4gIHJldHVybiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vaW1hZ2VzJywgbmFtZSArICcucG5nJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCB1cCBtb2NoYSB3aXRoIGBvcHRpb25zYC5cXG4gKlxcbiAqIE9wdGlvbnM6XFxuICpcXG4gKiAgIC0gYHVpYCBuYW1lIFxcXCJiZGRcXFwiLCBcXFwidGRkXFxcIiwgXFxcImV4cG9ydHNcXFwiIGV0Y1xcbiAqICAgLSBgcmVwb3J0ZXJgIHJlcG9ydGVyIGluc3RhbmNlLCBkZWZhdWx0cyB0byBgbW9jaGEucmVwb3J0ZXJzLnNwZWNgXFxuICogICAtIGBnbG9iYWxzYCBhcnJheSBvZiBhY2NlcHRlZCBnbG9iYWxzXFxuICogICAtIGB0aW1lb3V0YCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xcbiAqICAgLSBgcmV0cmllc2AgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0c1xcbiAqICAgLSBgYmFpbGAgYmFpbCBvbiB0aGUgZmlyc3QgdGVzdCBmYWlsdXJlXFxuICogICAtIGBzbG93YCBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgY29uc2lkZXJpbmcgYSB0ZXN0IHNsb3dcXG4gKiAgIC0gYGlnbm9yZUxlYWtzYCBpZ25vcmUgZ2xvYmFsIGxlYWtzXFxuICogICAtIGBmdWxsVHJhY2VgIGRpc3BsYXkgdGhlIGZ1bGwgc3RhY2stdHJhY2Ugb24gZmFpbGluZ1xcbiAqICAgLSBgZ3JlcGAgc3RyaW5nIG9yIHJlZ2V4cCB0byBmaWx0ZXIgdGVzdHMgd2l0aFxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIE1vY2hhIChvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHRoaXMuZmlsZXMgPSBbXTtcXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHRoaXMuZ3JlcChuZXcgUmVnRXhwKG9wdGlvbnMuZ3JlcCkpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZmdyZXApIHtcXG4gICAgdGhpcy5mZ3JlcChvcHRpb25zLmZncmVwKTtcXG4gIH1cXG4gIHRoaXMuc3VpdGUgPSBuZXcgZXhwb3J0cy5TdWl0ZSgnJywgbmV3IGV4cG9ydHMuQ29udGV4dCgpKTtcXG4gIHRoaXMudWkob3B0aW9ucy51aSk7XFxuICB0aGlzLmJhaWwob3B0aW9ucy5iYWlsKTtcXG4gIHRoaXMucmVwb3J0ZXIob3B0aW9ucy5yZXBvcnRlciwgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMpO1xcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMudGltZW91dCAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcXG4gIH1cXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXRyaWVzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnJldHJpZXMgIT09IG51bGwpIHtcXG4gICAgdGhpcy5yZXRyaWVzKG9wdGlvbnMucmV0cmllcyk7XFxuICB9XFxuICB0aGlzLnVzZUNvbG9ycyhvcHRpb25zLnVzZUNvbG9ycyk7XFxuICBpZiAob3B0aW9ucy5lbmFibGVUaW1lb3V0cyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLmVuYWJsZVRpbWVvdXRzKG9wdGlvbnMuZW5hYmxlVGltZW91dHMpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuc2xvdykge1xcbiAgICB0aGlzLnNsb3cob3B0aW9ucy5zbG93KTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRW5hYmxlIG9yIGRpc2FibGUgYmFpbGluZyBvbiB0aGUgZmlyc3QgZmFpbHVyZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBbYmFpbF1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYmFpbCA9IGZ1bmN0aW9uIChiYWlsKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgYmFpbCA9IHRydWU7XFxuICB9XFxuICB0aGlzLnN1aXRlLmJhaWwoYmFpbCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCB0ZXN0IGBmaWxlYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWRkRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XFxuICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcXFwic3BlY1xcXCIuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcmVwb3J0ZXJPcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb3J0ZXIsIHJlcG9ydGVyT3B0aW9ucykge1xcbiAgaWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVwb3J0ZXIgPSByZXBvcnRlciB8fCAnc3BlYyc7XFxuICAgIHZhciBfcmVwb3J0ZXI7XFxuICAgIC8vIFRyeSB0byBsb2FkIGEgYnVpbHQtaW4gcmVwb3J0ZXIuXFxuICAgIGlmIChyZXBvcnRlcnNbcmVwb3J0ZXJdKSB7XFxuICAgICAgX3JlcG9ydGVyID0gcmVwb3J0ZXJzW3JlcG9ydGVyXTtcXG4gICAgfVxcbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgX3JlcG9ydGVyID0gcmVxdWlyZShyZXBvcnRlcik7XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignQ2Fubm90IGZpbmQgbW9kdWxlJykgIT09IC0xKSB7XFxuICAgICAgICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIGEgcGF0aCAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpXFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgX3JlcG9ydGVyID0gcmVxdWlyZShwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVwb3J0ZXIpKTtcXG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLmluZGV4T2YoJ0Nhbm5vdCBmaW5kIG1vZHVsZScpICE9PSAtMSA/IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIG5vdCBmb3VuZCcpXFxuICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIGJsZXcgdXAgd2l0aCBlcnJvcjpcXFxcbicgKyBlcnIuc3RhY2spO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBibGV3IHVwIHdpdGggZXJyb3I6XFxcXG4nICsgZXJyLnN0YWNrKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFfcmVwb3J0ZXIgJiYgcmVwb3J0ZXIgPT09ICd0ZWFtY2l0eScpIHtcXG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBUZWFtY2l0eSByZXBvcnRlciB3YXMgbW92ZWQgdG8gYSBwYWNrYWdlIG5hbWVkICcgK1xcbiAgICAgICAgJ21vY2hhLXRlYW1jaXR5LXJlcG9ydGVyICcgK1xcbiAgICAgICAgJyhodHRwczovL25wbWpzLm9yZy9wYWNrYWdlL21vY2hhLXRlYW1jaXR5LXJlcG9ydGVyKS4nKTtcXG4gICAgfVxcbiAgICBpZiAoIV9yZXBvcnRlcikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZXBvcnRlciBcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgICB0aGlzLl9yZXBvcnRlciA9IF9yZXBvcnRlcjtcXG4gIH1cXG4gIHRoaXMub3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgPSByZXBvcnRlck9wdGlvbnM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IFVJIGBuYW1lYCwgZGVmYXVsdHMgdG8gXFxcImJkZFxcXCIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZGRcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudWkgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgbmFtZSA9IG5hbWUgfHwgJ2JkZCc7XFxuICB0aGlzLl91aSA9IGV4cG9ydHMuaW50ZXJmYWNlc1tuYW1lXTtcXG4gIGlmICghdGhpcy5fdWkpIHtcXG4gICAgdHJ5IHtcXG4gICAgICB0aGlzLl91aSA9IHJlcXVpcmUobmFtZSk7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnRlcmZhY2UgXFxcIicgKyBuYW1lICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5fdWkgPSB0aGlzLl91aSh0aGlzLnN1aXRlKTtcXG5cXG4gIHRoaXMuc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQpIHtcXG4gICAgZXhwb3J0cy5hZnRlckVhY2ggPSBjb250ZXh0LmFmdGVyRWFjaCB8fCBjb250ZXh0LnRlYXJkb3duO1xcbiAgICBleHBvcnRzLmFmdGVyID0gY29udGV4dC5hZnRlciB8fCBjb250ZXh0LnN1aXRlVGVhcmRvd247XFxuICAgIGV4cG9ydHMuYmVmb3JlRWFjaCA9IGNvbnRleHQuYmVmb3JlRWFjaCB8fCBjb250ZXh0LnNldHVwO1xcbiAgICBleHBvcnRzLmJlZm9yZSA9IGNvbnRleHQuYmVmb3JlIHx8IGNvbnRleHQuc3VpdGVTZXR1cDtcXG4gICAgZXhwb3J0cy5kZXNjcmliZSA9IGNvbnRleHQuZGVzY3JpYmUgfHwgY29udGV4dC5zdWl0ZTtcXG4gICAgZXhwb3J0cy5pdCA9IGNvbnRleHQuaXQgfHwgY29udGV4dC50ZXN0O1xcbiAgICBleHBvcnRzLnhpdCA9IGNvbnRleHQueGl0IHx8IGNvbnRleHQudGVzdC5za2lwO1xcbiAgICBleHBvcnRzLnNldHVwID0gY29udGV4dC5zZXR1cCB8fCBjb250ZXh0LmJlZm9yZUVhY2g7XFxuICAgIGV4cG9ydHMuc3VpdGVTZXR1cCA9IGNvbnRleHQuc3VpdGVTZXR1cCB8fCBjb250ZXh0LmJlZm9yZTtcXG4gICAgZXhwb3J0cy5zdWl0ZVRlYXJkb3duID0gY29udGV4dC5zdWl0ZVRlYXJkb3duIHx8IGNvbnRleHQuYWZ0ZXI7XFxuICAgIGV4cG9ydHMuc3VpdGUgPSBjb250ZXh0LnN1aXRlIHx8IGNvbnRleHQuZGVzY3JpYmU7XFxuICAgIGV4cG9ydHMudGVhcmRvd24gPSBjb250ZXh0LnRlYXJkb3duIHx8IGNvbnRleHQuYWZ0ZXJFYWNoO1xcbiAgICBleHBvcnRzLnRlc3QgPSBjb250ZXh0LnRlc3QgfHwgY29udGV4dC5pdDtcXG4gICAgZXhwb3J0cy5ydW4gPSBjb250ZXh0LnJ1bjtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBMb2FkIHJlZ2lzdGVyZWQgZmlsZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUubG9hZEZpbGVzID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdGhpcy5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgIGZpbGUgPSBwYXRoLnJlc29sdmUoZmlsZSk7XFxuICAgIHN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcXG4gICAgc3VpdGUuZW1pdCgncmVxdWlyZScsIHJlcXVpcmUoZmlsZSksIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdwb3N0LXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgfSk7XFxuICBmbiAmJiBmbigpO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuX2dyb3dsID0gZnVuY3Rpb24gKHJ1bm5lciwgcmVwb3J0ZXIpIHtcXG4gIHZhciBub3RpZnkgPSByZXF1aXJlKCdncm93bCcpO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0cyA9IHJlcG9ydGVyLnN0YXRzO1xcbiAgICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgICB2YXIgbXNnID0gc3RhdHMuZmFpbHVyZXMgKyAnIG9mICcgKyBydW5uZXIudG90YWwgKyAnIHRlc3RzIGZhaWxlZCc7XFxuICAgICAgbm90aWZ5KG1zZywgeyBuYW1lOiAnbW9jaGEnLCB0aXRsZTogJ0ZhaWxlZCcsIGltYWdlOiBpbWFnZSgnZXJyb3InKSB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBub3RpZnkoc3RhdHMucGFzc2VzICsgJyB0ZXN0cyBwYXNzZWQgaW4gJyArIHN0YXRzLmR1cmF0aW9uICsgJ21zJywge1xcbiAgICAgICAgbmFtZTogJ21vY2hhJyxcXG4gICAgICAgIHRpdGxlOiAnUGFzc2VkJyxcXG4gICAgICAgIGltYWdlOiBpbWFnZSgnb2snKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEVzY2FwZSBzdHJpbmcgYW5kIGFkZCBpdCB0byBncmVwIGFzIGEgcmVnZXhwLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0gc3RyXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mZ3JlcCA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIHJldHVybiB0aGlzLmdyZXAobmV3IFJlZ0V4cChlc2NhcGVSZShzdHIpKSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgcmVnZXhwIHRvIGdyZXAsIGlmIGByZWAgaXMgYSBzdHJpbmcgaXQgaXMgZXNjYXBlZC5cXG4gKlxcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSkge1xcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJlKSkge1xcbiAgICAvLyBleHRyYWN0IGFyZ3MgaWYgaXQncyByZWdleC1saWtlLCBpLmU6IFtzdHJpbmcsIHBhdHRlcm4sIGZsYWddXFxuICAgIHZhciBhcmcgPSByZS5tYXRjaCgvXlxcXFwvKC4qKVxcXFwvKGd8aXwpJHwuKi8pO1xcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IG5ldyBSZWdFeHAoYXJnWzFdIHx8IGFyZ1swXSwgYXJnWzJdKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gcmU7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcbi8qKlxcbiAqIEludmVydCBgLmdyZXAoKWAgbWF0Y2hlcy5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5pbnZlcnQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmUgZ2xvYmFsIGxlYWtzLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmlnbm9yZUxlYWtzID0gZnVuY3Rpb24gKGlnbm9yZSkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gQm9vbGVhbihpZ25vcmUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ2xvYmFsIGxlYWsgY2hlY2tpbmcuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gZmFsc2U7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc3BsYXkgbG9uZyBzdGFjay10cmFjZSBvbiBmYWlsaW5nXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mdWxsVHJhY2UgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZnVsbFN0YWNrVHJhY2UgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ3Jvd2wgc3VwcG9ydC5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmdyb3dsID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmdyb3dsID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGBnbG9iYWxzYCBhcnJheSBvciBzdHJpbmcuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChnbG9iYWxzKSB7XFxuICB0aGlzLm9wdGlvbnMuZ2xvYmFscyA9ICh0aGlzLm9wdGlvbnMuZ2xvYmFscyB8fCBbXSkuY29uY2F0KGdsb2JhbHMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbWl0IGNvbG9yIG91dHB1dC5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbG9yc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51c2VDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XFxuICBpZiAoY29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpcy5vcHRpb25zLnVzZUNvbG9ycyA9IGNvbG9ycztcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVXNlIGlubGluZSBkaWZmcyByYXRoZXIgdGhhbiArLy0uXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlubGluZURpZmZzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlubGluZURpZmZzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUlubGluZURpZmZzID0gZnVuY3Rpb24gKGlubGluZURpZmZzKSB7XFxuICB0aGlzLm9wdGlvbnMudXNlSW5saW5lRGlmZnMgPSBpbmxpbmVEaWZmcyAhPT0gdW5kZWZpbmVkICYmIGlubGluZURpZmZzO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xcbiAgdGhpcy5zdWl0ZS50aW1lb3V0KHRpbWVvdXQpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gcmV0cnkgdGltZXNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMuc3VpdGUucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHNsb3duZXNzIHRocmVzaG9sZCBpbiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gc2xvd1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChzbG93KSB7XFxuICB0aGlzLnN1aXRlLnNsb3coc2xvdyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB0aW1lb3V0cy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIHRoaXMuc3VpdGUuZW5hYmxlVGltZW91dHMoYXJndW1lbnRzLmxlbmd0aCAmJiBlbmFibGVkICE9PSB1bmRlZmluZWQgPyBlbmFibGVkIDogdHJ1ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIE1ha2VzIGFsbCB0ZXN0cyBhc3luYyAoYWNjZXB0aW5nIGEgY2FsbGJhY2spXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hc3luY09ubHkgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzYWJsZSBzeW50YXggaGlnaGxpZ2h0aW5nIChpbiBicm93c2VyKS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLm5vSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHVuY2F1Z2h0IGVycm9ycyB0byBwcm9wYWdhdGUgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWxsb3dVbmNhdWdodCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5hbGxvd1VuY2F1Z2h0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGVsYXkgcm9vdCBzdWl0ZSBleGVjdXRpb24uXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5ICgpIHtcXG4gIHRoaXMub3B0aW9ucy5kZWxheSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRlc3RzIG1hcmtlZCBvbmx5IGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRPbmx5ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmZvcmJpZE9ubHkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBQZW5kaW5nIHRlc3RzIGFuZCB0ZXN0cyBtYXJrZWQgc2tpcCBmYWlsIHRoZSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5mb3JiaWRQZW5kaW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRlc3RzIGFuZCBpbnZva2UgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVzLmxlbmd0aCkge1xcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xcbiAgfVxcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcbiAgb3B0aW9ucy5maWxlcyA9IHRoaXMuZmlsZXM7XFxuICB2YXIgcnVubmVyID0gbmV3IGV4cG9ydHMuUnVubmVyKHN1aXRlLCBvcHRpb25zLmRlbGF5KTtcXG4gIHZhciByZXBvcnRlciA9IG5ldyB0aGlzLl9yZXBvcnRlcihydW5uZXIsIG9wdGlvbnMpO1xcbiAgcnVubmVyLmlnbm9yZUxlYWtzID0gb3B0aW9ucy5pZ25vcmVMZWFrcyAhPT0gZmFsc2U7XFxuICBydW5uZXIuZnVsbFN0YWNrVHJhY2UgPSBvcHRpb25zLmZ1bGxTdGFja1RyYWNlO1xcbiAgcnVubmVyLmhhc09ubHkgPSBvcHRpb25zLmhhc09ubHk7XFxuICBydW5uZXIuYXN5bmNPbmx5ID0gb3B0aW9ucy5hc3luY09ubHk7XFxuICBydW5uZXIuYWxsb3dVbmNhdWdodCA9IG9wdGlvbnMuYWxsb3dVbmNhdWdodDtcXG4gIHJ1bm5lci5mb3JiaWRPbmx5ID0gb3B0aW9ucy5mb3JiaWRPbmx5O1xcbiAgcnVubmVyLmZvcmJpZFBlbmRpbmcgPSBvcHRpb25zLmZvcmJpZFBlbmRpbmc7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHJ1bm5lci5ncmVwKG9wdGlvbnMuZ3JlcCwgb3B0aW9ucy5pbnZlcnQpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZ2xvYmFscykge1xcbiAgICBydW5uZXIuZ2xvYmFscyhvcHRpb25zLmdsb2JhbHMpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZ3Jvd2wpIHtcXG4gICAgdGhpcy5fZ3Jvd2wocnVubmVyLCByZXBvcnRlcik7XFxuICB9XFxuICBpZiAob3B0aW9ucy51c2VDb2xvcnMgIT09IHVuZGVmaW5lZCkge1xcbiAgICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLnVzZUNvbG9ycyA9IG9wdGlvbnMudXNlQ29sb3JzO1xcbiAgfVxcbiAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS5pbmxpbmVEaWZmcyA9IG9wdGlvbnMudXNlSW5saW5lRGlmZnM7XFxuXFxuICBmdW5jdGlvbiBkb25lIChmYWlsdXJlcykge1xcbiAgICBpZiAocmVwb3J0ZXIuZG9uZSkge1xcbiAgICAgIHJlcG9ydGVyLmRvbmUoZmFpbHVyZXMsIGZuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmbiAmJiBmbihmYWlsdXJlcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBydW5uZXIucnVuKGRvbmUpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSxcXFwiL2xpYlxcXCIpXFxufSx7XFxcIi4vY29udGV4dFxcXCI6NixcXFwiLi9ob29rXFxcIjo3LFxcXCIuL2ludGVyZmFjZXNcXFwiOjExLFxcXCIuL3JlcG9ydGVyc1xcXCI6MjEsXFxcIi4vcnVubmFibGVcXFwiOjMzLFxcXCIuL3J1bm5lclxcXCI6MzQsXFxcIi4vc3VpdGVcXFwiOjM1LFxcXCIuL3Rlc3RcXFwiOjM2LFxcXCIuL3V0aWxzXFxcIjozOCxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NjEsXFxcImdyb3dsXFxcIjo2MyxcXFwicGF0aFxcXCI6NDJ9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEhlbHBlcnMuXFxuICovXFxuXFxudmFyIHMgPSAxMDAwO1xcbnZhciBtID0gcyAqIDYwO1xcbnZhciBoID0gbSAqIDYwO1xcbnZhciBkID0gaCAqIDI0O1xcbnZhciB5ID0gZCAqIDM2NS4yNTtcXG5cXG4vKipcXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICogQHJldHVybiB7c3RyaW5nfG51bWJlcn1cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBwYXJzZSh2YWwpO1xcbiAgfVxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvcHVsbC8xMDM1XFxuICByZXR1cm4gb3B0aW9uc1snbG9uZyddID8gbG9uZ0Zvcm1hdCh2YWwpIDogc2hvcnRGb3JtYXQodmFsKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuZnVuY3Rpb24gcGFyc2UgKHN0cikge1xcbiAgdmFyIG1hdGNoID0gKC9eKCg/OlxcXFxkKyk/XFxcXC4/XFxcXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kpLmV4ZWMoc3RyKTtcXG4gIGlmICghbWF0Y2gpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAneWVhcnMnOlxcbiAgICBjYXNlICd5ZWFyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdoJzpcXG4gICAgICByZXR1cm4gbiAqIGg7XFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxcbiAgICBjYXNlICdtaW51dGUnOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzJzpcXG4gICAgICByZXR1cm4gbiAqIHM7XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICAvLyBObyBkZWZhdWx0IGNhc2VcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHNob3J0Rm9ybWF0IChtcykge1xcbiAgaWYgKG1zID49IGQpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcXG4gIH1cXG4gIGlmIChtcyA+PSBoKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XFxuICB9XFxuICBpZiAobXMgPj0gbSkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xcbiAgfVxcbiAgaWYgKG1zID49IHMpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcXG4gIH1cXG4gIHJldHVybiBtcyArICdtcyc7XFxufVxcblxcbi8qKlxcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGxvbmdGb3JtYXQgKG1zKSB7XFxuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcXG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XFxuICAgIG1zICsgJyBtcyc7XFxufVxcblxcbi8qKlxcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqL1xcbmZ1bmN0aW9uIHBsdXJhbCAobXMsIG4sIG5hbWUpIHtcXG4gIGlmIChtcyA8IG4pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcXG4gIH1cXG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XFxufVxcblxcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBQZW5kaW5nYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBlbmRpbmc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUGVuZGluZ2AgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXFxuICovXFxuZnVuY3Rpb24gUGVuZGluZyAobWVzc2FnZSkge1xcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcXG59XFxuXFxufSx7fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcXG52YXIgZGlmZiA9IHJlcXVpcmUoJ2RpZmYnKTtcXG52YXIgbXMgPSByZXF1aXJlKCcuLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIHN1cHBvcnRzQ29sb3IgPSBwcm9jZXNzLmJyb3dzZXIgPyBudWxsIDogcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEJhc2VgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nLlxcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvaXNzdWVzLzIzN1xcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYm90aCBzdGRpbyBzdHJlYW1zIGFyZSBhc3NvY2lhdGVkIHdpdGggYSB0dHkuXFxuICovXFxuXFxudmFyIGlzYXR0eSA9IHR0eS5pc2F0dHkoMSkgJiYgdHR5LmlzYXR0eSgyKTtcXG5cXG4vKipcXG4gKiBFbmFibGUgY29sb3JpbmcgYnkgZGVmYXVsdCwgZXhjZXB0IGluIHRoZSBicm93c2VyIGludGVyZmFjZS5cXG4gKi9cXG5cXG5leHBvcnRzLnVzZUNvbG9ycyA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgKHN1cHBvcnRzQ29sb3IgfHwgKHByb2Nlc3MuZW52Lk1PQ0hBX0NPTE9SUyAhPT0gdW5kZWZpbmVkKSk7XFxuXFxuLyoqXFxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXFxuICovXFxuXFxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgY29sb3IgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0ge1xcbiAgcGFzczogOTAsXFxuICBmYWlsOiAzMSxcXG4gICdicmlnaHQgcGFzcyc6IDkyLFxcbiAgJ2JyaWdodCBmYWlsJzogOTEsXFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxcbiAgcGVuZGluZzogMzYsXFxuICBzdWl0ZTogMCxcXG4gICdlcnJvciB0aXRsZSc6IDAsXFxuICAnZXJyb3IgbWVzc2FnZSc6IDMxLFxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXFxuICBjaGVja21hcms6IDMyLFxcbiAgZmFzdDogOTAsXFxuICBtZWRpdW06IDMzLFxcbiAgc2xvdzogMzEsXFxuICBncmVlbjogMzIsXFxuICBsaWdodDogOTAsXFxuICAnZGlmZiBndXR0ZXInOiA5MCxcXG4gICdkaWZmIGFkZGVkJzogMzIsXFxuICAnZGlmZiByZW1vdmVkJzogMzFcXG59O1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc3ltYm9sIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLnN5bWJvbHMgPSB7XFxuICBvazogJ+KckycsXFxuICBlcnI6ICfinJYnLFxcbiAgZG90OiAn4oCkJyxcXG4gIGNvbW1hOiAnLCcsXFxuICBiYW5nOiAnISdcXG59O1xcblxcbi8vIFdpdGggbm9kZS5qcyBvbiBXaW5kb3dzOiB1c2Ugc3ltYm9scyBhdmFpbGFibGUgaW4gdGVybWluYWwgZGVmYXVsdCBmb250c1xcbmlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XFxuICBleHBvcnRzLnN5bWJvbHMub2sgPSAnXFxcXHUyMjFBJztcXG4gIGV4cG9ydHMuc3ltYm9scy5lcnIgPSAnXFxcXHUwMEQ3JztcXG4gIGV4cG9ydHMuc3ltYm9scy5kb3QgPSAnLic7XFxufVxcblxcbi8qKlxcbiAqIENvbG9yIGBzdHJgIHdpdGggdGhlIGdpdmVuIGB0eXBlYCxcXG4gKiBhbGxvd2luZyBjb2xvcnMgdG8gYmUgZGlzYWJsZWQsXFxuICogYXMgd2VsbCBhcyB1c2VyLWRlZmluZWQgY29sb3JcXG4gKiBzY2hlbWVzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbnZhciBjb2xvciA9IGV4cG9ydHMuY29sb3IgPSBmdW5jdGlvbiAodHlwZSwgc3RyKSB7XFxuICBpZiAoIWV4cG9ydHMudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBTdHJpbmcoc3RyKTtcXG4gIH1cXG4gIHJldHVybiAnXFxcXHUwMDFiWycgKyBleHBvcnRzLmNvbG9yc1t0eXBlXSArICdtJyArIHN0ciArICdcXFxcdTAwMWJbMG0nO1xcbn07XFxuXFxuLyoqXFxuICogRXhwb3NlIHRlcm0gd2luZG93IHNpemUsIHdpdGggc29tZSBkZWZhdWx0cyBmb3Igd2hlbiBzdGRlcnIgaXMgbm90IGEgdHR5LlxcbiAqL1xcblxcbmV4cG9ydHMud2luZG93ID0ge1xcbiAgd2lkdGg6IDc1XFxufTtcXG5cXG5pZiAoaXNhdHR5KSB7XFxuICBleHBvcnRzLndpbmRvdy53aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemVcXG4gICAgICA/IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoMSlbMF1cXG4gICAgICA6IHR0eS5nZXRXaW5kb3dTaXplKClbMV07XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBzb21lIGJhc2ljIGN1cnNvciBpbnRlcmFjdGlvbnMgdGhhdCBhcmUgY29tbW9uIGFtb25nIHJlcG9ydGVycy5cXG4gKi9cXG5cXG5leHBvcnRzLmN1cnNvciA9IHtcXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1bCcpO1xcbiAgfSxcXG5cXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1aCcpO1xcbiAgfSxcXG5cXG4gIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMksnKTtcXG4gIH0sXFxuXFxuICBiZWdpbm5pbmdPZkxpbmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMEcnKTtcXG4gIH0sXFxuXFxuICBDUjogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoaXNhdHR5KSB7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuZGVsZXRlTGluZSgpO1xcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmJlZ2lubmluZ09mTGluZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxccicpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBPdXRwdXQgdGhlIGdpdmVuIGBmYWlsdXJlc2AgYXMgYSBsaXN0LlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gZmFpbHVyZXNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChmYWlsdXJlcykge1xcbiAgY29uc29sZS5sb2coKTtcXG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QsIGkpIHtcXG4gICAgLy8gZm9ybWF0XFxuICAgIHZhciBmbXQgPSBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxcXG4nKSArXFxuICAgICAgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCAnICAgICAlcycpICtcXG4gICAgICBjb2xvcignZXJyb3Igc3RhY2snLCAnXFxcXG4lc1xcXFxuJyk7XFxuXFxuICAgIC8vIG1zZ1xcbiAgICB2YXIgbXNnO1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHZhciBtZXNzYWdlO1xcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgdHlwZW9mIGVyci5tZXNzYWdlLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlICsgJyc7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyci5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5pbnNwZWN0KCkgKyAnJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtZXNzYWdlID0gJyc7XFxuICAgIH1cXG4gICAgdmFyIHN0YWNrID0gZXJyLnN0YWNrIHx8IG1lc3NhZ2U7XFxuICAgIHZhciBpbmRleCA9IG1lc3NhZ2UgPyBzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDogLTE7XFxuICAgIHZhciBhY3R1YWwgPSBlcnIuYWN0dWFsO1xcbiAgICB2YXIgZXhwZWN0ZWQgPSBlcnIuZXhwZWN0ZWQ7XFxuICAgIHZhciBlc2NhcGUgPSB0cnVlO1xcblxcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XFxuICAgICAgbXNnID0gbWVzc2FnZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpbmRleCArPSBtZXNzYWdlLmxlbmd0aDtcXG4gICAgICBtc2cgPSBzdGFjay5zbGljZSgwLCBpbmRleCk7XFxuICAgICAgLy8gcmVtb3ZlIG1zZyBmcm9tIHN0YWNrXFxuICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpbmRleCArIDEpO1xcbiAgICB9XFxuXFxuICAgIC8vIHVuY2F1Z2h0XFxuICAgIGlmIChlcnIudW5jYXVnaHQpIHtcXG4gICAgICBtc2cgPSAnVW5jYXVnaHQgJyArIG1zZztcXG4gICAgfVxcbiAgICAvLyBleHBsaWNpdGx5IHNob3cgZGlmZlxcbiAgICBpZiAoZXJyLnNob3dEaWZmICE9PSBmYWxzZSAmJiBzYW1lVHlwZShhY3R1YWwsIGV4cGVjdGVkKSAmJiBleHBlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgZXNjYXBlID0gZmFsc2U7XFxuICAgICAgaWYgKCEodXRpbHMuaXNTdHJpbmcoYWN0dWFsKSAmJiB1dGlscy5pc1N0cmluZyhleHBlY3RlZCkpKSB7XFxuICAgICAgICBlcnIuYWN0dWFsID0gYWN0dWFsID0gdXRpbHMuc3RyaW5naWZ5KGFjdHVhbCk7XFxuICAgICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZCA9IHV0aWxzLnN0cmluZ2lmeShleHBlY3RlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbiVzJykgKyBjb2xvcignZXJyb3Igc3RhY2snLCAnXFxcXG4lc1xcXFxuJyk7XFxuICAgICAgdmFyIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXihbXjpdKyk6IGV4cGVjdGVkLyk7XFxuICAgICAgbXNnID0gJ1xcXFxuICAgICAgJyArIGNvbG9yKCdlcnJvciBtZXNzYWdlJywgbWF0Y2ggPyBtYXRjaFsxXSA6IG1zZyk7XFxuXFxuICAgICAgaWYgKGV4cG9ydHMuaW5saW5lRGlmZnMpIHtcXG4gICAgICAgIG1zZyArPSBpbmxpbmVEaWZmKGVyciwgZXNjYXBlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbXNnICs9IHVuaWZpZWREaWZmKGVyciwgZXNjYXBlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gaW5kZW50IHN0YWNrIHRyYWNlXFxuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJyk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgKGkgKyAxKSwgdGVzdC5mdWxsVGl0bGUoKSwgbXNnLCBzdGFjayk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEJhc2VgIHJlcG9ydGVyLlxcbiAqXFxuICogQWxsIG90aGVyIHJlcG9ydGVycyBnZW5lcmFsbHlcXG4gKiBpbmhlcml0IGZyb20gdGhpcyByZXBvcnRlciwgcHJvdmlkaW5nXFxuICogc3RhdHMgc3VjaCBhcyB0ZXN0IGR1cmF0aW9uLCBudW1iZXJcXG4gKiBvZiB0ZXN0cyBwYXNzZWQgLyBmYWlsZWQgZXRjLlxcbiAqXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gQmFzZSAocnVubmVyKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzID0geyBzdWl0ZXM6IDAsIHRlc3RzOiAwLCBwYXNzZXM6IDAsIHBlbmRpbmc6IDAsIGZhaWx1cmVzOiAwIH07XFxuICB2YXIgZmFpbHVyZXMgPSB0aGlzLmZhaWx1cmVzID0gW107XFxuXFxuICBpZiAoIXJ1bm5lcikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnJ1bm5lciA9IHJ1bm5lcjtcXG5cXG4gIHJ1bm5lci5zdGF0cyA9IHN0YXRzO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMuc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIHN0YXRzLnN1aXRlcyA9IHN0YXRzLnN1aXRlcyB8fCAwO1xcbiAgICBzdWl0ZS5yb290IHx8IHN0YXRzLnN1aXRlcysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy50ZXN0cyA9IHN0YXRzLnRlc3RzIHx8IDA7XFxuICAgIHN0YXRzLnRlc3RzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHN0YXRzLnBhc3NlcyA9IHN0YXRzLnBhc3NlcyB8fCAwO1xcblxcbiAgICBpZiAodGVzdC5kdXJhdGlvbiA+IHRlc3Quc2xvdygpKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdzbG93JztcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdtZWRpdW0nO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XFxuICAgIH1cXG5cXG4gICAgc3RhdHMucGFzc2VzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgc3RhdHMuZmFpbHVyZXMgPSBzdGF0cy5mYWlsdXJlcyB8fCAwO1xcbiAgICBzdGF0cy5mYWlsdXJlcysrO1xcbiAgICB0ZXN0LmVyciA9IGVycjtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XFxuICAgIHN0YXRzLmR1cmF0aW9uID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLnBlbmRpbmcrKztcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBPdXRwdXQgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZlxcbiAqIHRoZSBidW5kbGVkIHJlcG9ydGVycy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuQmFzZS5wcm90b3R5cGUuZXBpbG9ndWUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIGZtdDtcXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxuXFxuICAvLyBwYXNzZXNcXG4gIGZtdCA9IGNvbG9yKCdicmlnaHQgcGFzcycsICcgJykgK1xcbiAgICBjb2xvcignZ3JlZW4nLCAnICVkIHBhc3NpbmcnKSArXFxuICAgIGNvbG9yKCdsaWdodCcsICcgKCVzKScpO1xcblxcbiAgY29uc29sZS5sb2coZm10LFxcbiAgICBzdGF0cy5wYXNzZXMgfHwgMCxcXG4gICAgbXMoc3RhdHMuZHVyYXRpb24pKTtcXG5cXG4gIC8vIHBlbmRpbmdcXG4gIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIGZtdCA9IGNvbG9yKCdwZW5kaW5nJywgJyAnKSArXFxuICAgICAgY29sb3IoJ3BlbmRpbmcnLCAnICVkIHBlbmRpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5wZW5kaW5nKTtcXG4gIH1cXG5cXG4gIC8vIGZhaWx1cmVzXFxuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgZm10ID0gY29sb3IoJ2ZhaWwnLCAnICAlZCBmYWlsaW5nJyk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgc3RhdHMuZmFpbHVyZXMpO1xcblxcbiAgICBCYXNlLmxpc3QodGhpcy5mYWlsdXJlcyk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9XFxuXFxuICBjb25zb2xlLmxvZygpO1xcbn07XFxuXFxuLyoqXFxuICogUGFkIHRoZSBnaXZlbiBgc3RyYCB0byBgbGVuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcGFyYW0ge3N0cmluZ30gbGVuXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHBhZCAoc3RyLCBsZW4pIHtcXG4gIHN0ciA9IFN0cmluZyhzdHIpO1xcbiAgcmV0dXJuIEFycmF5KGxlbiAtIHN0ci5sZW5ndGggKyAxKS5qb2luKCcgJykgKyBzdHI7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYW4gaW5saW5lIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyIHdpdGggYWN0dWFsL2V4cGVjdGVkXFxuICogQHBhcmFtIHtib29sZWFufSBlc2NhcGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcXG4gKi9cXG5mdW5jdGlvbiBpbmxpbmVEaWZmIChlcnIsIGVzY2FwZSkge1xcbiAgdmFyIG1zZyA9IGVycm9yRGlmZihlcnIsICdXb3Jkc1dpdGhTcGFjZScsIGVzY2FwZSk7XFxuXFxuICAvLyBsaW5lbm9zXFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJyk7XFxuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xcbiAgICB2YXIgd2lkdGggPSBTdHJpbmcobGluZXMubGVuZ3RoKS5sZW5ndGg7XFxuICAgIG1zZyA9IGxpbmVzLm1hcChmdW5jdGlvbiAoc3RyLCBpKSB7XFxuICAgICAgcmV0dXJuIHBhZCgrK2ksIHdpZHRoKSArICcgfCcgKyAnICcgKyBzdHI7XFxuICAgIH0pLmpvaW4oJ1xcXFxuJyk7XFxuICB9XFxuXFxuICAvLyBsZWdlbmRcXG4gIG1zZyA9ICdcXFxcbicgK1xcbiAgICBjb2xvcignZGlmZiByZW1vdmVkJywgJ2FjdHVhbCcpICtcXG4gICAgJyAnICtcXG4gICAgY29sb3IoJ2RpZmYgYWRkZWQnLCAnZXhwZWN0ZWQnKSArXFxuICAgICdcXFxcblxcXFxuJyArXFxuICAgIG1zZyArXFxuICAgICdcXFxcbic7XFxuXFxuICAvLyBpbmRlbnRcXG4gIG1zZyA9IG1zZy5yZXBsYWNlKC9eL2dtLCAnICAgICAgJyk7XFxuICByZXR1cm4gbXNnO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgdW5pZmllZCBkaWZmIGJldHdlZW4gdHdvIHN0cmluZ3MuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgd2l0aCBhY3R1YWwvZXhwZWN0ZWRcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZVxcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRpZmYuXFxuICovXFxuZnVuY3Rpb24gdW5pZmllZERpZmYgKGVyciwgZXNjYXBlKSB7XFxuICB2YXIgaW5kZW50ID0gJyAgICAgICc7XFxuICBmdW5jdGlvbiBjbGVhblVwIChsaW5lKSB7XFxuICAgIGlmIChlc2NhcGUpIHtcXG4gICAgICBsaW5lID0gZXNjYXBlSW52aXNpYmxlcyhsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9AQC8pKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgaWYgKGxpbmUubWF0Y2goL1xcXFxcXFxcIE5vIG5ld2xpbmUvKSkge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBpbmRlbnQgKyBsaW5lO1xcbiAgfVxcbiAgZnVuY3Rpb24gbm90QmxhbmsgKGxpbmUpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiBsaW5lICE9PSBudWxsO1xcbiAgfVxcbiAgdmFyIG1zZyA9IGRpZmYuY3JlYXRlUGF0Y2goJ3N0cmluZycsIGVyci5hY3R1YWwsIGVyci5leHBlY3RlZCk7XFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJykuc3BsaWNlKDQpO1xcbiAgcmV0dXJuICdcXFxcbiAgICAgICcgK1xcbiAgICBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArICcgJyArXFxuICAgIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbCcpICtcXG4gICAgJ1xcXFxuXFxcXG4nICtcXG4gICAgbGluZXMubWFwKGNsZWFuVXApLmZpbHRlcihub3RCbGFuaykuam9pbignXFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2hhcmFjdGVyIGRpZmYgZm9yIGBlcnJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBlcnJvckRpZmYgKGVyciwgdHlwZSwgZXNjYXBlKSB7XFxuICB2YXIgYWN0dWFsID0gZXNjYXBlID8gZXNjYXBlSW52aXNpYmxlcyhlcnIuYWN0dWFsKSA6IGVyci5hY3R1YWw7XFxuICB2YXIgZXhwZWN0ZWQgPSBlc2NhcGUgPyBlc2NhcGVJbnZpc2libGVzKGVyci5leHBlY3RlZCkgOiBlcnIuZXhwZWN0ZWQ7XFxuICByZXR1cm4gZGlmZlsnZGlmZicgKyB0eXBlXShhY3R1YWwsIGV4cGVjdGVkKS5tYXAoZnVuY3Rpb24gKHN0cikge1xcbiAgICBpZiAoc3RyLmFkZGVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBzdHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGlmIChzdHIucmVtb3ZlZCkge1xcbiAgICAgIHJldHVybiBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCBzdHIudmFsdWUpO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHIudmFsdWU7XFxuICB9KS5qb2luKCcnKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGFsbCBpbnZpc2libGUgY2hhcmFjdGVycyBpbiBwbGFpbiB0ZXh0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBlc2NhcGVJbnZpc2libGVzIChsaW5lKSB7XFxuICByZXR1cm4gbGluZS5yZXBsYWNlKC9cXFxcdC9nLCAnPHRhYj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXHIvZywgJzxDUj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXG4vZywgJzxMRj5cXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xvciBsaW5lcyBmb3IgYHN0cmAsIHVzaW5nIHRoZSBjb2xvciBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gY29sb3JMaW5lcyAobmFtZSwgc3RyKSB7XFxuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbiAoc3RyKSB7XFxuICAgIHJldHVybiBjb2xvcihuYW1lLCBzdHIpO1xcbiAgfSkuam9pbignXFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nIHJlZmVyZW5jZS5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIENoZWNrIHRoYXQgYSAvIGIgaGF2ZSB0aGUgc2FtZSB0eXBlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IGFcXG4gKiBAcGFyYW0ge09iamVjdH0gYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gc2FtZVR5cGUgKGEsIGIpIHtcXG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKGEpID09PSBvYmpUb1N0cmluZy5jYWxsKGIpO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi9tc1xcXCI6MTUsXFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJkaWZmXFxcIjo1NSxcXFwic3VwcG9ydHMtY29sb3JcXFwiOjQyLFxcXCJ0dHlcXFwiOjV9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG9jYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb2M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG9jYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIERvYyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBpbmRlbnRzID0gMjtcXG5cXG4gIGZ1bmN0aW9uIGluZGVudCAoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxzZWN0aW9uIGNsYXNzPVxcXCJzdWl0ZVxcXCI+JywgaW5kZW50KCkpO1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxoMT4lczwvaDE+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShzdWl0ZS50aXRsZSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXM8ZGw+JywgaW5kZW50KCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25zb2xlLmxvZygnJXM8L2RsPicsIGluZGVudCgpKTtcXG4gICAgLS1pbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZygnJXM8L3NlY3Rpb24+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZCBjbGFzcz1cXFwiZXJyb3JcXFwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2RkPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoZXJyKSk7XFxuICB9KTtcXG59XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxN31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG90YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIERvdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgbiA9IC0xO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGVuZGluZycsIEJhc2Uuc3ltYm9scy5jb21tYSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIGlmICh0ZXN0LnNwZWVkID09PSAnc2xvdycpIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcignYnJpZ2h0IHllbGxvdycsIEJhc2Uuc3ltYm9scy5kb3QpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcih0ZXN0LnNwZWVkLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmJhbmcpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhEb3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcHJvZ3Jlc3MnKTtcXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBlc2NhcGUgPSB1dGlscy5lc2NhcGU7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSFRNTGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSFRNTDtcXG5cXG4vKipcXG4gKiBTdGF0cyB0ZW1wbGF0ZS5cXG4gKi9cXG5cXG52YXIgc3RhdHNUZW1wbGF0ZSA9ICc8dWwgaWQ9XFxcIm1vY2hhLXN0YXRzXFxcIj4nICtcXG4gICc8bGkgY2xhc3M9XFxcInByb2dyZXNzXFxcIj48Y2FudmFzIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCI+PC9jYW52YXM+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcInBhc3Nlc1xcXCI+PGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApO1xcXCI+cGFzc2VzOjwvYT4gPGVtPjA8L2VtPjwvbGk+JyArXFxuICAnPGxpIGNsYXNzPVxcXCJmYWlsdXJlc1xcXCI+PGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApO1xcXCI+ZmFpbHVyZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcImR1cmF0aW9uXFxcIj5kdXJhdGlvbjogPGVtPjA8L2VtPnM8L2xpPicgK1xcbiAgJzwvdWw+JztcXG5cXG52YXIgcGxheUljb24gPSAnJiN4MjAyMzsnO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEhUTUxgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSFRNTCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgc3RhdCA9IGZyYWdtZW50KHN0YXRzVGVtcGxhdGUpO1xcbiAgdmFyIGl0ZW1zID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcXG4gIHZhciBwYXNzZXMgPSBpdGVtc1sxXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBwYXNzZXNMaW5rID0gaXRlbXNbMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcXG4gIHZhciBmYWlsdXJlcyA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIGZhaWx1cmVzTGluayA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XFxuICB2YXIgZHVyYXRpb24gPSBpdGVtc1szXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBjYW52YXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKVswXTtcXG4gIHZhciByZXBvcnQgPSBmcmFnbWVudCgnPHVsIGlkPVxcXCJtb2NoYS1yZXBvcnRcXFwiPjwvdWw+Jyk7XFxuICB2YXIgc3RhY2sgPSBbcmVwb3J0XTtcXG4gIHZhciBwcm9ncmVzcztcXG4gIHZhciBjdHg7XFxuICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpO1xcblxcbiAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XFxuICAgIHZhciByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XFxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XFxuICAgIGNhbnZhcy53aWR0aCAqPSByYXRpbztcXG4gICAgY2FudmFzLmhlaWdodCAqPSByYXRpbztcXG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XFxuICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xcbiAgICBwcm9ncmVzcyA9IG5ldyBQcm9ncmVzcygpO1xcbiAgfVxcblxcbiAgaWYgKCFyb290KSB7XFxuICAgIHJldHVybiBlcnJvcignI21vY2hhIGRpdiBtaXNzaW5nLCBhZGQgaXQgdG8geW91ciBkb2N1bWVudCcpO1xcbiAgfVxcblxcbiAgLy8gcGFzcyB0b2dnbGVcXG4gIG9uKHBhc3Nlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIHVuaGlkZSgpO1xcbiAgICB2YXIgbmFtZSA9ICgvcGFzcy8pLnRlc3QocmVwb3J0LmNsYXNzTmFtZSkgPyAnJyA6ICcgcGFzcyc7XFxuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcXG4gICAgICBoaWRlU3VpdGVzV2l0aG91dCgndGVzdCBwYXNzJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gZmFpbHVyZSB0b2dnbGVcXG4gIG9uKGZhaWx1cmVzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9mYWlsLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBmYWlsJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IGZhaWwnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByb290LmFwcGVuZENoaWxkKHN0YXQpO1xcbiAgcm9vdC5hcHBlbmRDaGlsZChyZXBvcnQpO1xcblxcbiAgaWYgKHByb2dyZXNzKSB7XFxuICAgIHByb2dyZXNzLnNpemUoNDApO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBzdWl0ZVxcbiAgICB2YXIgdXJsID0gc2VsZi5zdWl0ZVVSTChzdWl0ZSk7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInN1aXRlXFxcIj48aDE+PGEgaHJlZj1cXFwiJXNcXFwiPiVzPC9hPjwvaDE+PC9saT4nLCB1cmwsIGVzY2FwZShzdWl0ZS50aXRsZSkpO1xcblxcbiAgICAvLyBjb250YWluZXJcXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICBzdGFjay51bnNoaWZ0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJykpO1xcbiAgICBlbC5hcHBlbmRDaGlsZChzdGFja1swXSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgdXBkYXRlU3RhdHMoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgc3RhY2suc2hpZnQoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIHVybCA9IHNlbGYudGVzdFVSTCh0ZXN0KTtcXG4gICAgdmFyIG1hcmt1cCA9ICc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyAlZVxcXCI+PGgyPiVlPHNwYW4gY2xhc3M9XFxcImR1cmF0aW9uXFxcIj4lZW1zPC9zcGFuPiAnICtcXG4gICAgICAnPGEgaHJlZj1cXFwiJXNcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgKyBwbGF5SWNvbiArICc8L2E+PC9oMj48L2xpPic7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KG1hcmt1cCwgdGVzdC5zcGVlZCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbiwgdXJsKTtcXG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwidGVzdCBmYWlsXFxcIj48aDI+JWUgPGEgaHJlZj1cXFwiJWVcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgKyBwbGF5SWNvbiArICc8L2E+PC9oMj48L2xpPicsXFxuICAgICAgdGVzdC50aXRsZSwgc2VsZi50ZXN0VVJMKHRlc3QpKTtcXG4gICAgdmFyIHN0YWNrU3RyaW5nOyAvLyBOb3RlOiBJbmNsdWRlcyBsZWFkaW5nIG5ld2xpbmVcXG4gICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xcblxcbiAgICAvLyA8PUlFNyBzdHJpbmdpZmllcyB0byBbT2JqZWN0IEVycm9yXS4gU2luY2UgaXQgY2FuIGJlIG92ZXJsb2FkZWQsIHdlXFxuICAgIC8vIGNoZWNrIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBzdHJpbmdpZnlpbmcuXFxuICAgIGlmIChtZXNzYWdlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgbWVzc2FnZSA9IHRlc3QuZXJyLm1lc3NhZ2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRlc3QuZXJyLnN0YWNrKSB7XFxuICAgICAgdmFyIGluZGV4T2ZNZXNzYWdlID0gdGVzdC5lcnIuc3RhY2suaW5kZXhPZih0ZXN0LmVyci5tZXNzYWdlKTtcXG4gICAgICBpZiAoaW5kZXhPZk1lc3NhZ2UgPT09IC0xKSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrLnN1YnN0cih0ZXN0LmVyci5tZXNzYWdlLmxlbmd0aCArIGluZGV4T2ZNZXNzYWdlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuc291cmNlVVJMICYmIHRlc3QuZXJyLmxpbmUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGdpdmUgeW91IGEgc3RhY2suIExldCdzIGF0IGxlYXN0IHByb3ZpZGUgYSBzb3VyY2UgbGluZS5cXG4gICAgICBzdGFja1N0cmluZyA9ICdcXFxcbignICsgdGVzdC5lcnIuc291cmNlVVJMICsgJzonICsgdGVzdC5lcnIubGluZSArICcpJztcXG4gICAgfVxcblxcbiAgICBzdGFja1N0cmluZyA9IHN0YWNrU3RyaW5nIHx8ICcnO1xcblxcbiAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBjbGFzcz1cXFwiaHRtbC1lcnJvclxcXCI+JXNcXFxcbjxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZTwvcHJlPjwvZGl2PicsXFxuICAgICAgICB0ZXN0LmVyci5odG1sTWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSkge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lczwvZGl2PicsIHRlc3QuZXJyLmh0bWxNZXNzYWdlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IHBhc3MgcGVuZGluZ1xcXCI+PGgyPiVlPC9oMj48L2xpPicsIHRlc3QudGl0bGUpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gYXBwZW5kVG9TdGFjayAoZWwpIHtcXG4gICAgLy8gRG9uJ3QgY2FsbCAuYXBwZW5kQ2hpbGQgaWYgI21vY2hhLXJlcG9ydCB3YXMgYWxyZWFkeSAuc2hpZnQoKSdlZCBvZmYgdGhlIHN0YWNrLlxcbiAgICBpZiAoc3RhY2tbMF0pIHtcXG4gICAgICBzdGFja1swXS5hcHBlbmRDaGlsZChlbCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRzICgpIHtcXG4gICAgLy8gVE9ETzogYWRkIHRvIHN0YXRzXFxuICAgIHZhciBwZXJjZW50ID0gc3RhdHMudGVzdHMgLyBydW5uZXIudG90YWwgKiAxMDAgfCAwO1xcbiAgICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgICBwcm9ncmVzcy51cGRhdGUocGVyY2VudCkuZHJhdyhjdHgpO1xcbiAgICB9XFxuXFxuICAgIC8vIHVwZGF0ZSBzdGF0c1xcbiAgICB2YXIgbXMgPSBuZXcgRGF0ZSgpIC0gc3RhdHMuc3RhcnQ7XFxuICAgIHRleHQocGFzc2VzLCBzdGF0cy5wYXNzZXMpO1xcbiAgICB0ZXh0KGZhaWx1cmVzLCBzdGF0cy5mYWlsdXJlcyk7XFxuICAgIHRleHQoZHVyYXRpb24sIChtcyAvIDEwMDApLnRvRml4ZWQoMikpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBNYWtlcyBhIFVSTCwgcHJlc2VydmluZyBxdWVyeXN0cmluZyAoXFxcInNlYXJjaFxcXCIpIHBhcmFtZXRlcnMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBuZXcgVVJMLlxcbiAqL1xcbmZ1bmN0aW9uIG1ha2VVcmwgKHMpIHtcXG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xcblxcbiAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyZXAgcXVlcnkgcGFyYW1ldGVyIGlmIHByZXNlbnRcXG4gIGlmIChzZWFyY2gpIHtcXG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoL1s/Jl1ncmVwPVteJlxcXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcXG4gIH1cXG5cXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArICdncmVwPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlUmUocykpO1xcbn1cXG5cXG4vKipcXG4gKiBQcm92aWRlIHN1aXRlIFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXFxuICovXFxuSFRNTC5wcm90b3R5cGUuc3VpdGVVUkwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHJldHVybiBtYWtlVXJsKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFByb3ZpZGUgdGVzdCBVUkwuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXFxuICovXFxuSFRNTC5wcm90b3R5cGUudGVzdFVSTCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICByZXR1cm4gbWFrZVVybCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgY29kZSB0b2dnbGUgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIHByb3ZpZGVkIHRlc3QncyBsaXN0IGVsZW1lbnQuXFxuICpcXG4gKiBAcGFyYW0ge0hUTUxMSUVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuSFRNTC5wcm90b3R5cGUuYWRkQ29kZVRvZ2dsZSA9IGZ1bmN0aW9uIChlbCwgY29udGVudHMpIHtcXG4gIHZhciBoMiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpWzBdO1xcblxcbiAgb24oaDIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJlLnN0eWxlLmRpc3BsYXkgPSBwcmUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJ2Jsb2NrJyA6ICdub25lJztcXG4gIH0pO1xcblxcbiAgdmFyIHByZSA9IGZyYWdtZW50KCc8cHJlPjxjb2RlPiVlPC9jb2RlPjwvcHJlPicsIHV0aWxzLmNsZWFuKGNvbnRlbnRzKSk7XFxuICBlbC5hcHBlbmRDaGlsZChwcmUpO1xcbiAgcHJlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGVycm9yIGBtc2dgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xcbiAqL1xcbmZ1bmN0aW9uIGVycm9yIChtc2cpIHtcXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgaWQ9XFxcIm1vY2hhLWVycm9yXFxcIj4lczwvZGl2PicsIG1zZykpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBET00gZnJhZ21lbnQgZnJvbSBgaHRtbGAuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxcbiAqL1xcbmZ1bmN0aW9uIGZyYWdtZW50IChodG1sKSB7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gIHZhciBpID0gMTtcXG5cXG4gIGRpdi5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2UoLyUoW3NlXSkvZywgZnVuY3Rpb24gKF8sIHR5cGUpIHtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAncyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICdlJzogcmV0dXJuIGVzY2FwZShhcmdzW2krK10pO1xcbiAgICAgIC8vIG5vIGRlZmF1bHRcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrIGZvciBzdWl0ZXMgdGhhdCBkbyBub3QgaGF2ZSBlbGVtZW50c1xcbiAqIHdpdGggYGNsYXNzbmFtZWAsIGFuZCBoaWRlIHRoZW0uXFxuICpcXG4gKiBAcGFyYW0ge3RleHR9IGNsYXNzbmFtZVxcbiAqL1xcbmZ1bmN0aW9uIGhpZGVTdWl0ZXNXaXRob3V0IChjbGFzc25hbWUpIHtcXG4gIHZhciBzdWl0ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzdWl0ZScpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGVscyA9IHN1aXRlc1tpXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzbmFtZSk7XFxuICAgIGlmICghZWxzLmxlbmd0aCkge1xcbiAgICAgIHN1aXRlc1tpXS5jbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFVuaGlkZSAuaGlkZGVuIHN1aXRlcy5cXG4gKi9cXG5mdW5jdGlvbiB1bmhpZGUgKCkge1xcbiAgdmFyIGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlIGhpZGRlbicpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgZWxzW2ldLmNsYXNzTmFtZSA9IGVsc1tpXS5jbGFzc05hbWUucmVwbGFjZSgnc3VpdGUgaGlkZGVuJywgJ3N1aXRlJyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFNldCBhbiBlbGVtZW50J3MgdGV4dCBjb250ZW50cy5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuZnVuY3Rpb24gdGV4dCAoZWwsIGNvbnRlbnRzKSB7XFxuICBpZiAoZWwudGV4dENvbnRlbnQpIHtcXG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmlubmVyVGV4dCA9IGNvbnRlbnRzO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBMaXN0ZW4gb24gYGV2ZW50YCB3aXRoIGNhbGxiYWNrIGBmbmAuXFxuICovXFxuZnVuY3Rpb24gb24gKGVsLCBldmVudCwgZm4pIHtcXG4gIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XFxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XFxuICB9IGVsc2Uge1xcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcXG4gIH1cXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL2Jyb3dzZXIvcHJvZ3Jlc3NcXFwiOjQsXFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjYxfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vLyBBbGlhcyBleHBvcnRzIHRvIGEgdGhlaXIgbm9ybWFsaXplZCBmb3JtYXQgTW9jaGEjcmVwb3J0ZXIgdG8gcHJldmVudCBhIG5lZWRcXG4vLyBmb3IgZHluYW1pYyAodHJ5L2NhdGNoKSByZXF1aXJlcywgd2hpY2ggQnJvd3NlcmlmeSBkb2Vzbid0IGhhbmRsZS5cXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5leHBvcnRzLkRvdCA9IGV4cG9ydHMuZG90ID0gcmVxdWlyZSgnLi9kb3QnKTtcXG5leHBvcnRzLkRvYyA9IGV4cG9ydHMuZG9jID0gcmVxdWlyZSgnLi9kb2MnKTtcXG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcXG5leHBvcnRzLkpTT04gPSBleHBvcnRzLmpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcXG5leHBvcnRzLkhUTUwgPSBleHBvcnRzLmh0bWwgPSByZXF1aXJlKCcuL2h0bWwnKTtcXG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcXG5leHBvcnRzLk1pbiA9IGV4cG9ydHMubWluID0gcmVxdWlyZSgnLi9taW4nKTtcXG5leHBvcnRzLlNwZWMgPSBleHBvcnRzLnNwZWMgPSByZXF1aXJlKCcuL3NwZWMnKTtcXG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcXG5leHBvcnRzLlhVbml0ID0gZXhwb3J0cy54dW5pdCA9IHJlcXVpcmUoJy4veHVuaXQnKTtcXG5leHBvcnRzLk1hcmtkb3duID0gZXhwb3J0cy5tYXJrZG93biA9IHJlcXVpcmUoJy4vbWFya2Rvd24nKTtcXG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcXG5leHBvcnRzLkxhbmRpbmcgPSBleHBvcnRzLmxhbmRpbmcgPSByZXF1aXJlKCcuL2xhbmRpbmcnKTtcXG5leHBvcnRzLkpTT05TdHJlYW0gPSBleHBvcnRzWydqc29uLXN0cmVhbSddID0gcmVxdWlyZSgnLi9qc29uLXN0cmVhbScpO1xcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjE3LFxcXCIuL2RvY1xcXCI6MTgsXFxcIi4vZG90XFxcIjoxOSxcXFwiLi9odG1sXFxcIjoyMCxcXFwiLi9qc29uXFxcIjoyMyxcXFwiLi9qc29uLXN0cmVhbVxcXCI6MjIsXFxcIi4vbGFuZGluZ1xcXCI6MjQsXFxcIi4vbGlzdFxcXCI6MjUsXFxcIi4vbWFya2Rvd25cXFwiOjI2LFxcXCIuL21pblxcXCI6MjcsXFxcIi4vbnlhblxcXCI6MjgsXFxcIi4vcHJvZ3Jlc3NcXFwiOjI5LFxcXCIuL3NwZWNcXFwiOjMwLFxcXCIuL3RhcFxcXCI6MzEsXFxcIi4veHVuaXRcXFwiOjMyfV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgSlNPTiA9IHJlcXVpcmUoJ2pzb24zJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExpc3RgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydzdGFydCcsIHsgdG90YWw6IHRvdGFsIH1dKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsncGFzcycsIGNsZWFuKHRlc3QpXSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIHRlc3QgPSBjbGVhbih0ZXN0KTtcXG4gICAgdGVzdC5lcnIgPSBlcnIubWVzc2FnZTtcXG4gICAgdGVzdC5zdGFjayA9IGVyci5zdGFjayB8fCBudWxsO1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ2ZhaWwnLCB0ZXN0XSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkoWydlbmQnLCBzZWxmLnN0YXRzXSkpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIHBsYWluLW9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBgdGVzdGBcXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuICh0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpXFxuICB9O1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJqc29uM1xcXCI6Njl9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSlNPTmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSlNPTlJlcG9ydGVyO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpTT05gIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSlNPTlJlcG9ydGVyIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgcGVuZGluZyA9IFtdO1xcbiAgdmFyIGZhaWx1cmVzID0gW107XFxuICB2YXIgcGFzc2VzID0gW107XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcGFzc2VzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHBlbmRpbmcucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBvYmogPSB7XFxuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXFxuICAgICAgdGVzdHM6IHRlc3RzLm1hcChjbGVhbiksXFxuICAgICAgcGVuZGluZzogcGVuZGluZy5tYXAoY2xlYW4pLFxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxcbiAgICAgIHBhc3NlczogcGFzc2VzLm1hcChjbGVhbilcXG4gICAgfTtcXG5cXG4gICAgcnVubmVyLnRlc3RSZXN1bHRzID0gb2JqO1xcblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbiAodGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcXG4gICAgZXJyOiBlcnJvckpTT04odGVzdC5lcnIgfHwge30pXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gYGVycm9yYCBpbnRvIGEgSlNPTiBvYmplY3QuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gZXJyb3JKU09OIChlcnIpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJlc1trZXldID0gZXJyW2tleV07XFxuICB9LCBlcnIpO1xcbiAgcmV0dXJuIHJlcztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExhbmRpbmdgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExhbmRpbmc7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucGxhbmUgPSAwO1xcblxcbi8qKlxcbiAqIEFpcnBsYW5lIGNyYXNoIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzWydwbGFuZSBjcmFzaCddID0gMzE7XFxuXFxuLyoqXFxuICogUnVud2F5IGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnJ1bndheSA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExhbmRpbmdgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGFuZGluZyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuICB2YXIgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXQ7XFxuICB2YXIgcGxhbmUgPSBjb2xvcigncGxhbmUnLCAn4pyIJyk7XFxuICB2YXIgY3Jhc2hlZCA9IC0xO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gcnVud2F5ICgpIHtcXG4gICAgdmFyIGJ1ZiA9IEFycmF5KHdpZHRoKS5qb2luKCctJyk7XFxuICAgIHJldHVybiAnICAnICsgY29sb3IoJ3J1bndheScsIGJ1Zik7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFxuXFxcXG5cXFxcbiAgJyk7XFxuICAgIGN1cnNvci5oaWRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICAvLyBjaGVjayBpZiB0aGUgcGxhbmUgY3Jhc2hlZFxcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyB3aWR0aCAqICsrbiAvIHRvdGFsIHwgMCA6IGNyYXNoZWQ7XFxuXFxuICAgIC8vIHNob3cgdGhlIGNyYXNoXFxuICAgIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICAgIHBsYW5lID0gY29sb3IoJ3BsYW5lIGNyYXNoJywgJ+KciCcpO1xcbiAgICAgIGNyYXNoZWQgPSBjb2w7XFxuICAgIH1cXG5cXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXFxcdTAwMWJbMkEnKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIHN0cmVhbS53cml0ZShjb2xvcigncnVud2F5JywgQXJyYXkoY29sKS5qb2luKCfii4UnKSkpO1xcbiAgICBzdHJlYW0ud3JpdGUocGxhbmUpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXFxcbicpKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbMG0nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMYW5kaW5nLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODJ9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExpc3RgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0JywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Bhc3MnLCAnICAgICcgKyB0ZXN0LmZ1bGxUaXRsZSgpICsgJzogJykpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10ID0gY29sb3IoJ2NoZWNrbWFyaycsICcgIC0nKSArXFxuICAgICAgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xcbiAgICAgIGNvbG9yKCdwYXNzJywgJyAlczogJykgK1xcbiAgICAgIGNvbG9yKHRlc3Quc3BlZWQsICclZG1zJyk7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCksIHRlc3QuZHVyYXRpb24pO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ2ZhaWwnLCAnICAlZCkgJXMnKSwgKytuLCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMaXN0LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODJ9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogQ29uc3RhbnRzXFxuICovXFxuXFxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBNYXJrZG93biAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBsZXZlbCA9IDA7XFxuICB2YXIgYnVmID0gJyc7XFxuXFxuICBmdW5jdGlvbiB0aXRsZSAoc3RyKSB7XFxuICAgIHJldHVybiBBcnJheShsZXZlbCkuam9pbignIycpICsgJyAnICsgc3RyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWFwVE9DIChzdWl0ZSwgb2JqKSB7XFxuICAgIHZhciByZXQgPSBvYmo7XFxuICAgIHZhciBrZXkgPSBTVUlURV9QUkVGSVggKyBzdWl0ZS50aXRsZTtcXG5cXG4gICAgb2JqID0gb2JqW2tleV0gPSBvYmpba2V5XSB8fCB7IHN1aXRlOiBzdWl0ZSB9O1xcbiAgICBzdWl0ZS5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgICBtYXBUT0Moc3VpdGUsIG9iaik7XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RyaW5naWZ5VE9DIChvYmosIGxldmVsKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBidWYgPSAnJztcXG4gICAgdmFyIGxpbms7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAoa2V5ID09PSAnc3VpdGUnKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGtleSAhPT0gU1VJVEVfUFJFRklYKSB7XFxuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcXG4gICAgICAgIGxpbmsgKz0gJygjJyArIHV0aWxzLnNsdWcob2JqW2tleV0uc3VpdGUuZnVsbFRpdGxlKCkpICsgJylcXFxcbic7XFxuICAgICAgICBidWYgKz0gQXJyYXkobGV2ZWwpLmpvaW4oJyAgJykgKyBsaW5rO1xcbiAgICAgIH1cXG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ1ZjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVE9DIChzdWl0ZSkge1xcbiAgICB2YXIgb2JqID0gbWFwVE9DKHN1aXRlLCB7fSk7XFxuICAgIHJldHVybiBzdHJpbmdpZnlUT0Mob2JqLCAwKTtcXG4gIH1cXG5cXG4gIGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBzbHVnID0gdXRpbHMuc2x1ZyhzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuICAgIGJ1ZiArPSAnPGEgbmFtZT1cXFwiJyArIHNsdWcgKyAnXFxcIj48L2E+JyArICdcXFxcbic7XFxuICAgIGJ1ZiArPSB0aXRsZShzdWl0ZS50aXRsZSkgKyAnXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgLS1sZXZlbDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5jbGVhbih0ZXN0LmJvZHkpO1xcbiAgICBidWYgKz0gdGVzdC50aXRsZSArICcuXFxcXG4nO1xcbiAgICBidWYgKz0gJ1xcXFxuYGBganNcXFxcbic7XFxuICAgIGJ1ZiArPSBjb2RlICsgJ1xcXFxuJztcXG4gICAgYnVmICs9ICdgYGBcXFxcblxcXFxuJztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcjIFRPQ1xcXFxuJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xcbiAgfSk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1pbmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWluO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1pbmAgbWluaW1hbCB0ZXN0IHJlcG9ydGVyIChiZXN0IHVzZWQgd2l0aCAtLXdhdGNoKS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1pbiAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIGNsZWFyIHNjcmVlblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJKJyk7XFxuICAgIC8vIHNldCBjdXJzb3IgcG9zaXRpb25cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsxOzNIJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgdGhpcy5lcGlsb2d1ZS5iaW5kKHRoaXMpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTWluLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODJ9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE55YW5DYXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIE55YW5DYXQgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUgfCAwO1xcbiAgdmFyIG55YW5DYXRXaWR0aCA9IHRoaXMubnlhbkNhdFdpZHRoID0gMTE7XFxuXFxuICB0aGlzLmNvbG9ySW5kZXggPSAwO1xcbiAgdGhpcy5udW1iZXJPZkxpbmVzID0gNDtcXG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcXG4gIHRoaXMuc2NvcmVib2FyZFdpZHRoID0gNTtcXG4gIHRoaXMudGljayA9IDA7XFxuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XFxuICB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCA9ICh3aWR0aCAtIG55YW5DYXRXaWR0aCk7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBCYXNlLmN1cnNvci5oaWRlKCk7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgQmFzZS5jdXJzb3Iuc2hvdygpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubnVtYmVyT2ZMaW5lczsgaSsrKSB7XFxuICAgICAgd3JpdGUoJ1xcXFxuJyk7XFxuICAgIH1cXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKE55YW5DYXQsIEJhc2UpO1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIG55YW4gY2F0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5hcHBlbmRSYWluYm93KCk7XFxuICB0aGlzLmRyYXdTY29yZWJvYXJkKCk7XFxuICB0aGlzLmRyYXdSYWluYm93KCk7XFxuICB0aGlzLmRyYXdOeWFuQ2F0KCk7XFxuICB0aGlzLnRpY2sgPSAhdGhpcy50aWNrO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgXFxcInNjb3JlYm9hcmRcXFwiIHNob3dpbmcgdGhlIG51bWJlclxcbiAqIG9mIHBhc3NlcywgZmFpbHVyZXMgYW5kIHBlbmRpbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3U2NvcmVib2FyZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuXFxuICBmdW5jdGlvbiBkcmF3ICh0eXBlLCBuKSB7XFxuICAgIHdyaXRlKCcgJyk7XFxuICAgIHdyaXRlKEJhc2UuY29sb3IodHlwZSwgbikpO1xcbiAgICB3cml0ZSgnXFxcXG4nKTtcXG4gIH1cXG5cXG4gIGRyYXcoJ2dyZWVuJywgc3RhdHMucGFzc2VzKTtcXG4gIGRyYXcoJ2ZhaWwnLCBzdGF0cy5mYWlsdXJlcyk7XFxuICBkcmF3KCdwZW5kaW5nJywgc3RhdHMucGVuZGluZyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEFwcGVuZCB0aGUgcmFpbmJvdy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmFwcGVuZFJhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VnbWVudCA9IHRoaXMudGljayA/ICdfJyA6ICctJztcXG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XFxuXFxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5udW1iZXJPZkxpbmVzOyBpbmRleCsrKSB7XFxuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xcbiAgICBpZiAodHJhamVjdG9yeS5sZW5ndGggPj0gdGhpcy50cmFqZWN0b3J5V2lkdGhNYXgpIHtcXG4gICAgICB0cmFqZWN0b3J5LnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgdHJhamVjdG9yeS5wdXNoKHJhaW5ib3dpZmllZCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHdyaXRlKCdcXFxcdTAwMWJbJyArIHNlbGYuc2NvcmVib2FyZFdpZHRoICsgJ0MnKTtcXG4gICAgd3JpdGUobGluZS5qb2luKCcnKSk7XFxuICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgfSk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBueWFuIGNhdFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd055YW5DYXQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xcbiAgdmFyIGRpc3QgPSAnXFxcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xcbiAgdmFyIHBhZGRpbmcgPSAnJztcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgd3JpdGUoJ18sLS0tLS0tLCcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICAnIDogJyAgICc7XFxuICB3cml0ZSgnX3wnICsgcGFkZGluZyArICcvXFxcXFxcXFxfL1xcXFxcXFxcICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnXycgOiAnX18nO1xcbiAgdmFyIHRhaWwgPSBzZWxmLnRpY2sgPyAnficgOiAnXic7XFxuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcXG4gIHdyaXRlKHBhZGRpbmcgKyAnXFxcIlxcXCIgIFxcXCJcXFwiICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZmFjZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgcmV0dXJuICcoIHggLngpJztcXG4gIH0gZWxzZSBpZiAoc3RhdHMucGVuZGluZykge1xcbiAgICByZXR1cm4gJyggbyAubyknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wYXNzZXMpIHtcXG4gICAgcmV0dXJuICcoIF4gLl4pJztcXG4gIH1cXG4gIHJldHVybiAnKCAtIC4tKSc7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciB1cCBgbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24gKG4pIHtcXG4gIHdyaXRlKCdcXFxcdTAwMWJbJyArIG4gKyAnQScpO1xcbn07XFxuXFxuLyoqXFxuICogTW92ZSBjdXJzb3IgZG93biBgbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmN1cnNvckRvd24gPSBmdW5jdGlvbiAobikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdCJyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIGNvbG9ycyA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoNiAqIDcpOyBpKyspIHtcXG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xcbiAgICB2YXIgbiA9IChpICogKDEuMCAvIDYpKTtcXG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuKSArIDMpO1xcbiAgICB2YXIgZyA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyAyICogcGkzKSArIDMpO1xcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xcbiAgICBjb2xvcnMucHVzaCgzNiAqIHIgKyA2ICogZyArIGIgKyAxNik7XFxuICB9XFxuXFxuICByZXR1cm4gY29sb3JzO1xcbn07XFxuXFxuLyoqXFxuICogQXBwbHkgcmFpbmJvdyB0byB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICBpZiAoIUJhc2UudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxuICB2YXIgY29sb3IgPSB0aGlzLnJhaW5ib3dDb2xvcnNbdGhpcy5jb2xvckluZGV4ICUgdGhpcy5yYWluYm93Q29sb3JzLmxlbmd0aF07XFxuICB0aGlzLmNvbG9ySW5kZXggKz0gMTtcXG4gIHJldHVybiAnXFxcXHUwMDFiWzM4OzU7JyArIGNvbG9yICsgJ20nICsgc3RyICsgJ1xcXFx1MDAxYlswbSc7XFxufTtcXG5cXG4vKipcXG4gKiBTdGRvdXQgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBBIG1lc3NhZ2UgdG8gd3JpdGUgdG8gc3Rkb3V0LlxcbiAqL1xcbmZ1bmN0aW9uIHdyaXRlIChzdHJpbmcpIHtcXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHN0cmluZyk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBHZW5lcmFsIHByb2dyZXNzIGJhciBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wcm9ncmVzcyA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBiYXIgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MgKHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNTAgfCAwO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcbiAgdmFyIGNvbXBsZXRlID0gMDtcXG4gIHZhciBsYXN0TiA9IC0xO1xcblxcbiAgLy8gZGVmYXVsdCBjaGFyc1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICBvcHRpb25zLm9wZW4gPSBvcHRpb25zLm9wZW4gfHwgJ1snO1xcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGUgfHwgJ+KWrCc7XFxuICBvcHRpb25zLmluY29tcGxldGUgPSBvcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcXG4gIG9wdGlvbnMuY2xvc2UgPSBvcHRpb25zLmNsb3NlIHx8ICddJztcXG4gIG9wdGlvbnMudmVyYm9zZSA9IGZhbHNlO1xcblxcbiAgLy8gdGVzdHMgc3RhcnRlZFxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgLy8gdGVzdHMgY29tcGxldGVcXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbXBsZXRlKys7XFxuXFxuICAgIHZhciBwZXJjZW50ID0gY29tcGxldGUgLyB0b3RhbDtcXG4gICAgdmFyIG4gPSB3aWR0aCAqIHBlcmNlbnQgfCAwO1xcbiAgICB2YXIgaSA9IHdpZHRoIC0gbjtcXG5cXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcXG4gICAgICAvLyBEb24ndCByZS1yZW5kZXIgdGhlIGxpbmUgaWYgaXQgaGFzbid0IGNoYW5nZWRcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGFzdE4gPSBuO1xcblxcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYltKJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgICcgKyBvcHRpb25zLm9wZW4pKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkobikuam9pbihvcHRpb25zLmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsIG9wdGlvbnMuY2xvc2UpKTtcXG4gICAgaWYgKG9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBhcmUgY29tcGxldGUsIG91dHB1dCBzb21lIHN0YXRzXFxuICAvLyBhbmQgdGhlIGZhaWx1cmVzIGlmIGFueVxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhQcm9ncmVzcywgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3BlY2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3BlYztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTcGVjYCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gU3BlYyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBpbmRlbnRzID0gMDtcXG4gIHZhciBuID0gMDtcXG5cXG4gIGZ1bmN0aW9uIGluZGVudCAoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKGNvbG9yKCdzdWl0ZScsICclcyVzJyksIGluZGVudCgpLCBzdWl0ZS50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICAtLWluZGVudHM7XFxuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XFxuICAgICAgY29uc29sZS5sb2coKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10ID0gaW5kZW50KCkgKyBjb2xvcigncGVuZGluZycsICcgIC0gJXMnKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdDtcXG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdmYXN0Jykge1xcbiAgICAgIGZtdCA9IGluZGVudCgpICtcXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgICBjb2xvcigncGFzcycsICcgJXMnKTtcXG4gICAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZtdCA9IGluZGVudCgpICtcXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgICBjb2xvcigncGFzcycsICcgJXMnKSArXFxuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coaW5kZW50KCkgKyBjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFRBUGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEFQO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRBUGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBUQVAgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbiA9IDE7XFxuICB2YXIgcGFzc2VzID0gMDtcXG4gIHZhciBmYWlsdXJlcyA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdG90YWwgPSBydW5uZXIuZ3JlcFRvdGFsKHJ1bm5lci5zdWl0ZSk7XFxuICAgIGNvbnNvbGUubG9nKCclZC4uJWQnLCAxLCB0b3RhbCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICsrbjtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwYXNzZXMrKztcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIGZhaWx1cmVzKys7XFxuICAgIGNvbnNvbGUubG9nKCdub3Qgb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICAgIGlmIChlcnIuc3RhY2spIHtcXG4gICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJykpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygnIyB0ZXN0cyAnICsgKHBhc3NlcyArIGZhaWx1cmVzKSk7XFxuICAgIGNvbnNvbGUubG9nKCcjIHBhc3MgJyArIHBhc3Nlcyk7XFxuICAgIGNvbnNvbGUubG9nKCcjIGZhaWwgJyArIGZhaWx1cmVzKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBUQVAtc2FmZSB0aXRsZSBvZiBgdGVzdGBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRpdGxlICh0ZXN0KSB7XFxuICByZXR1cm4gdGVzdC5mdWxsVGl0bGUoKS5yZXBsYWNlKC8jL2csICcnKTtcXG59XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIGVzY2FwZSA9IHV0aWxzLmVzY2FwZTtcXG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgWFVuaXRgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFhVbml0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFhVbml0YCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFhVbml0IChydW5uZXIsIG9wdGlvbnMpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciB0ZXN0cyA9IFtdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgJiYgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSB7XFxuICAgIGlmICghZnMuY3JlYXRlV3JpdGVTdHJlYW0pIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGUgb3V0cHV0IG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xcbiAgICB9XFxuICAgIG1rZGlycC5zeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpKTtcXG4gICAgc2VsZi5maWxlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBzZWxmLndyaXRlKHRhZygndGVzdHN1aXRlJywge1xcbiAgICAgIG5hbWU6ICdNb2NoYSBUZXN0cycsXFxuICAgICAgdGVzdHM6IHN0YXRzLnRlc3RzLFxcbiAgICAgIGZhaWx1cmVzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICBlcnJvcnM6IHN0YXRzLmZhaWx1cmVzLFxcbiAgICAgIHNraXBwZWQ6IHN0YXRzLnRlc3RzIC0gc3RhdHMuZmFpbHVyZXMgLSBzdGF0cy5wYXNzZXMsXFxuICAgICAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKSxcXG4gICAgICB0aW1lOiAoc3RhdHMuZHVyYXRpb24gLyAxMDAwKSB8fCAwXFxuICAgIH0sIGZhbHNlKSk7XFxuXFxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcXG4gICAgICBzZWxmLnRlc3QodCk7XFxuICAgIH0pO1xcblxcbiAgICBzZWxmLndyaXRlKCc8L3Rlc3RzdWl0ZT4nKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhYVW5pdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgZG9uZSB0byBjbG9zZSB0aGUgc3RyZWFtIChpZiBpdCdzIGEgZmlsZSkuXFxuICpcXG4gKiBAcGFyYW0gZmFpbHVyZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblhVbml0LnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZhaWx1cmVzLCBmbikge1xcbiAgaWYgKHRoaXMuZmlsZVN0cmVhbSkge1xcbiAgICB0aGlzLmZpbGVTdHJlYW0uZW5kKGZ1bmN0aW9uICgpIHtcXG4gICAgICBmbihmYWlsdXJlcyk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgZm4oZmFpbHVyZXMpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmVcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobGluZSkge1xcbiAgaWYgKHRoaXMuZmlsZVN0cmVhbSkge1xcbiAgICB0aGlzLmZpbGVTdHJlYW0ud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIHtcXG4gICAgY29uc29sZS5sb2cobGluZSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBPdXRwdXQgdGFnIGZvciB0aGUgZ2l2ZW4gYHRlc3QuYFxcbiAqXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICovXFxuWFVuaXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgdmFyIGF0dHJzID0ge1xcbiAgICBjbGFzc25hbWU6IHRlc3QucGFyZW50LmZ1bGxUaXRsZSgpLFxcbiAgICBuYW1lOiB0ZXN0LnRpdGxlLFxcbiAgICB0aW1lOiAodGVzdC5kdXJhdGlvbiAvIDEwMDApIHx8IDBcXG4gIH07XFxuXFxuICBpZiAodGVzdC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcXG4gICAgdmFyIGVyciA9IHRlc3QuZXJyO1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgZmFsc2UsIHRhZygnZmFpbHVyZScsIHt9LCBmYWxzZSwgZXNjYXBlKGVyci5tZXNzYWdlKSArICdcXFxcbicgKyBlc2NhcGUoZXJyLnN0YWNrKSkpKTtcXG4gIH0gZWxzZSBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgZmFsc2UsIHRhZygnc2tpcHBlZCcsIHt9LCB0cnVlKSkpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIHRydWUpKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEhUTUwgdGFnIGhlbHBlci5cXG4gKlxcbiAqIEBwYXJhbSBuYW1lXFxuICogQHBhcmFtIGF0dHJzXFxuICogQHBhcmFtIGNsb3NlXFxuICogQHBhcmFtIGNvbnRlbnRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGFnIChuYW1lLCBhdHRycywgY2xvc2UsIGNvbnRlbnQpIHtcXG4gIHZhciBlbmQgPSBjbG9zZSA/ICcvPicgOiAnPic7XFxuICB2YXIgcGFpcnMgPSBbXTtcXG4gIHZhciB0YWc7XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywga2V5KSkge1xcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz1cXFwiJyArIGVzY2FwZShhdHRyc1trZXldKSArICdcXFwiJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRhZyA9ICc8JyArIG5hbWUgKyAocGFpcnMubGVuZ3RoID8gJyAnICsgcGFpcnMuam9pbignICcpIDogJycpICsgZW5kO1xcbiAgaWYgKGNvbnRlbnQpIHtcXG4gICAgdGFnICs9IGNvbnRlbnQgKyAnPC8nICsgbmFtZSArIGVuZDtcXG4gIH1cXG4gIHJldHVybiB0YWc7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJmc1xcXCI6NDIsXFxcIm1rZGlycFxcXCI6NzksXFxcInBhdGhcXFwiOjQyfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBKU09OID0gcmVxdWlyZSgnanNvbjMnKTtcXG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnJ1bm5hYmxlJyk7XFxudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJy4vbXMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5jcmVhdGUnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nKCkuXFxuICovXFxuXFxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5hYmxlYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5hYmxlO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJ1bm5hYmxlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5hYmxlICh0aXRsZSwgZm4pIHtcXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIHRoaXMuZm4gPSBmbjtcXG4gIHRoaXMuYm9keSA9IChmbiB8fCAnJykudG9TdHJpbmcoKTtcXG4gIHRoaXMuYXN5bmMgPSBmbiAmJiBmbi5sZW5ndGg7XFxuICB0aGlzLnN5bmMgPSAhdGhpcy5hc3luYztcXG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xcbiAgdGhpcy5fc2xvdyA9IDc1O1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSB0cnVlO1xcbiAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xcbiAgdGhpcy5fdHJhY2UgPSBuZXcgRXJyb3IoJ2RvbmUoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcXG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcXG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IDA7XFxuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUgPSBjcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xcbiAgY29uc3RydWN0b3I6IFJ1bm5hYmxlXFxufSk7XFxuXFxuLyoqXFxuICogU2V0ICYgZ2V0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XFxuICB9XFxuICAvLyBzZWUgIzE2NTIgZm9yIHJlYXNvbmluZ1xcbiAgaWYgKG1zID09PSAwIHx8IG1zID4gTWF0aC5wb3coMiwgMzEpKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcXG4gIGlmICh0aGlzLnRpbWVyKSB7XFxuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCAmIGdldCBzbG93IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7UnVubmFibGV8bnVtYmVyfSBtcyBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGFuZCBnZXQgd2hldGhlciB0aW1lb3V0IGlzIGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge1J1bm5hYmxlfGJvb2xlYW59IGVuYWJsZWQgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSGFsdCBhbmQgbWFyayBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRocm93IG5ldyBQZW5kaW5nKCdzeW5jIHNraXAnKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHRoaXMgcnVubmFibGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5wZW5kaW5nIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1BlbmRpbmcoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJpZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XFxuICB9XFxuICB0aGlzLl9yZXRyaWVzID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBjdXJyZW50IHJldHJ5XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuY3VycmVudFJldHJ5ID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xcbiAgfVxcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBhcmVudC5mdWxsVGl0bGUoKSArICcgJyArIHRoaXMudGl0bGU7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhciB0aGUgdGltZW91dC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XFxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxufTtcXG5cXG4vKipcXG4gKiBJbnNwZWN0IHRoZSBydW5uYWJsZSB2b2lkIG9mIHByaXZhdGUgcHJvcGVydGllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcXG4gICAgaWYgKGtleVswXSA9PT0gJ18nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChrZXkgPT09ICdwYXJlbnQnKSB7XFxuICAgICAgcmV0dXJuICcjPFN1aXRlPic7XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ2N0eCcpIHtcXG4gICAgICByZXR1cm4gJyM8Q29udGV4dD4nO1xcbiAgICB9XFxuICAgIHJldHVybiB2YWw7XFxuICB9LCAyKTtcXG59O1xcblxcbi8qKlxcbiAqIFJlc2V0IHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnJlc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBtcyA9IHRoaXMudGltZW91dCgpIHx8IDFlOTtcXG5cXG4gIGlmICghdGhpcy5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcXG4gIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzZWxmLmNhbGxiYWNrKG5ldyBFcnJvcignVGltZW91dCBvZiAnICsgbXMgK1xcbiAgICAgICdtcyBleGNlZWRlZC4gRm9yIGFzeW5jIHRlc3RzIGFuZCBob29rcywgZW5zdXJlIFxcXCJkb25lKClcXFwiIGlzIGNhbGxlZDsgaWYgcmV0dXJuaW5nIGEgUHJvbWlzZSwgZW5zdXJlIGl0IHJlc29sdmVzLicpKTtcXG4gICAgc2VsZi50aW1lZE91dCA9IHRydWU7XFxuICB9LCBtcyk7XFxufTtcXG5cXG4vKipcXG4gKiBXaGl0ZWxpc3QgYSBsaXN0IG9mIGdsb2JhbHMgZm9yIHRoaXMgdGVzdCBydW4uXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBnbG9iYWxzXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoZ2xvYmFscykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9hbGxvd2VkR2xvYmFscztcXG4gIH1cXG4gIHRoaXMuX2FsbG93ZWRHbG9iYWxzID0gZ2xvYmFscztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgdGVzdCBhbmQgaW52b2tlIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcXG4gIHZhciBjdHggPSB0aGlzLmN0eDtcXG4gIHZhciBmaW5pc2hlZDtcXG4gIHZhciBlbWl0dGVkO1xcblxcbiAgLy8gU29tZXRpbWVzIHRoZSBjdHggZXhpc3RzLCBidXQgaXQgaXMgbm90IHJ1bm5hYmxlXFxuICBpZiAoY3R4ICYmIGN0eC5ydW5uYWJsZSkge1xcbiAgICBjdHgucnVubmFibGUodGhpcyk7XFxuICB9XFxuXFxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcXG4gIGZ1bmN0aW9uIG11bHRpcGxlIChlcnIpIHtcXG4gICAgaWYgKGVtaXR0ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZW1pdHRlZCA9IHRydWU7XFxuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIgfHwgbmV3IEVycm9yKCdkb25lKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzOyBzdGFja3RyYWNlIG1heSBiZSBpbmFjY3VyYXRlJykpO1xcbiAgfVxcblxcbiAgLy8gZmluaXNoZWRcXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xcbiAgICB2YXIgbXMgPSBzZWxmLnRpbWVvdXQoKTtcXG4gICAgaWYgKHNlbGYudGltZWRPdXQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKGZpbmlzaGVkKSB7XFxuICAgICAgcmV0dXJuIG11bHRpcGxlKGVyciB8fCBzZWxmLl90cmFjZSk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5jbGVhclRpbWVvdXQoKTtcXG4gICAgc2VsZi5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGFydDtcXG4gICAgZmluaXNoZWQgPSB0cnVlO1xcbiAgICBpZiAoIWVyciAmJiBzZWxmLmR1cmF0aW9uID4gbXMgJiYgc2VsZi5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1RpbWVvdXQgb2YgJyArIG1zICtcXG4gICAgICAnbXMgZXhjZWVkZWQuIEZvciBhc3luYyB0ZXN0cyBhbmQgaG9va3MsIGVuc3VyZSBcXFwiZG9uZSgpXFxcIiBpcyBjYWxsZWQ7IGlmIHJldHVybmluZyBhIFByb21pc2UsIGVuc3VyZSBpdCByZXNvbHZlcy4nKTtcXG4gICAgfVxcbiAgICBmbihlcnIpO1xcbiAgfVxcblxcbiAgLy8gZm9yIC5yZXNldFRpbWVvdXQoKVxcbiAgdGhpcy5jYWxsYmFjayA9IGRvbmU7XFxuXFxuICAvLyBleHBsaWNpdCBhc3luYyB3aXRoIGBkb25lYCBhcmd1bWVudFxcbiAgaWYgKHRoaXMuYXN5bmMpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG5cXG4gICAgLy8gYWxsb3dzIHNraXAoKSB0byBiZSB1c2VkIGluIGFuIGV4cGxpY2l0IGFzeW5jIGNvbnRleHRcXG4gICAgdGhpcy5za2lwID0gZnVuY3Rpb24gYXN5bmNTa2lwICgpIHtcXG4gICAgICBkb25lKG5ldyBQZW5kaW5nKCdhc3luYyBza2lwIGNhbGwnKSk7XFxuICAgICAgLy8gaGFsdCBleGVjdXRpb24uICB0aGUgUnVubmFibGUgd2lsbCBiZSBtYXJrZWQgcGVuZGluZ1xcbiAgICAgIC8vIGJ5IHRoZSBwcmV2aW91cyBjYWxsLCBhbmQgdGhlIHVuY2F1Z2h0IGhhbmRsZXIgd2lsbCBpZ25vcmVcXG4gICAgICAvLyB0aGUgZmFpbHVyZS5cXG4gICAgICB0aHJvdyBuZXcgUGVuZGluZygnYXN5bmMgc2tpcDsgYWJvcnRpbmcgZXhlY3V0aW9uJyk7XFxuICAgIH07XFxuXFxuICAgIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgICByZXR1cm4gY2FsbEZuQXN5bmModGhpcy5mbik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgZW1pdHRlZCA9IHRydWU7XFxuICAgICAgZG9uZSh1dGlscy5nZXRFcnJvcihlcnIpKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxGbih0aGlzLmZuKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBzeW5jIG9yIHByb21pc2UtcmV0dXJuaW5nXFxuICB0cnkge1xcbiAgICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICAgIGRvbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjYWxsRm4odGhpcy5mbik7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgZG9uZSh1dGlscy5nZXRFcnJvcihlcnIpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbiAoZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcXG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBzZWxmLnJlc2V0VGltZW91dCgpO1xcbiAgICAgIHJlc3VsdFxcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBkb25lKCk7XFxuICAgICAgICAgIC8vIFJldHVybiBudWxsIHNvIGxpYnJhcmllcyBsaWtlIGJsdWViaXJkIGRvIG5vdCB3YXJuIGFib3V0XFxuICAgICAgICAgIC8vIHN1YnNlcXVlbnRseSBjb25zdHJ1Y3RlZCBQcm9taXNlcy5cXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9LFxcbiAgICAgICAgZnVuY3Rpb24gKHJlYXNvbikge1xcbiAgICAgICAgICBkb25lKHJlYXNvbiB8fCBuZXcgRXJyb3IoJ1Byb21pc2UgcmVqZWN0ZWQgd2l0aCBubyBvciBmYWxzeSByZWFzb24nKSk7XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoc2VsZi5hc3luY09ubHkpIHtcXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignLS1hc3luYy1vbmx5IG9wdGlvbiBpbiB1c2Ugd2l0aG91dCBkZWNsYXJpbmcgYGRvbmUoKWAgb3IgcmV0dXJuaW5nIGEgcHJvbWlzZScpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9uZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm5Bc3luYyAoZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICtcXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShlcnIpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgZXJyKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNQcm9taXNlKHJlc3VsdCkpIHtcXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignUmVzb2x1dGlvbiBtZXRob2QgaXMgb3ZlcnNwZWNpZmllZC4gU3BlY2lmeSBhIGNhbGxiYWNrICpvciogcmV0dXJuIGEgUHJvbWlzZTsgbm90IGJvdGguJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbXNcXFwiOjE1LFxcXCIuL3BlbmRpbmdcXFwiOjE2LFxcXCIuL3V0aWxzXFxcIjozOCxcXFwiZGVidWdcXFwiOjIsXFxcImV2ZW50c1xcXCI6MyxcXFwianNvbjNcXFwiOjY5LFxcXCJsb2Rhc2guY3JlYXRlXFxcIjo3NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnJ1bm5lcicpO1xcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG52YXIgZmlsdGVyID0gdXRpbHMuZmlsdGVyO1xcbnZhciBpbmRleE9mID0gdXRpbHMuaW5kZXhPZjtcXG52YXIgc29tZSA9IHV0aWxzLnNvbWU7XFxudmFyIGtleXMgPSB1dGlscy5rZXlzO1xcbnZhciBzdGFja0ZpbHRlciA9IHV0aWxzLnN0YWNrVHJhY2VGaWx0ZXIoKTtcXG52YXIgc3RyaW5naWZ5ID0gdXRpbHMuc3RyaW5naWZ5O1xcbnZhciB0eXBlID0gdXRpbHMudHlwZTtcXG52YXIgdW5kZWZpbmVkRXJyb3IgPSB1dGlscy51bmRlZmluZWRFcnJvcjtcXG52YXIgaXNBcnJheSA9IHV0aWxzLmlzQXJyYXk7XFxuXFxuLyoqXFxuICogTm9uLWVudW1lcmFibGUgZ2xvYmFscy5cXG4gKi9cXG5cXG52YXIgZ2xvYmFscyA9IFtcXG4gICdzZXRUaW1lb3V0JyxcXG4gICdjbGVhclRpbWVvdXQnLFxcbiAgJ3NldEludGVydmFsJyxcXG4gICdjbGVhckludGVydmFsJyxcXG4gICdYTUxIdHRwUmVxdWVzdCcsXFxuICAnRGF0ZScsXFxuICAnc2V0SW1tZWRpYXRlJyxcXG4gICdjbGVhckltbWVkaWF0ZSdcXG5dO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmVyYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgYFJ1bm5lcmAgZm9yIHRoZSBnaXZlbiBgc3VpdGVgLlxcbiAqXFxuICogRXZlbnRzOlxcbiAqXFxuICogICAtIGBzdGFydGAgIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBlbmRgICBleGVjdXRpb24gY29tcGxldGVcXG4gKiAgIC0gYHN1aXRlYCAgKHN1aXRlKSB0ZXN0IHN1aXRlIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBzdWl0ZSBlbmRgICAoc3VpdGUpIGFsbCB0ZXN0cyAoYW5kIHN1Yi1zdWl0ZXMpIGhhdmUgZmluaXNoZWRcXG4gKiAgIC0gYHRlc3RgICAodGVzdCkgdGVzdCBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgdGVzdCBlbmRgICAodGVzdCkgdGVzdCBjb21wbGV0ZWRcXG4gKiAgIC0gYGhvb2tgICAoaG9vaykgaG9vayBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgaG9vayBlbmRgICAoaG9vaykgaG9vayBjb21wbGV0ZVxcbiAqICAgLSBgcGFzc2AgICh0ZXN0KSB0ZXN0IHBhc3NlZFxcbiAqICAgLSBgZmFpbGAgICh0ZXN0LCBlcnIpIHRlc3QgZmFpbGVkXFxuICogICAtIGBwZW5kaW5nYCAgKHRlc3QpIHRlc3QgcGVuZGluZ1xcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlXFxuICogQHBhcmFtIHtib29sZWFufSBbZGVsYXldIFdoZXRoZXIgb3Igbm90IHRvIGRlbGF5IGV4ZWN1dGlvbiBvZiByb290IHN1aXRlXFxuICogdW50aWwgcmVhZHkuXFxuICovXFxuZnVuY3Rpb24gUnVubmVyIChzdWl0ZSwgZGVsYXkpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHRoaXMuX2dsb2JhbHMgPSBbXTtcXG4gIHRoaXMuX2Fib3J0ID0gZmFsc2U7XFxuICB0aGlzLl9kZWxheSA9IGRlbGF5O1xcbiAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xcbiAgdGhpcy5zdGFydGVkID0gZmFsc2U7XFxuICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcXG4gIHRoaXMuZmFpbHVyZXMgPSAwO1xcbiAgdGhpcy5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBzZWxmLmNoZWNrR2xvYmFscyh0ZXN0KTtcXG4gIH0pO1xcbiAgdGhpcy5vbignaG9vayBlbmQnLCBmdW5jdGlvbiAoaG9vaykge1xcbiAgICBzZWxmLmNoZWNrR2xvYmFscyhob29rKTtcXG4gIH0pO1xcbiAgdGhpcy5fZGVmYXVsdEdyZXAgPSAvLiovO1xcbiAgdGhpcy5ncmVwKHRoaXMuX2RlZmF1bHRHcmVwKTtcXG4gIHRoaXMuZ2xvYmFscyh0aGlzLmdsb2JhbFByb3BzKCkuY29uY2F0KGV4dHJhR2xvYmFscygpKSk7XFxufVxcblxcbi8qKlxcbiAqIFdyYXBwZXIgZm9yIHNldEltbWVkaWF0ZSwgcHJvY2Vzcy5uZXh0VGljaywgb3IgYnJvd3NlciBwb2x5ZmlsbC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLmltbWVkaWF0ZWx5ID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBwcm9jZXNzLm5leHRUaWNrO1xcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUnVubmVyLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyB3aXRoIGZ1bGwgdGl0bGVzIG1hdGNoaW5nIGByZWAuIFVwZGF0ZXMgcnVubmVyLnRvdGFsXFxuICogd2l0aCBudW1iZXIgb2YgdGVzdHMgbWF0Y2hlZC5cXG4gKlxcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52ZXJ0XFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24gKHJlLCBpbnZlcnQpIHtcXG4gIGRlYnVnKCdncmVwICVzJywgcmUpO1xcbiAgdGhpcy5fZ3JlcCA9IHJlO1xcbiAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xcbiAgdGhpcy50b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHRoaXMuc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGVzdHMgbWF0Y2hpbmcgdGhlIGdyZXAgc2VhcmNoIGZvciB0aGVcXG4gKiBnaXZlbiBzdWl0ZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7TnVtYmVyfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwVG90YWwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IDA7XFxuXFxuICBzdWl0ZS5lYWNoVGVzdChmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XFxuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcXG4gICAgICBtYXRjaCA9ICFtYXRjaDtcXG4gICAgfVxcbiAgICBpZiAobWF0Y2gpIHtcXG4gICAgICB0b3RhbCsrO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGxpc3Qgb2YgZ2xvYmFsIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbFByb3BzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHByb3BzID0ga2V5cyhnbG9iYWwpO1xcblxcbiAgLy8gbm9uLWVudW1lcmFibGVzXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JhbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKH5pbmRleE9mKHByb3BzLCBnbG9iYWxzW2ldKSkge1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHByb3BzLnB1c2goZ2xvYmFsc1tpXSk7XFxuICB9XFxuXFxuICByZXR1cm4gcHJvcHM7XFxufTtcXG5cXG4vKipcXG4gKiBBbGxvdyB0aGUgZ2l2ZW4gYGFycmAgb2YgZ2xvYmFscy5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEByZXR1cm4ge1J1bm5lcn0gZm9yIGNoYWluaW5nXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoYXJyKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbHM7XFxuICB9XFxuICBkZWJ1ZygnZ2xvYmFscyAlaicsIGFycik7XFxuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQoYXJyKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIGdsb2JhbCB2YXJpYWJsZSBsZWFrcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuY2hlY2tHbG9iYWxzID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIGlmICh0aGlzLmlnbm9yZUxlYWtzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBvayA9IHRoaXMuX2dsb2JhbHM7XFxuXFxuICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsUHJvcHMoKTtcXG4gIHZhciBsZWFrcztcXG5cXG4gIGlmICh0ZXN0KSB7XFxuICAgIG9rID0gb2suY29uY2F0KHRlc3QuX2FsbG93ZWRHbG9iYWxzIHx8IFtdKTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID09PSBnbG9iYWxzLmxlbmd0aCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID0gZ2xvYmFscy5sZW5ndGg7XFxuXFxuICBsZWFrcyA9IGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChsZWFrcyk7XFxuXFxuICBpZiAobGVha3MubGVuZ3RoID4gMSkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVha3MgZGV0ZWN0ZWQ6ICcgKyBsZWFrcy5qb2luKCcsICcpICsgJycpKTtcXG4gIH0gZWxzZSBpZiAobGVha3MubGVuZ3RoKSB7XFxuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ2dsb2JhbCBsZWFrIGRldGVjdGVkOiAnICsgbGVha3NbMF0pKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZhaWwgdGhlIGdpdmVuIGB0ZXN0YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gICsrdGhpcy5mYWlsdXJlcztcXG4gIHRlc3Quc3RhdGUgPSAnZmFpbGVkJztcXG5cXG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IGVyciAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSkge1xcbiAgICBlcnIgPSBuZXcgRXJyb3IoJ3RoZSAnICsgdHlwZShlcnIpICsgJyAnICsgc3RyaW5naWZ5KGVycikgKyAnIHdhcyB0aHJvd24sIHRocm93IGFuIEVycm9yIDopJyk7XFxuICB9XFxuXFxuICB0cnkge1xcbiAgICBlcnIuc3RhY2sgPSAodGhpcy5mdWxsU3RhY2tUcmFjZSB8fCAhZXJyLnN0YWNrKVxcbiAgICAgID8gZXJyLnN0YWNrXFxuICAgICAgOiBzdGFja0ZpbHRlcihlcnIuc3RhY2spO1xcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xcbiAgICAvLyBzb21lIGVudmlyb25tZW50cyBkbyBub3QgdGFrZSBraW5kbHkgdG8gbW9ua2V5aW5nIHdpdGggdGhlIHN0YWNrXFxuICB9XFxuXFxuICB0aGlzLmVtaXQoJ2ZhaWwnLCB0ZXN0LCBlcnIpO1xcbn07XFxuXFxuLyoqXFxuICogRmFpbCB0aGUgZ2l2ZW4gYGhvb2tgIHdpdGggYGVycmAuXFxuICpcXG4gKiBIb29rIGZhaWx1cmVzIHdvcmsgaW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxcbiAqIC0gSWYgYmFpbCwgdGhlbiBleGl0XFxuICogLSBGYWlsZWQgYGJlZm9yZWAgaG9vayBza2lwcyBhbGwgdGVzdHMgaW4gYSBzdWl0ZSBhbmQgc3Vic3VpdGVzLFxcbiAqICAgYnV0IGp1bXBzIHRvIGNvcnJlc3BvbmRpbmcgYGFmdGVyYCBob29rXFxuICogLSBGYWlsZWQgYGJlZm9yZSBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgaG9vayxcXG4gKiAgIHdoaWNoIGlzIHJ1biBvbmx5IG9uY2VcXG4gKiAtIEZhaWxlZCBgYWZ0ZXJgIGhvb2sgZG9lcyBub3QgYWx0ZXJcXG4gKiAgIGV4ZWN1dGlvbiBvcmRlclxcbiAqIC0gRmFpbGVkIGBhZnRlciBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQgc3Vic3VpdGVzLCBidXQgZXhlY3V0ZXMgb3RoZXIgYGFmdGVyIGVhY2hgXFxuICogICBob29rc1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtIb29rfSBob29rXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5mYWlsSG9vayA9IGZ1bmN0aW9uIChob29rLCBlcnIpIHtcXG4gIGlmIChob29rLmN0eCAmJiBob29rLmN0eC5jdXJyZW50VGVzdCkge1xcbiAgICBob29rLm9yaWdpbmFsVGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgfHwgaG9vay50aXRsZTtcXG4gICAgaG9vay50aXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSArICcgZm9yIFxcXCInICsgaG9vay5jdHguY3VycmVudFRlc3QudGl0bGUgKyAnXFxcIic7XFxuICB9XFxuXFxuICB0aGlzLmZhaWwoaG9vaywgZXJyKTtcXG4gIGlmICh0aGlzLnN1aXRlLmJhaWwoKSkge1xcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGNhbGxiYWNrcyBhbmQgdGhlbiBpbnZva2UgYGZuKClgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblxcblJ1bm5lci5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBob29rcyA9IHN1aXRlWydfJyArIG5hbWVdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoaSkge1xcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xcbiAgICBpZiAoIWhvb2spIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcbiAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IGhvb2s7XFxuXFxuICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gc2VsZi50ZXN0O1xcblxcbiAgICBzZWxmLmVtaXQoJ2hvb2snLCBob29rKTtcXG5cXG4gICAgaWYgKCFob29rLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcXG4gICAgICBob29rLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBob29rLnJ1bihmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgdmFyIHRlc3RFcnJvciA9IGhvb2suZXJyb3IoKTtcXG4gICAgICBpZiAodGVzdEVycm9yKSB7XFxuICAgICAgICBzZWxmLmZhaWwoc2VsZi50ZXN0LCB0ZXN0RXJyb3IpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2JlZm9yZUVhY2gnIHx8IG5hbWUgPT09ICdhZnRlckVhY2gnKSB7XFxuICAgICAgICAgICAgc2VsZi50ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2goc3VpdGUudGVzdHMsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vIGEgcGVuZGluZyBob29rIHdvbid0IGJlIGV4ZWN1dGVkIHR3aWNlLlxcbiAgICAgICAgICAgIGhvb2sucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG5cXG4gICAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcXG4gICAgICAgICAgcmV0dXJuIGZuKGVycik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNlbGYuZW1pdCgnaG9vayBlbmQnLCBob29rKTtcXG4gICAgICBkZWxldGUgaG9vay5jdHguY3VycmVudFRlc3Q7XFxuICAgICAgbmV4dCgrK2kpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XFxuICAgIG5leHQoMCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rIGBuYW1lYCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGBzdWl0ZXNgXFxuICogaW4gb3JkZXIsIGFuZCBjYWxsYmFjayBgZm4oZXJyLCBlcnJTdWl0ZSlgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va3MgPSBmdW5jdGlvbiAobmFtZSwgc3VpdGVzLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG9yaWcgPSB0aGlzLnN1aXRlO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoc3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcblxcbiAgICBpZiAoIXN1aXRlKSB7XFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5ob29rKG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICB2YXIgZXJyU3VpdGUgPSBzZWxmLnN1aXRlO1xcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgICByZXR1cm4gZm4oZXJyLCBlcnJTdWl0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5leHQoc3VpdGVzLnBvcCgpKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBuZXh0KHN1aXRlcy5wb3AoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgdG9wIGxldmVsIGRvd24uXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rVXAgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZXMgPSBbdGhpcy5zdWl0ZV0uY29uY2F0KHRoaXMucGFyZW50cygpKS5yZXZlcnNlKCk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2tzIGZyb20gdGhlIGJvdHRvbSB1cC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tEb3duID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBhcmVudCBTdWl0ZXMgZnJvbVxcbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIHN1aXRlcyA9IFtdO1xcbiAgd2hpbGUgKHN1aXRlLnBhcmVudCkge1xcbiAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudDtcXG4gICAgc3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHN1aXRlcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgY3VycmVudCB0ZXN0IGFuZCBjYWxsYmFjayBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuVGVzdCA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3Q7XFxuXFxuICBpZiAoIXRlc3QpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKHRoaXMuYXN5bmNPbmx5KSB7XFxuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIH1cXG4gIHRlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xcbiAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcXG4gIH0pO1xcbiAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICB0ZXN0LmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgICByZXR1cm4gdGVzdC5ydW4oZm4pO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgdGVzdC5ydW4oZm4pO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGZuKGVycik7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgaW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0cyA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0cyA9IHN1aXRlLnRlc3RzLnNsaWNlKCk7XFxuICB2YXIgdGVzdDtcXG5cXG4gIGZ1bmN0aW9uIGhvb2tFcnIgKF8sIGVyclN1aXRlLCBhZnRlcikge1xcbiAgICAvLyBiZWZvcmUvYWZ0ZXIgRWFjaCBob29rIGZvciBlcnJTdWl0ZSBmYWlsZWQ6XFxuICAgIHZhciBvcmlnID0gc2VsZi5zdWl0ZTtcXG5cXG4gICAgLy8gZm9yIGZhaWxlZCAnYWZ0ZXIgZWFjaCcgaG9vayBzdGFydCBmcm9tIGVyclN1aXRlIHBhcmVudCxcXG4gICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGZyb20gZXJyU3VpdGUgaXRzZWxmXFxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xcblxcbiAgICBpZiAoc2VsZi5zdWl0ZSkge1xcbiAgICAgIC8vIGNhbGwgaG9va1VwIGFmdGVyRWFjaFxcbiAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBmdW5jdGlvbiAoZXJyMiwgZXJyU3VpdGUyKSB7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIC8vIHNvbWUgaG9va3MgbWF5IGZhaWwgZXZlbiBub3dcXG4gICAgICAgIGlmIChlcnIyKSB7XFxuICAgICAgICAgIHJldHVybiBob29rRXJyKGVycjIsIGVyclN1aXRlMiwgdHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyByZXBvcnQgZXJyb3Igc3VpdGVcXG4gICAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGNhbGxpbmcgb3RoZXIgJ2FmdGVyIGVhY2gnIGhvb2tzXFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBuZXh0IChlcnIsIGVyclN1aXRlKSB7XFxuICAgIC8vIGlmIHdlIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyXFxuICAgIGlmIChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVycikge1xcbiAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIC8vIG5leHQgdGVzdFxcbiAgICB0ZXN0ID0gdGVzdHMuc2hpZnQoKTtcXG5cXG4gICAgLy8gYWxsIGRvbmVcXG4gICAgaWYgKCF0ZXN0KSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZ3JlcFxcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XFxuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcXG4gICAgICBtYXRjaCA9ICFtYXRjaDtcXG4gICAgfVxcbiAgICBpZiAoIW1hdGNoKSB7XFxuICAgICAgLy8gUnVuIGltbWVkaWF0ZWx5IG9ubHkgaWYgd2UgaGF2ZSBkZWZpbmVkIGEgZ3JlcC4gV2hlbiB3ZVxcbiAgICAgIC8vIGRlZmluZSBhIGdyZXAg4oCUIEl0IGNhbiBjYXVzZSBtYXhpbXVtIGNhbGxzdGFjayBlcnJvciBpZlxcbiAgICAgIC8vIHRoZSBncmVwIGlzIGRvaW5nIGEgbGFyZ2UgcmVjdXJzaXZlIGxvb3AgYnkgbmVnbGVjdGluZ1xcbiAgICAgIC8vIGFsbCB0ZXN0cy4gVGhlIHJ1biBpbW1lZGlhdGVseSBmdW5jdGlvbiBhbHNvIGNvbWVzIHdpdGhcXG4gICAgICAvLyBhIHBlcmZvcm1hbmNlIGNvc3QuIFNvIHdlIGRvbid0IHdhbnQgdG8gcnVuIGltbWVkaWF0ZWx5XFxuICAgICAgLy8gaWYgd2UgcnVuIHRoZSB3aG9sZSB0ZXN0IHN1aXRlLCBiZWNhdXNlIHJ1bm5pbmcgdGhlIHdob2xlXFxuICAgICAgLy8gdGVzdCBzdWl0ZSBkb24ndCBkbyBhbnkgaW1tZWRpYXRlIHJlY3Vyc2l2ZSBsb29wcy4gVGh1cyxcXG4gICAgICAvLyBhbGxvd2luZyBhIEpTIHJ1bnRpbWUgdG8gYnJlYXRoZS5cXG4gICAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcXG4gICAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShuZXh0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgfVxcblxcbiAgICAvLyBleGVjdXRlIHRlc3QgYW5kIGhvb2socylcXG4gICAgc2VsZi5lbWl0KCd0ZXN0Jywgc2VsZi50ZXN0ID0gdGVzdCk7XFxuICAgIHNlbGYuaG9va0Rvd24oJ2JlZm9yZUVhY2gnLCBmdW5jdGlvbiAoZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBzZWxmLnRlc3Q7XFxuICAgICAgc2VsZi5ydW5UZXN0KGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHRlc3QgPSBzZWxmLnRlc3Q7XFxuICAgICAgICBpZiAoZXJyKSB7XFxuICAgICAgICAgIHZhciByZXRyeSA9IHRlc3QuY3VycmVudFJldHJ5KCk7XFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXRyeSA8IHRlc3QucmV0cmllcygpKSB7XFxuICAgICAgICAgICAgdmFyIGNsb25lZFRlc3QgPSB0ZXN0LmNsb25lKCk7XFxuICAgICAgICAgICAgY2xvbmVkVGVzdC5jdXJyZW50UmV0cnkocmV0cnkgKyAxKTtcXG4gICAgICAgICAgICB0ZXN0cy51bnNoaWZ0KGNsb25lZFRlc3QpO1xcblxcbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiArIGhvb2sgdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXNuJ3RcXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50IHdyb25nXFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuXFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGVzdC5zdGF0ZSA9ICdwYXNzZWQnO1xcbiAgICAgICAgc2VsZi5lbWl0KCdwYXNzJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgdGhpcy5uZXh0ID0gbmV4dDtcXG4gIHRoaXMuaG9va0VyciA9IGhvb2tFcnI7XFxuICBuZXh0KCk7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5TdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHN1aXRlKTtcXG4gIHZhciBhZnRlckFsbEhvb2tDYWxsZWQgPSBmYWxzZTtcXG5cXG4gIGRlYnVnKCdydW4gc3VpdGUgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuXFxuICBpZiAoIXRvdGFsIHx8IChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSkge1xcbiAgICByZXR1cm4gZm4oKTtcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCB0aGlzLnN1aXRlID0gc3VpdGUpO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoZXJyU3VpdGUpIHtcXG4gICAgaWYgKGVyclN1aXRlKSB7XFxuICAgICAgLy8gY3VycmVudCBzdWl0ZSBmYWlsZWQgb24gYSBob29rIGZyb20gZXJyU3VpdGVcXG4gICAgICBpZiAoZXJyU3VpdGUgPT09IHN1aXRlKSB7XFxuICAgICAgICAvLyBpZiBlcnJTdWl0ZSBpcyBjdXJyZW50IHN1aXRlXFxuICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBzaWJsaW5nIHN1aXRlXFxuICAgICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICAgIH1cXG4gICAgICAvLyBlcnJTdWl0ZSBpcyBhbW9uZyB0aGUgcGFyZW50cyBvZiBjdXJyZW50IHN1aXRlXFxuICAgICAgLy8gc3RvcCBleGVjdXRpb24gb2YgZXJyU3VpdGUgYW5kIGFsbCBzdWItc3VpdGVzXFxuICAgICAgcmV0dXJuIGRvbmUoZXJyU3VpdGUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGN1cnIgPSBzdWl0ZS5zdWl0ZXNbaSsrXTtcXG4gICAgaWYgKCFjdXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICAvLyBBdm9pZCBncmVwIG5lZ2xlY3RpbmcgbGFyZ2UgbnVtYmVyIG9mIHRlc3RzIGNhdXNpbmcgYVxcbiAgICAvLyBodWdlIHJlY3Vyc2l2ZSBsb29wIGFuZCB0aHVzIGEgbWF4aW11bSBjYWxsIHN0YWNrIGVycm9yLlxcbiAgICAvLyBTZWUgY29tbWVudCBpbiBgdGhpcy5ydW5UZXN0cygpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG4gICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZG9uZSAoZXJyU3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcbiAgICBzZWxmLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICAgIGlmIChhZnRlckFsbEhvb2tDYWxsZWQpIHtcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWFyayB0aGF0IHRoZSBhZnRlckFsbCBibG9jayBoYXMgYmVlbiBjYWxsZWQgb25jZVxcbiAgICAgIC8vIGFuZCBzbyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiBpdC5cXG4gICAgICBhZnRlckFsbEhvb2tDYWxsZWQgPSB0cnVlO1xcblxcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGVzdFxcbiAgICAgIGRlbGV0ZSBzZWxmLnRlc3Q7XFxuXFxuICAgICAgc2VsZi5ob29rKCdhZnRlckFsbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYuZW1pdCgnc3VpdGUgZW5kJywgc3VpdGUpO1xcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICB0aGlzLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICB0aGlzLmhvb2soJ2JlZm9yZUFsbCcsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgaWYgKGVycikge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG4gICAgc2VsZi5ydW5UZXN0cyhzdWl0ZSwgbmV4dCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS51bmNhdWdodCA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIGlmIChlcnIpIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IGV4Y2VwdGlvbiAlcycsIGVyciA9PT0gKGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfS5jYWxsKGVycikpID8gKGVyci5tZXNzYWdlIHx8IGVycikgOiBlcnIpO1xcbiAgfSBlbHNlIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IHVuZGVmaW5lZCBleGNlcHRpb24nKTtcXG4gICAgZXJyID0gdW5kZWZpbmVkRXJyb3IoKTtcXG4gIH1cXG4gIGVyci51bmNhdWdodCA9IHRydWU7XFxuXFxuICB2YXIgcnVubmFibGUgPSB0aGlzLmN1cnJlbnRSdW5uYWJsZTtcXG5cXG4gIGlmICghcnVubmFibGUpIHtcXG4gICAgcnVubmFibGUgPSBuZXcgUnVubmFibGUoJ1VuY2F1Z2h0IGVycm9yIG91dHNpZGUgdGVzdCBzdWl0ZScpO1xcbiAgICBydW5uYWJsZS5wYXJlbnQgPSB0aGlzLnN1aXRlO1xcblxcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIENhbid0IHJlY292ZXIgZnJvbSB0aGlzIGZhaWx1cmVcXG4gICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgcnVubmFibGUuY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAvLyBJZ25vcmUgZXJyb3JzIGlmIGNvbXBsZXRlIG9yIHBlbmRpbmdcXG4gIGlmIChydW5uYWJsZS5zdGF0ZSB8fCBydW5uYWJsZS5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuXFxuICAvLyByZWNvdmVyIGZyb20gdGVzdFxcbiAgaWYgKHJ1bm5hYmxlLnR5cGUgPT09ICd0ZXN0Jykge1xcbiAgICB0aGlzLmVtaXQoJ3Rlc3QgZW5kJywgcnVubmFibGUpO1xcbiAgICB0aGlzLmhvb2tVcCgnYWZ0ZXJFYWNoJywgdGhpcy5uZXh0KTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAvLyByZWNvdmVyIGZyb20gaG9va3NcXG4gIGlmIChydW5uYWJsZS50eXBlID09PSAnaG9vaycpIHtcXG4gICAgdmFyIGVyclN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGFmdGVyRWFjaCBibG9ja1xcbiAgICBpZiAocnVubmFibGUuZnVsbFRpdGxlKCkuaW5kZXhPZignYWZ0ZXIgZWFjaCcpID4gLTEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ob29rRXJyKGVyciwgZXJyU3VpdGUsIHRydWUpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBiZWZvcmVFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdiZWZvcmUgZWFjaCcpID4gLTEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgfVxcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXIgb3IgYmVmb3JlIGJsb2Nrc1xcbiAgICByZXR1cm4gdGhpcy5uZXh0U3VpdGUoZXJyU3VpdGUpO1xcbiAgfVxcblxcbiAgLy8gYmFpbFxcbiAgdGhpcy5lbWl0KCdlbmQnKTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFucyB1cCB0aGUgcmVmZXJlbmNlcyB0byBhbGwgdGhlIGRlZmVycmVkIGZ1bmN0aW9uc1xcbiAqIChiZWZvcmUvYWZ0ZXIvYmVmb3JlRWFjaC9hZnRlckVhY2gpIGFuZCB0ZXN0cyBvZiBhIFN1aXRlLlxcbiAqIFRoZXNlIG11c3QgYmUgZGVsZXRlZCBvdGhlcndpc2UgYSBtZW1vcnkgbGVhayBjYW4gaGFwcGVuLFxcbiAqIGFzIHRob3NlIGZ1bmN0aW9ucyBtYXkgcmVmZXJlbmNlIHZhcmlhYmxlcyBmcm9tIGNsb3N1cmVzLFxcbiAqIHRodXMgdGhvc2UgdmFyaWFibGVzIGNhbiBuZXZlciBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhcyBsb25nXFxuICogYXMgdGhlIGRlZmVycmVkIGZ1bmN0aW9ucyBleGlzdC5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICovXFxuZnVuY3Rpb24gY2xlYW5TdWl0ZVJlZmVyZW5jZXMgKHN1aXRlKSB7XFxuICBmdW5jdGlvbiBjbGVhbkFyclJlZmVyZW5jZXMgKGFycikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlbGV0ZSBhcnJbaV0uZm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9iZWZvcmVBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9iZWZvcmVFYWNoKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2JlZm9yZUVhY2gpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2FmdGVyQWxsKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2FmdGVyQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9hZnRlckVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJFYWNoKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGUudGVzdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGVsZXRlIHN1aXRlLnRlc3RzW2ldLmZuO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxcbiAqIG9uIGNvbXBsZXRpb24uXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn0gZm9yIGNoYWluaW5nXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgcm9vdFN1aXRlID0gdGhpcy5zdWl0ZTtcXG5cXG4gIC8vIElmIHRoZXJlIGlzIGFuIGBvbmx5YCBmaWx0ZXJcXG4gIGlmICh0aGlzLmhhc09ubHkpIHtcXG4gICAgZmlsdGVyT25seShyb290U3VpdGUpO1xcbiAgfVxcblxcbiAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fTtcXG5cXG4gIGZ1bmN0aW9uIHVuY2F1Z2h0IChlcnIpIHtcXG4gICAgc2VsZi51bmNhdWdodChlcnIpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RhcnQgKCkge1xcbiAgICBzZWxmLnN0YXJ0ZWQgPSB0cnVlO1xcbiAgICBzZWxmLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgIHNlbGYucnVuU3VpdGUocm9vdFN1aXRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVidWcoJ2ZpbmlzaGVkIHJ1bm5pbmcnKTtcXG4gICAgICBzZWxmLmVtaXQoJ2VuZCcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGRlYnVnKCdzdGFydCcpO1xcblxcbiAgLy8gcmVmZXJlbmNlcyBjbGVhbnVwIHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xcbiAgdGhpcy5vbignc3VpdGUgZW5kJywgY2xlYW5TdWl0ZVJlZmVyZW5jZXMpO1xcblxcbiAgLy8gY2FsbGJhY2tcXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHNlbGYuZm9yYmlkT25seSAmJiBzZWxmLmhhc09ubHkpIHtcXG4gICAgICBzZWxmLmZhaWx1cmVzICs9IHNlbGYuc3RhdHMudGVzdHM7XFxuICAgIH1cXG4gICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgIHNlbGYuZmFpbHVyZXMgKz0gc2VsZi5zdGF0cy5wZW5kaW5nO1xcbiAgICB9XFxuICAgIGRlYnVnKCdlbmQnKTtcXG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuICAgIGZuKHNlbGYuZmFpbHVyZXMpO1xcbiAgfSk7XFxuXFxuICAvLyB1bmNhdWdodCBleGNlcHRpb25cXG4gIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdW5jYXVnaHQpO1xcblxcbiAgaWYgKHRoaXMuX2RlbGF5KSB7XFxuICAgIC8vIGZvciByZXBvcnRlcnMsIEkgZ3Vlc3MuXFxuICAgIC8vIG1pZ2h0IGJlIG5pY2UgdG8gZGVib3VuY2Ugc29tZSBkb3RzIHdoaWxlIHdlIHdhaXQuXFxuICAgIHRoaXMuZW1pdCgnd2FpdGluZycsIHJvb3RTdWl0ZSk7XFxuICAgIHJvb3RTdWl0ZS5vbmNlKCdydW4nLCBzdGFydCk7XFxuICB9IGVsc2Uge1xcbiAgICBzdGFydCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbmx5IGFib3J0IGV4ZWN1dGlvbi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcXG4gIGRlYnVnKCdhYm9ydGluZycpO1xcbiAgdGhpcy5fYWJvcnQgPSB0cnVlO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBGaWx0ZXIgc3VpdGVzIGJhc2VkIG9uIGBpc09ubHlgIGxvZ2ljLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJPbmx5IChzdWl0ZSkge1xcbiAgaWYgKHN1aXRlLl9vbmx5VGVzdHMubGVuZ3RoKSB7XFxuICAgIC8vIElmIHRoZSBzdWl0ZSBjb250YWlucyBgb25seWAgdGVzdHMsIHJ1biB0aG9zZSBhbmQgaWdub3JlIGFueSBuZXN0ZWQgc3VpdGVzLlxcbiAgICBzdWl0ZS50ZXN0cyA9IHN1aXRlLl9vbmx5VGVzdHM7XFxuICAgIHN1aXRlLnN1aXRlcyA9IFtdO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcnVuIGFueSBvZiB0aGUgdGVzdHMgaW4gdGhpcyBzdWl0ZS5cXG4gICAgc3VpdGUudGVzdHMgPSBbXTtcXG4gICAgdXRpbHMuZm9yRWFjaChzdWl0ZS5fb25seVN1aXRlcywgZnVuY3Rpb24gKG9ubHlTdWl0ZSkge1xcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxcbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIG9mIHRoZSB0ZXN0cyBvbiB0aGlzIGBvbmx5YCBzdWl0ZSBzaG91bGQgYmUgcnVuLCBzbyBkb24ndCBmaWx0ZXIgaXQuXFxuICAgICAgaWYgKGhhc09ubHkob25seVN1aXRlKSkge1xcbiAgICAgICAgZmlsdGVyT25seShvbmx5U3VpdGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIC8vIFJ1biB0aGUgYG9ubHlgIHN1aXRlcywgYXMgd2VsbCBhcyBhbnkgb3RoZXIgc3VpdGVzIHRoYXQgaGF2ZSBgb25seWAgdGVzdHMvc3VpdGVzIGFzIGRlc2NlbmRhbnRzLlxcbiAgICBzdWl0ZS5zdWl0ZXMgPSBmaWx0ZXIoc3VpdGUuc3VpdGVzLCBmdW5jdGlvbiAoY2hpbGRTdWl0ZSkge1xcbiAgICAgIHJldHVybiBpbmRleE9mKHN1aXRlLl9vbmx5U3VpdGVzLCBjaGlsZFN1aXRlKSAhPT0gLTEgfHwgZmlsdGVyT25seShjaGlsZFN1aXRlKTtcXG4gICAgfSk7XFxuICB9XFxuICAvLyBLZWVwIHRoZSBzdWl0ZSBvbmx5IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBydW5cXG4gIHJldHVybiBzdWl0ZS50ZXN0cy5sZW5ndGggfHwgc3VpdGUuc3VpdGVzLmxlbmd0aDtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3VpdGUgaGFzIGFuIGBvbmx5YCB0ZXN0IG9yIHN1aXRlIGFzIGEgZGVzY2VuZGFudC5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlXFxuICogQHJldHVybnMge0Jvb2xlYW59XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gaGFzT25seSAoc3VpdGUpIHtcXG4gIHJldHVybiBzdWl0ZS5fb25seVRlc3RzLmxlbmd0aCB8fCBzdWl0ZS5fb25seVN1aXRlcy5sZW5ndGggfHwgc29tZShzdWl0ZS5zdWl0ZXMsIGhhc09ubHkpO1xcbn1cXG5cXG4vKipcXG4gKiBGaWx0ZXIgbGVha3Mgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFscyBmbGFnZ2VkIGFzIGBva2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBva1xcbiAqIEBwYXJhbSB7QXJyYXl9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJMZWFrcyAob2ssIGdsb2JhbHMpIHtcXG4gIHJldHVybiBmaWx0ZXIoZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xcbiAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgZXhwb3NlcyBpZnJhbWVzIGFzIGluZGV4IGluc2lkZSB0aGUgd2luZG93IG9iamVjdFxcbiAgICBpZiAoL15cXFxcZCsvLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBpbiBmaXJlZm94XFxuICAgIC8vIGlmIHJ1bm5lciBydW5zIGluIGFuIGlmcmFtZSwgdGhpcyBpZnJhbWUncyB3aW5kb3cuZ2V0SW50ZXJmYWNlIG1ldGhvZFxcbiAgICAvLyBub3QgaW5pdCBhdCBmaXJzdCBpdCBpcyBhc3NpZ25lZCBpbiBzb21lIHNlY29uZHNcXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgKC9eZ2V0SW50ZXJmYWNlLykudGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIGFuIGlmcmFtZSBjb3VsZCBiZSBhcHByb2FjaGVkIGJ5IHdpbmRvd1tpZnJhbWVJbmRleF1cXG4gICAgLy8gaW4gaWU2LDcsOCBhbmQgb3BlcmEsIGlmcmFtZUluZGV4IGlzIGVudW1lcmFibGUsIHRoaXMgY291bGQgY2F1c2UgbGVha1xcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAoL15cXFxcZCsvKS50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gT3BlcmEgYW5kIElFIGV4cG9zZSBnbG9iYWwgdmFyaWFibGVzIGZvciBIVE1MIGVsZW1lbnQgSURzIChpc3N1ZSAjMjQzKVxcbiAgICBpZiAoL15tb2NoYS0vLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICB2YXIgbWF0Y2hlZCA9IGZpbHRlcihvaywgZnVuY3Rpb24gKG9rKSB7XFxuICAgICAgaWYgKH5vay5pbmRleE9mKCcqJykpIHtcXG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihvay5zcGxpdCgnKicpWzBdKSA9PT0gMDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGtleSA9PT0gb2s7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gIW1hdGNoZWQubGVuZ3RoICYmICghZ2xvYmFsLm5hdmlnYXRvciB8fCBrZXkgIT09ICdvbmVycm9yJyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogQXJyYXkgb2YgZ2xvYmFscyBkZXBlbmRlbnQgb24gdGhlIGVudmlyb25tZW50LlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gZXh0cmFHbG9iYWxzICgpIHtcXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIHBhcnRzID0gcHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJyk7XFxuICAgIHZhciBub2RlVmVyc2lvbiA9IHV0aWxzLnJlZHVjZShwYXJ0cywgZnVuY3Rpb24gKGEsIHYpIHtcXG4gICAgICByZXR1cm4gYSA8PCA4IHwgdjtcXG4gICAgfSk7XFxuXFxuICAgIC8vICdlcnJubycgd2FzIHJlbmFtZWQgdG8gcHJvY2Vzcy5fZXJybm8gaW4gdjAuOS4xMS5cXG5cXG4gICAgaWYgKG5vZGVWZXJzaW9uIDwgMHgwMDA5MEIpIHtcXG4gICAgICByZXR1cm4gWydlcnJubyddO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gW107XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vcGVuZGluZ1xcXCI6MTYsXFxcIi4vcnVubmFibGVcXFwiOjMzLFxcXCIuL3V0aWxzXFxcIjozOCxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJkZWJ1Z1xcXCI6MixcXFwiZXZlbnRzXFxcIjozfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIEhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6c3VpdGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3VpdGVgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN1aXRlO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBgU3VpdGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIHBhcmVudCBgU3VpdGVgLiBXaGVuIGEgc3VpdGVcXG4gKiB3aXRoIHRoZSBzYW1lIHRpdGxlIGlzIGFscmVhZHkgcHJlc2VudCwgdGhhdCBzdWl0ZSBpcyByZXR1cm5lZCB0byBwcm92aWRlXFxuICogbmljZXIgcmVwb3J0ZXIgYW5kIG1vcmUgZmxleGlibGUgbWV0YS10ZXN0aW5nLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBwYXJlbnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRpdGxlKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGl0bGUsIHBhcmVudC5jdHgpO1xcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xcbiAgdGl0bGUgPSBzdWl0ZS5mdWxsVGl0bGUoKTtcXG4gIHBhcmVudC5hZGRTdWl0ZShzdWl0ZSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgYGN0eGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0NvbnRleHR9IHBhcmVudENvbnRleHRcXG4gKi9cXG5mdW5jdGlvbiBTdWl0ZSAodGl0bGUsIHBhcmVudENvbnRleHQpIHtcXG4gIGlmICghdXRpbHMuaXNTdHJpbmcodGl0bGUpKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignU3VpdGUgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgKyB0eXBlb2YgdGl0bGUgKyAnXFxcIiB3YXMgZ2l2ZW4gaW5zdGVhZC4nKTtcXG4gIH1cXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIGZ1bmN0aW9uIENvbnRleHQgKCkge31cXG4gIENvbnRleHQucHJvdG90eXBlID0gcGFyZW50Q29udGV4dDtcXG4gIHRoaXMuY3R4ID0gbmV3IENvbnRleHQoKTtcXG4gIHRoaXMuc3VpdGVzID0gW107XFxuICB0aGlzLnRlc3RzID0gW107XFxuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG4gIHRoaXMuX2JlZm9yZUVhY2ggPSBbXTtcXG4gIHRoaXMuX2JlZm9yZUFsbCA9IFtdO1xcbiAgdGhpcy5fYWZ0ZXJFYWNoID0gW107XFxuICB0aGlzLl9hZnRlckFsbCA9IFtdO1xcbiAgdGhpcy5yb290ID0gIXRpdGxlO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9iYWlsID0gZmFsc2U7XFxuICB0aGlzLl9yZXRyaWVzID0gLTE7XFxuICB0aGlzLl9vbmx5VGVzdHMgPSBbXTtcXG4gIHRoaXMuX29ubHlTdWl0ZXMgPSBbXTtcXG4gIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFN1aXRlLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgYFN1aXRlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aGlzLnRpdGxlKTtcXG4gIGRlYnVnKCdjbG9uZScpO1xcbiAgc3VpdGUuY3R4ID0gdGhpcy5jdHg7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGltZW91dCBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIGlmIChtcy50b1N0cmluZygpID09PSAnMCcpIHtcXG4gICAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBmYWxzZTtcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fdGltZW91dCA9IHBhcnNlSW50KG1zLCAxMCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgYSBmYWlsZWQgdGVzdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gblxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgZGVidWcoJ3JldHJpZXMgJWQnLCBuKTtcXG4gIHRoaXMuX3JldHJpZXMgPSBwYXJzZUludChuLCAxMCkgfHwgMDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICAqIFNldCB0aW1lb3V0IHRvIGBlbmFibGVkYC5cXG4gICpcXG4gICogQGFwaSBwcml2YXRlXFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAgKiBAcmV0dXJuIHtTdWl0ZXxib29sZWFufSBzZWxmIG9yIGVuYWJsZWRcXG4gICovXFxuU3VpdGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHNsb3cgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXFxcIjJzXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0cyB3aGV0aGVyIHRvIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyb3IuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJhaWxcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYmFpbDtcXG4gIH1cXG4gIGRlYnVnKCdiYWlsICVzJywgYmFpbCk7XFxuICB0aGlzLl9iYWlsID0gYmFpbDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBzdWl0ZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJiZWZvcmUgYWxsXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLl9iZWZvcmVBbGwucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYmVmb3JlQWxsJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYWZ0ZXIgYWxsXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckFsbCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJiZWZvcmUgZWFjaFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XFxuICBob29rLnBhcmVudCA9IHRoaXM7XFxuICBob29rLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIGhvb2suZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIGhvb2suc2xvdyh0aGlzLnNsb3coKSk7XFxuICBob29rLmN0eCA9IHRoaXMuY3R4O1xcbiAgdGhpcy5fYmVmb3JlRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJhZnRlciBlYWNoXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLl9hZnRlckVhY2gucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYWZ0ZXJFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIHRlc3QgYHN1aXRlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRTdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgc3VpdGUucGFyZW50ID0gdGhpcztcXG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBzdWl0ZS5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XFxuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcXG4gIHRoaXMuc3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgdGhpcy5lbWl0KCdzdWl0ZScsIHN1aXRlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgYHRlc3RgIHRvIHRoaXMgc3VpdGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcXG4gIHRoaXMuZW1pdCgndGVzdCcsIHRlc3QpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5wYXJlbnQpIHtcXG4gICAgdmFyIGZ1bGwgPSB0aGlzLnBhcmVudC5mdWxsVGl0bGUoKTtcXG4gICAgaWYgKGZ1bGwpIHtcXG4gICAgICByZXR1cm4gZnVsbCArICcgJyArIHRoaXMudGl0bGU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzLnRpdGxlO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudG90YWwgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdXRpbHMucmVkdWNlKHRoaXMuc3VpdGVzLCBmdW5jdGlvbiAoc3VtLCBzdWl0ZSkge1xcbiAgICByZXR1cm4gc3VtICsgc3VpdGUudG90YWwoKTtcXG4gIH0sIDApICsgdGhpcy50ZXN0cy5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxcbiAqIGZ1bmN0aW9uIGluIHRoZSBmb3JtYXQgYGZuKHRlc3QpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmVhY2hUZXN0ID0gZnVuY3Rpb24gKGZuKSB7XFxuICB1dGlscy5mb3JFYWNoKHRoaXMudGVzdHMsIGZuKTtcXG4gIHV0aWxzLmZvckVhY2godGhpcy5zdWl0ZXMsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBzdWl0ZS5lYWNoVGVzdChmbik7XFxuICB9KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVGhpcyB3aWxsIHJ1biB0aGUgcm9vdCBzdWl0ZSBpZiB3ZSBoYXBwZW4gdG8gYmUgcnVubmluZyBpbiBkZWxheWVkIG1vZGUuXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XFxuICBpZiAodGhpcy5yb290KSB7XFxuICAgIHRoaXMuZW1pdCgncnVuJyk7XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi9ob29rXFxcIjo3LFxcXCIuL21zXFxcIjoxNSxcXFwiLi91dGlsc1xcXCI6MzgsXFxcImRlYnVnXFxcIjoyLFxcXCJldmVudHNcXFwiOjN9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2guY3JlYXRlJyk7XFxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi91dGlscycpLmlzU3RyaW5nO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVGVzdGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFRlc3QgKHRpdGxlLCBmbikge1xcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IGB0aXRsZWAgc2hvdWxkIGJlIGEgXFxcInN0cmluZ1xcXCIgYnV0IFxcXCInICsgdHlwZW9mIHRpdGxlICsgJ1xcXCIgd2FzIGdpdmVuIGluc3RlYWQuJyk7XFxuICB9XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnBlbmRpbmcgPSAhZm47XFxuICB0aGlzLnR5cGUgPSAndGVzdCc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5UZXN0LnByb3RvdHlwZSA9IGNyZWF0ZShSdW5uYWJsZS5wcm90b3R5cGUsIHtcXG4gIGNvbnN0cnVjdG9yOiBUZXN0XFxufSk7XFxuXFxuVGVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRoaXMudGl0bGUsIHRoaXMuZm4pO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgdGVzdC5jdXJyZW50UmV0cnkodGhpcy5jdXJyZW50UmV0cnkoKSk7XFxuICB0ZXN0Lmdsb2JhbHModGhpcy5nbG9iYWxzKCkpO1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcXG4gIHRlc3QuZmlsZSA9IHRoaXMuZmlsZTtcXG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XFxuICByZXR1cm4gdGVzdDtcXG59O1xcblxcbn0se1xcXCIuL3J1bm5hYmxlXFxcIjozMyxcXFwiLi91dGlsc1xcXCI6MzgsXFxcImxvZGFzaC5jcmVhdGVcXFwiOjc1fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBQYWQgYSBgbnVtYmVyYCB3aXRoIGEgdGVuJ3MgcGxhY2UgemVyby5cXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkKG51bWJlcikge1xcbiAgdmFyIG4gPSBudW1iZXIudG9TdHJpbmcoKTtcXG4gIHJldHVybiBuLmxlbmd0aCA9PT0gMSA/ICcwJyArIG4gOiBuO1xcbn1cXG5cXG4vKipcXG4gKiBUdXJuIGEgYGRhdGVgIGludG8gYW4gSVNPIHN0cmluZy5cXG4gKlxcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0b0lTT1N0cmluZyhkYXRlKSB7XFxuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpXFxuICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpXFxuICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpKVxcbiAgICArICdUJyArIHBhZChkYXRlLmdldFVUQ0hvdXJzKCkpXFxuICAgICsgJzonICsgcGFkKGRhdGUuZ2V0VVRDTWludXRlcygpKVxcbiAgICArICc6JyArIHBhZChkYXRlLmdldFVUQ1NlY29uZHMoKSlcXG4gICAgKyAnLicgKyBTdHJpbmcoKGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkvMTAwMCkudG9GaXhlZCgzKSkuc2xpY2UoMiwgNSlcXG4gICAgKyAnWic7XFxufVxcblxcbi8qXFxuICogRXhwb3J0cy5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHRvSVNPU3RyaW5nO1xcblxcbn0se31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyogZXNsaW50LWVudiBicm93c2VyICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgSlNPTiA9IHJlcXVpcmUoJ2pzb24zJyk7XFxudmFyIGJhc2VuYW1lID0gcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOndhdGNoJyk7XFxudmFyIGV4aXN0cyA9IHJlcXVpcmUoJ2ZzJykuZXhpc3RzU3luYyB8fCByZXF1aXJlKCdwYXRoJykuZXhpc3RzU3luYztcXG52YXIgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgam9pbiA9IHBhdGguam9pbjtcXG52YXIgcmVhZGRpclN5bmMgPSByZXF1aXJlKCdmcycpLnJlYWRkaXJTeW5jO1xcbnZhciBzdGF0U3luYyA9IHJlcXVpcmUoJ2ZzJykuc3RhdFN5bmM7XFxudmFyIHdhdGNoRmlsZSA9IHJlcXVpcmUoJ2ZzJykud2F0Y2hGaWxlO1xcbnZhciBsc3RhdFN5bmMgPSByZXF1aXJlKCdmcycpLmxzdGF0U3luYztcXG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL3RvLWlzby1zdHJpbmcnKTtcXG52YXIgaGUgPSByZXF1aXJlKCdoZScpO1xcblxcbi8qKlxcbiAqIElnbm9yZWQgZGlyZWN0b3JpZXMuXFxuICovXFxuXFxudmFyIGlnbm9yZSA9IFsnbm9kZV9tb2R1bGVzJywgJy5naXQnXTtcXG5cXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtICB7c3RyaW5nfSBodG1sXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24gKGh0bWwpIHtcXG4gIHJldHVybiBoZS5lbmNvZGUoU3RyaW5nKGh0bWwpLCB7IHVzZU5hbWVkUmVmZXJlbmNlczogZmFsc2UgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNmb3JFYWNoICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXFxuICovXFxuZXhwb3J0cy5mb3JFYWNoID0gZnVuY3Rpb24gKGFyciwgZm4sIHNjb3BlKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFRlc3QgaWYgdGhlIGdpdmVuIG9iaiBpcyB0eXBlIG9mIHN0cmluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNtYXAgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChhcnIsIGZuLCBzY29wZSkge1xcbiAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIHJlc3VsdC5wdXNoKGZuLmNhbGwoc2NvcGUsIGFycltpXSwgaSwgYXJyKSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjaW5kZXhPZiAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRvIGZpbmQgaW5kZXggb2ZcXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxudmFyIGluZGV4T2YgPSBleHBvcnRzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyLCBvYmosIHN0YXJ0KSB7XFxuICBmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSB7XFxuICAgICAgcmV0dXJuIGk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiAtMTtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I3JlZHVjZSAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgSW5pdGlhbCB2YWx1ZS5cXG4gKiBAcmV0dXJuIHsqfVxcbiAqL1xcbnZhciByZWR1Y2UgPSBleHBvcnRzLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGZuLCB2YWwpIHtcXG4gIHZhciBydmFsID0gdmFsO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIHJ2YWwgPSBmbihydmFsLCBhcnJbaV0sIGksIGFycik7XFxuICB9XFxuXFxuICByZXR1cm4gcnZhbDtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I2ZpbHRlciAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24gKGFyciwgZm4pIHtcXG4gIHZhciByZXQgPSBbXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xcbiAgICBpZiAoZm4odmFsLCBpLCBhcnIpKSB7XFxuICAgICAgcmV0LnB1c2godmFsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I3NvbWUgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5leHBvcnRzLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBmbikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGlmIChmbihhcnJbaV0pKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmYWxzZTtcXG59O1xcblxcbi8qKlxcbiAqIE9iamVjdC5rZXlzICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xcbiAqL1xcbmV4cG9ydHMua2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5rZXlzIDogZnVuY3Rpb24gKG9iaikge1xcbiAgdmFyIGtleXMgPSBbXTtcXG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OyAvLyBmb3IgYHdpbmRvd2Agb24gPD1JRThcXG5cXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xcbiAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ga2V5cztcXG59O1xcblxcbi8qKlxcbiAqIFdhdGNoIHRoZSBnaXZlbiBgZmlsZXNgIGZvciBjaGFuZ2VzXFxuICogYW5kIGludm9rZSBgZm4oZmlsZSlgIG9uIG1vZGlmaWNhdGlvbi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5leHBvcnRzLndhdGNoID0gZnVuY3Rpb24gKGZpbGVzLCBmbikge1xcbiAgdmFyIG9wdGlvbnMgPSB7IGludGVydmFsOiAxMDAgfTtcXG4gIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgZGVidWcoJ2ZpbGUgJXMnLCBmaWxlKTtcXG4gICAgd2F0Y2hGaWxlKGZpbGUsIG9wdGlvbnMsIGZ1bmN0aW9uIChjdXJyLCBwcmV2KSB7XFxuICAgICAgaWYgKHByZXYubXRpbWUgPCBjdXJyLm10aW1lKSB7XFxuICAgICAgICBmbihmaWxlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheS5pc0FycmF5ICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtCb29sZWFufVxcbiAqL1xcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gKG9iaikge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xcbn07XFxuXFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG4vKipcXG4gKiBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiBwb2x5ZmlsbC5cXG4gKlxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cXG4gKi9cXG5pZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLnByb3RvdHlwZSkge1xcbiAgQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiB8fCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCAwKTtcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIElnbm9yZWQgZmlsZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gaWdub3JlZCAocGF0aCkge1xcbiAgcmV0dXJuICF+aWdub3JlLmluZGV4T2YocGF0aCk7XFxufVxcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlcyBpbiB0aGUgZ2l2ZW4gYGRpcmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2V4dD1bJy5qcyddXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXQ9W11dXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWxlcyA9IGZ1bmN0aW9uIChkaXIsIGV4dCwgcmV0KSB7XFxuICByZXQgPSByZXQgfHwgW107XFxuICBleHQgPSBleHQgfHwgWydqcyddO1xcblxcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKCcgKyBleHQuam9pbignfCcpICsgJykkJyk7XFxuXFxuICByZWFkZGlyU3luYyhkaXIpXFxuICAgIC5maWx0ZXIoaWdub3JlZClcXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcXG4gICAgICBwYXRoID0gam9pbihkaXIsIHBhdGgpO1xcbiAgICAgIGlmIChsc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgZXhwb3J0cy5maWxlcyhwYXRoLCBleHQsIHJldCk7XFxuICAgICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKHJlKSkge1xcbiAgICAgICAgcmV0LnB1c2gocGF0aCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG4vKipcXG4gKiBDb21wdXRlIGEgc2x1ZyBmcm9tIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zbHVnID0gZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHN0clxcbiAgICAudG9Mb3dlckNhc2UoKVxcbiAgICAucmVwbGFjZSgvICsvZywgJy0nKVxcbiAgICAucmVwbGFjZSgvW14tXFxcXHddL2csICcnKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmlwIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIGZyb20gYHN0cmAsIGFuZCByZS1pbmRlbnQgZm9yIHByZSB3aGl0ZXNwYWNlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmNsZWFuID0gZnVuY3Rpb24gKHN0cikge1xcbiAgc3RyID0gc3RyXFxuICAgIC5yZXBsYWNlKC9cXFxcclxcXFxuP3xbXFxcXG5cXFxcdTIwMjhcXFxcdTIwMjldL2csICdcXFxcbicpLnJlcGxhY2UoL15cXFxcdUZFRkYvLCAnJylcXG4gICAgLy8gKHRyYWRpdGlvbmFsKS0+ICBzcGFjZS9uYW1lICAgICBwYXJhbWV0ZXJzICAgIGJvZHkgICAgIChsYW1iZGEpLT4gcGFyYW1ldGVycyAgICAgICBib2R5ICAgbXVsdGktc3RhdGVtZW50L3NpbmdsZSAgICAgICAgICBrZWVwIGJvZHkgY29udGVudFxcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uKD86XFxcXHMqfFxcXFxzK1teKF0qKVxcXFwoW14pXSpcXFxcKVxcXFxzKlxcXFx7KCg/Oi58XFxcXG4pKj8pXFxcXHMqXFxcXH0kfF5cXFxcKFteKV0qXFxcXClcXFxccyo9PlxcXFxzKig/OlxcXFx7KCg/Oi58XFxcXG4pKj8pXFxcXHMqXFxcXH18KCg/Oi58XFxcXG4pKikpJC8sICckMSQyJDMnKTtcXG5cXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXFxcbj8oICopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXFxcbj8oXFxcXHQqKS8pWzFdLmxlbmd0aDtcXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ15cXFxcbj8nICsgKHRhYnMgPyAnXFxcXHQnIDogJyAnKSArICd7JyArICh0YWJzIHx8IHNwYWNlcykgKyAnfScsICdnbScpO1xcblxcbiAgc3RyID0gc3RyLnJlcGxhY2UocmUsICcnKTtcXG5cXG4gIHJldHVybiBleHBvcnRzLnRyaW0oc3RyKTtcXG59O1xcblxcbi8qKlxcbiAqIFRyaW0gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnRyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJyk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHFzYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxc1xcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5leHBvcnRzLnBhcnNlUXVlcnkgPSBmdW5jdGlvbiAocXMpIHtcXG4gIHJldHVybiByZWR1Y2UocXMucmVwbGFjZSgnPycsICcnKS5zcGxpdCgnJicpLCBmdW5jdGlvbiAob2JqLCBwYWlyKSB7XFxuICAgIHZhciBpID0gcGFpci5pbmRleE9mKCc9Jyk7XFxuICAgIHZhciBrZXkgPSBwYWlyLnNsaWNlKDAsIGkpO1xcbiAgICB2YXIgdmFsID0gcGFpci5zbGljZSgrK2kpO1xcblxcbiAgICAvLyBEdWUgdG8gaG93IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJIHRyZWF0cyBzcGFjZXNcXG4gICAgb2JqW2tleV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsLnJlcGxhY2UoL1xcXFwrL2csICclMjAnKSk7XFxuXFxuICAgIHJldHVybiBvYmo7XFxuICB9LCB7fSk7XFxufTtcXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGdpdmVuIHN0cmluZyBvZiBganNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IGpzXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGhpZ2hsaWdodCAoanMpIHtcXG4gIHJldHVybiBqc1xcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXFxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcXG4gICAgLnJlcGxhY2UoL1xcXFwvXFxcXC8oLiopL2dtLCAnPHNwYW4gY2xhc3M9XFxcImNvbW1lbnRcXFwiPi8vJDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLygnLio/JykvZ20sICc8c3BhbiBjbGFzcz1cXFwic3RyaW5nXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKFxcXFxkK1xcXFwuXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcYm5ld1sgXFxcXHRdKyhcXFxcdyspL2dtLCAnPHNwYW4gY2xhc3M9XFxcImtleXdvcmRcXFwiPm5ldzwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImluaXRcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcYihmdW5jdGlvbnxuZXd8dGhyb3d8cmV0dXJufHZhcnxpZnxlbHNlKVxcXFxiL2dtLCAnPHNwYW4gY2xhc3M9XFxcImtleXdvcmRcXFwiPiQxPC9zcGFuPicpO1xcbn1cXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGNvbnRlbnRzIG9mIHRhZyBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqL1xcbmV4cG9ydHMuaGlnaGxpZ2h0VGFncyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICB2YXIgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgY29kZVtpXS5pbm5lckhUTUwgPSBoaWdobGlnaHQoY29kZVtpXS5pbm5lckhUTUwpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSWYgYSB2YWx1ZSBjb3VsZCBoYXZlIHByb3BlcnRpZXMsIGFuZCBoYXMgbm9uZSwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsXFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXFxuICpcXG4gKiBGdW5jdGlvbnMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCdbRnVuY3Rpb25dJ2BcXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcXG4gKiBPYmplY3RzIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAne30nYFxcbiAqIEFsbCBlbHNlOiByZXR1cm4gcmVzdWx0IG9mIGB2YWx1ZS50b1N0cmluZygpYFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZUhpbnQgVGhlIHR5cGUgb2YgdGhlIHZhbHVlXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBlbXB0eVJlcHJlc2VudGF0aW9uICh2YWx1ZSwgdHlwZUhpbnQpIHtcXG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxcbiAgICAgIHJldHVybiAnW0Z1bmN0aW9uXSc7XFxuICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgcmV0dXJuICd7fSc7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICByZXR1cm4gJ1tdJztcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVGFrZXMgc29tZSB2YXJpYWJsZSBhbmQgYXNrcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpYCB3aGF0IGl0IHRoaW5rcyBpdFxcbiAqIGlzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbXB1dGVkIHR5cGVcXG4gKiBAZXhhbXBsZVxcbiAqIHR5cGUoe30pIC8vICdvYmplY3QnXFxuICogdHlwZShbXSkgLy8gJ2FycmF5J1xcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcXG4gKiB0eXBlKGZhbHNlKSAvLyAnYm9vbGVhbidcXG4gKiB0eXBlKEluZmluaXR5KSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXFxuICogdHlwZShuZXcgRGF0ZSgpKSAvLyAnZGF0ZSdcXG4gKiB0eXBlKC9mb28vKSAvLyAncmVnZXhwJ1xcbiAqIHR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xcbiAqIHR5cGUoZ2xvYmFsKSAvLyAnZ2xvYmFsJ1xcbiAqIHR5cGUobmV3IFN0cmluZygnZm9vJykgLy8gJ29iamVjdCdcXG4gKi9cXG52YXIgdHlwZSA9IGV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIHR5cGUgKHZhbHVlKSB7XFxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XFxuICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgIHJldHVybiAnbnVsbCc7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcXG4gICAgcmV0dXJuICdidWZmZXInO1xcbiAgfVxcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcXG4gICAgLnJlcGxhY2UoL15cXFxcWy4rXFxcXHMoLis/KV0kLywgJyQxJylcXG4gICAgLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG4vKipcXG4gKiBTdHJpbmdpZnkgYHZhbHVlYC4gRGlmZmVyZW50IGJlaGF2aW9yIGRlcGVuZGluZyBvbiB0eXBlIG9mIHZhbHVlOlxcbiAqXFxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgIHdyYXBwZWQgaW4gZG91YmxlLXF1b3Rlcy5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgYW4gKmVtcHR5KiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBmdW5jdGlvblxcbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxcbiAqIC0gSWYgYHZhbHVlYCBoYXMgcHJvcGVydGllcywgY2FsbCB7QGxpbmsgZXhwb3J0cy5jYW5vbmljYWxpemV9IG9uIGl0LCB0aGVuIHJldHVybiByZXN1bHQgb2ZcXG4gKiAgIEpTT04uc3RyaW5naWZ5KCkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHZhciB0eXBlSGludCA9IHR5cGUodmFsdWUpO1xcblxcbiAgaWYgKCF+aW5kZXhPZihbJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbiddLCB0eXBlSGludCkpIHtcXG4gICAgaWYgKHR5cGVIaW50ID09PSAnYnVmZmVyJykge1xcbiAgICAgIHZhciBqc29uID0gdmFsdWUudG9KU09OKCk7XFxuICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcXG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbiwgMilcXG4gICAgICAgIC5yZXBsYWNlKC8sKFxcXFxufCQpL2csICckMScpO1xcbiAgICB9XFxuXFxuICAgIC8vIElFNy9JRTggaGFzIGEgYml6YXJyZSBTdHJpbmcgY29uc3RydWN0b3I7IG5lZWRzIHRvIGJlIGNvZXJjZWRcXG4gICAgLy8gaW50byBhbiBhcnJheSBhbmQgYmFjayB0byBvYmouXFxuICAgIGlmICh0eXBlSGludCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xcbiAgICAgIHZhbHVlID0gcmVkdWNlKHZhbHVlLnNwbGl0KCcnKSwgZnVuY3Rpb24gKGFjYywgY2hhciwgaWR4KSB7XFxuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XFxuICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgIH0sIHt9KTtcXG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wKSkge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCB0eXBlSGludCksIDIpLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XFxufTtcXG5cXG4vKipcXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9ICBvYmplY3RcXG4gKiBAcGFyYW0ge251bWJlcj19IHNwYWNlc1xcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcXG4gKiBAcmV0dXJucyB7Kn1cXG4gKi9cXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5IChvYmplY3QsIHNwYWNlcywgZGVwdGgpIHtcXG4gIGlmICh0eXBlb2Ygc3BhY2VzID09PSAndW5kZWZpbmVkJykge1xcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcXG4gICAgcmV0dXJuIF9zdHJpbmdpZnkob2JqZWN0KTtcXG4gIH1cXG5cXG4gIGRlcHRoID0gZGVwdGggfHwgMTtcXG4gIHZhciBzcGFjZSA9IHNwYWNlcyAqIGRlcHRoO1xcbiAgdmFyIHN0ciA9IGlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcXG4gIHZhciBlbmQgPSBpc0FycmF5KG9iamVjdCkgPyAnXScgOiAnfSc7XFxuICB2YXIgbGVuZ3RoID0gdHlwZW9mIG9iamVjdC5sZW5ndGggPT09ICdudW1iZXInID8gb2JqZWN0Lmxlbmd0aCA6IGV4cG9ydHMua2V5cyhvYmplY3QpLmxlbmd0aDtcXG4gIC8vIGAucmVwZWF0KClgIHBvbHlmaWxsXFxuICBmdW5jdGlvbiByZXBlYXQgKHMsIG4pIHtcXG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSAodmFsKSB7XFxuICAgIHN3aXRjaCAodHlwZSh2YWwpKSB7XFxuICAgICAgY2FzZSAnbnVsbCc6XFxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgICAgIHZhbCA9ICdbJyArIHZhbCArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgICAgY2FzZSAnc3ltYm9sJzpcXG4gICAgICBjYXNlICdudW1iZXInOlxcbiAgICAgICAgdmFsID0gdmFsID09PSAwICYmICgxIC8gdmFsKSA9PT0gLUluZmluaXR5IC8vIGAtMGBcXG4gICAgICAgICAgPyAnLTAnXFxuICAgICAgICAgIDogdmFsLnRvU3RyaW5nKCk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdkYXRlJzpcXG4gICAgICAgIHZhciBzRGF0ZTtcXG4gICAgICAgIGlmIChpc05hTih2YWwuZ2V0VGltZSgpKSkgeyAvLyBJbnZhbGlkIGRhdGVcXG4gICAgICAgICAgc0RhdGUgPSB2YWwudG9TdHJpbmcoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNEYXRlID0gdmFsLnRvSVNPU3RyaW5nID8gdmFsLnRvSVNPU3RyaW5nKCkgOiB0b0lTT1N0cmluZyh2YWwpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFsID0gJ1tEYXRlOiAnICsgc0RhdGUgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdidWZmZXInOlxcbiAgICAgICAgdmFyIGpzb24gPSB2YWwudG9KU09OKCk7XFxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xcbiAgICAgICAgdmFsID0gJ1tCdWZmZXI6ICcgKyBqc29uU3RyaW5naWZ5KGpzb24sIDIsIGRlcHRoICsgMSkgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgdmFsID0gKHZhbCA9PT0gJ1tGdW5jdGlvbl0nIHx8IHZhbCA9PT0gJ1tDaXJjdWxhcl0nKVxcbiAgICAgICAgICA/IHZhbFxcbiAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbCk7IC8vIHN0cmluZ1xcbiAgICB9XFxuICAgIHJldHVybiB2YWw7XFxuICB9XFxuXFxuICBmb3IgKHZhciBpIGluIG9iamVjdCkge1xcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGkpKSB7XFxuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xcbiAgICB9XFxuICAgIC0tbGVuZ3RoO1xcbiAgICBzdHIgKz0gJ1xcXFxuICcgKyByZXBlYXQoJyAnLCBzcGFjZSkgK1xcbiAgICAgIChpc0FycmF5KG9iamVjdCkgPyAnJyA6ICdcXFwiJyArIGkgKyAnXFxcIjogJykgKyAvLyBrZXlcXG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVcXG4gICAgICAobGVuZ3RoID8gJywnIDogJycpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFcXG4gIH1cXG5cXG4gIHJldHVybiBzdHIgK1xcbiAgICAvLyBbXSwge31cXG4gICAgKHN0ci5sZW5ndGggIT09IDEgPyAnXFxcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpO1xcbn1cXG5cXG4vKipcXG4gKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBidWZmZXIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZXhwb3J0cy5pc0J1ZmZlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgcmV0dXJuIHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgVGhpbmcgdGhhdCBoYXMgdGhlIGtleXMgaW4gc29ydGVkIG9yZGVyLiBSZWN1cnNpdmUuXFxuICpcXG4gKiBJZiB0aGUgVGhpbmcuLi5cXG4gKiAtIGhhcyBhbHJlYWR5IGJlZW4gc2VlbiwgcmV0dXJuIHN0cmluZyBgJ1tDaXJjdWxhcl0nYFxcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXFxuICogLSBpcyBgbnVsbGAsIHJldHVybiB2YWx1ZSBgbnVsbGBcXG4gKiAtIGlzIHNvbWUgb3RoZXIgcHJpbWl0aXZlLCByZXR1cm4gdGhlIHZhbHVlXFxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxcbiAqIC0gaXMgYSBub24tZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cXG4gKiAtIGlzIGFuIGVtcHR5IGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBlbXB0eVJlcHJlc2VudGF0aW9uKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoaW5nIHRvIGluc3BlY3QuICBNYXkgb3IgbWF5IG5vdCBoYXZlIHByb3BlcnRpZXMuXFxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrPVtdXSBTdGFjayBvZiBzZWVuIHZhbHVlc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxcbiAqIEByZXR1cm4geyhPYmplY3R8QXJyYXl8RnVuY3Rpb258c3RyaW5nfHVuZGVmaW5lZCl9XFxuICovXFxuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUgKHZhbHVlLCBzdGFjaywgdHlwZUhpbnQpIHtcXG4gIHZhciBjYW5vbmljYWxpemVkT2JqO1xcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG4gIHZhciBwcm9wO1xcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdHlwZUhpbnQgPSB0eXBlSGludCB8fCB0eXBlKHZhbHVlKTtcXG4gIGZ1bmN0aW9uIHdpdGhTdGFjayAodmFsdWUsIGZuKSB7XFxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xcbiAgICBmbigpO1xcbiAgICBzdGFjay5wb3AoKTtcXG4gIH1cXG5cXG4gIHN0YWNrID0gc3RhY2sgfHwgW107XFxuXFxuICBpZiAoaW5kZXhPZihzdGFjaywgdmFsdWUpICE9PSAtMSkge1xcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgfVxcblxcbiAgc3dpdGNoICh0eXBlSGludCkge1xcbiAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICBjYXNlICdidWZmZXInOlxcbiAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBleHBvcnRzLm1hcCh2YWx1ZSwgZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2Fub25pY2FsaXplKGl0ZW0sIHN0YWNrKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdmdW5jdGlvbic6XFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXFxuICAgICAgZm9yIChwcm9wIGluIHZhbHVlKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0ge307XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBndWFyZC1mb3ItaW4gKi9cXG4gICAgICBpZiAoIWNhbm9uaWNhbGl6ZWRPYmopIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gY2Fub25pY2FsaXplZE9iaiB8fCB7fTtcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGV4cG9ydHMuZm9yRWFjaChleHBvcnRzLmtleXModmFsdWUpLnNvcnQoKSwgZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICBjYW5vbmljYWxpemVkT2JqW2tleV0gPSBleHBvcnRzLmNhbm9uaWNhbGl6ZSh2YWx1ZVtrZXldLCBzdGFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnZGF0ZSc6XFxuICAgIGNhc2UgJ251bWJlcic6XFxuICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICBjYXNlICdzeW1ib2wnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUgKyAnJztcXG4gIH1cXG5cXG4gIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xcbn07XFxuXFxuLyoqXFxuICogTG9va3VwIGZpbGUgbmFtZXMgYXQgdGhlIGdpdmVuIGBwYXRoYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggQmFzZSBwYXRoIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4dGVuc2lvbnMgRmlsZSBleHRlbnNpb25zIHRvIGxvb2sgZm9yLlxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFdoZXRoZXIgb3Igbm90IHRvIHJlY3Vyc2UgaW50byBzdWJkaXJlY3Rvcmllcy5cXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcGF0aHMuXFxuICovXFxuZXhwb3J0cy5sb29rdXBGaWxlcyA9IGZ1bmN0aW9uIGxvb2t1cEZpbGVzIChwYXRoLCBleHRlbnNpb25zLCByZWN1cnNpdmUpIHtcXG4gIHZhciBmaWxlcyA9IFtdO1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKCcgKyBleHRlbnNpb25zLmpvaW4oJ3wnKSArICcpJCcpO1xcblxcbiAgaWYgKCFleGlzdHMocGF0aCkpIHtcXG4gICAgaWYgKGV4aXN0cyhwYXRoICsgJy5qcycpKSB7XFxuICAgICAgcGF0aCArPSAnLmpzJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmaWxlcyA9IGdsb2Iuc3luYyhwYXRoKTtcXG4gICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJjYW5ub3QgcmVzb2x2ZSBwYXRoIChvciBwYXR0ZXJuKSAnXFxcIiArIHBhdGggKyBcXFwiJ1xcXCIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmlsZXM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIHZhciBzdGF0ID0gc3RhdFN5bmMocGF0aCk7XFxuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XFxuICAgICAgcmV0dXJuIHBhdGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgcmVhZGRpclN5bmMocGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICBmaWxlID0gam9pbihwYXRoLCBmaWxlKTtcXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgc3RhdCA9IHN0YXRTeW5jKGZpbGUpO1xcbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcXG4gICAgICAgICAgZmlsZXMgPSBmaWxlcy5jb25jYXQobG9va3VwRmlsZXMoZmlsZSwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKCFzdGF0LmlzRmlsZSgpIHx8ICFyZS50ZXN0KGZpbGUpIHx8IGJhc2VuYW1lKGZpbGUpWzBdID09PSAnLicpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZmlsZXMucHVzaChmaWxlKTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGZpbGVzO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIHdpdGggYSBtZXNzYWdlIHdhcm5pbmcgdGhlIHVzZXIuXFxuICpcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLnVuZGVmaW5lZEVycm9yID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIG5ldyBFcnJvcignQ2F1Z2h0IHVuZGVmaW5lZCBlcnJvciwgZGlkIHlvdSB0aHJvdyB3aXRob3V0IHNwZWNpZnlpbmcgd2hhdD8nKTtcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFuIHVuZGVmaW5lZCBlcnJvciBpZiBgZXJyYCBpcyBub3QgZGVmaW5lZC5cXG4gKlxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICByZXR1cm4gZXJyIHx8IGV4cG9ydHMudW5kZWZpbmVkRXJyb3IoKTtcXG59O1xcblxcbi8qKlxcbiAqIEBzdW1tYXJ5XFxuICogVGhpcyBGaWx0ZXIgYmFzZWQgb24gYG1vY2hhLWNsZWFuYCBtb2R1bGUuKHNlZTogYGdpdGh1Yi5jb20vcnN0YWNydXovbW9jaGEtY2xlYW5gKVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFdoZW4gaW52b2tpbmcgdGhpcyBmdW5jdGlvbiB5b3UgZ2V0IGEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgZ2V0IHRoZSBFcnJvci5zdGFjayBhcyBhbiBpbnB1dCxcXG4gKiBhbmQgcmV0dXJuIGEgcHJldHRpZnkgb3V0cHV0LlxcbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XFxuICovXFxuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGBwcm9jZXNzLmJyb3dzZXJgXFxuICB2YXIgaXMgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8geyBub2RlOiB0cnVlIH0gOiB7IGJyb3dzZXI6IHRydWUgfTtcXG4gIHZhciBzbGFzaCA9IHBhdGguc2VwO1xcbiAgdmFyIGN3ZDtcXG4gIGlmIChpcy5ub2RlKSB7XFxuICAgIGN3ZCA9IHByb2Nlc3MuY3dkKCkgKyBzbGFzaDtcXG4gIH0gZWxzZSB7XFxuICAgIGN3ZCA9ICh0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnXFxuICAgICAgPyB3aW5kb3cubG9jYXRpb25cXG4gICAgICA6IGxvY2F0aW9uKS5ocmVmLnJlcGxhY2UoL1xcXFwvW14vXSokLywgJy8nKTtcXG4gICAgc2xhc2ggPSAnLyc7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc01vY2hhSW50ZXJuYWwgKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEnICsgc2xhc2gpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEuanMnKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignYm93ZXJfY29tcG9uZW50cycgKyBzbGFzaCArICdtb2NoYS5qcycpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKHNsYXNoICsgJ21vY2hhLmpzJykpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNOb2RlSW50ZXJuYWwgKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCcodGltZXJzLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcoZXZlbnRzLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcobm9kZS5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUubmV4dCAobmF0aXZlKScpKSB8fFxcbiAgICAgIGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFjaykge1xcbiAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXFxcbicpO1xcblxcbiAgICBzdGFjayA9IHJlZHVjZShzdGFjaywgZnVuY3Rpb24gKGxpc3QsIGxpbmUpIHtcXG4gICAgICBpZiAoaXNNb2NoYUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzLm5vZGUgJiYgaXNOb2RlSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXFxuICAgICAgaWYgKC9cXFxcKD8uKzpcXFxcZCs6XFxcXGQrXFxcXCk/JC8udGVzdChsaW5lKSkge1xcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShjd2QsICcnKTtcXG4gICAgICB9XFxuXFxuICAgICAgbGlzdC5wdXNoKGxpbmUpO1xcbiAgICAgIHJldHVybiBsaXN0O1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIHJldHVybiBzdGFjay5qb2luKCdcXFxcbicpO1xcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIENydWRlLCBidXQgZWZmZWN0aXZlLlxcbiAqIEBhcGlcXG4gKiBAcGFyYW0geyp9IHZhbHVlXFxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGB2YWx1ZWAgaXMgYSBQcm9taXNlXFxuICovXFxuZXhwb3J0cy5pc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UgKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcbi8qKlxcbiAqIEl0J3MgYSBub29wLlxcbiAqIEBhcGlcXG4gKi9cXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFxcXCJidWZmZXJcXFwiKS5CdWZmZXIpXFxufSx7XFxcIi4vdG8taXNvLXN0cmluZ1xcXCI6MzcsXFxcIl9wcm9jZXNzXFxcIjo4MixcXFwiYnVmZmVyXFxcIjo0MyxcXFwiZGVidWdcXFwiOjIsXFxcImZzXFxcIjo0MixcXFwiZ2xvYlxcXCI6NDIsXFxcImhlXFxcIjo2NCxcXFwianNvbjNcXFwiOjY5LFxcXCJwYXRoXFxcIjo0MixcXFwidXRpbFxcXCI6MTAyfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0J1xcblxcbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcXG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XFxuXFxudmFyIGxvb2t1cCA9IFtdXFxudmFyIHJldkxvb2t1cCA9IFtdXFxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxcblxcbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXFxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxcbn1cXG5cXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcXG5cXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XFxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXFxuICB9XFxuXFxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXFxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXFxufVxcblxcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXFxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXFxufVxcblxcbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcXG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXFxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxcblxcbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxcblxcbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXFxuXFxuICB2YXIgTCA9IDBcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXFxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XFxuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXFxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XFxuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XFxuICB2YXIgdG1wXFxuICB2YXIgb3V0cHV0ID0gW11cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XFxuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXFxuICB9XFxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXFxufVxcblxcbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XFxuICB2YXIgdG1wXFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcXG4gIHZhciBvdXRwdXQgPSAnJ1xcbiAgdmFyIHBhcnRzID0gW11cXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xcblxcbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxcbiAgfVxcblxcbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcXG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cXG4gICAgb3V0cHV0ICs9ICc9PSdcXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXFxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz0nXFxuICB9XFxuXFxuICBwYXJ0cy5wdXNoKG91dHB1dClcXG5cXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxcbn1cXG5cXG59LHt9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuXFxufSx7fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxudmFyIFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuV3JpdGFibGVcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEJyb3dzZXJTdGRvdXRcXG5cXG5cXG5pbmhlcml0cyhCcm93c2VyU3Rkb3V0LCBXcml0YWJsZVN0cmVhbSlcXG5cXG5mdW5jdGlvbiBCcm93c2VyU3Rkb3V0KG9wdHMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCcm93c2VyU3Rkb3V0KSkgcmV0dXJuIG5ldyBCcm93c2VyU3Rkb3V0KG9wdHMpXFxuXFxuICBvcHRzID0gb3B0cyB8fCB7fVxcbiAgV3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCBvcHRzKVxcbiAgdGhpcy5sYWJlbCA9IChvcHRzLmxhYmVsICE9PSB1bmRlZmluZWQpID8gb3B0cy5sYWJlbCA6ICdzdGRvdXQnXFxufVxcblxcbkJyb3dzZXJTdGRvdXQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rcywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgb3V0cHV0ID0gY2h1bmtzLnRvU3RyaW5nID8gY2h1bmtzLnRvU3RyaW5nKCkgOiBjaHVua3NcXG4gIGlmICh0aGlzLmxhYmVsID09PSBmYWxzZSkge1xcbiAgICBjb25zb2xlLmxvZyhvdXRwdXQpXFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyh0aGlzLmxhYmVsKyc6Jywgb3V0cHV0KVxcbiAgfVxcbiAgcHJvY2Vzcy5uZXh0VGljayhjYilcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo4MixcXFwic3RyZWFtXFxcIjo5NixcXFwidXRpbFxcXCI6MTAyfV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmFyZ3VtZW50c1s0XVs0MF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXFxufSx7XFxcImR1cFxcXCI6NDB9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbi8qIVxcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuXFxuJ3VzZSBzdHJpY3QnXFxuXFxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXFxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxcblxcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXFxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxcblxcbi8qKlxcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XFxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXFxuICpcXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxcbiAqXFxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxcbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxcbiAqXFxuICogTm90ZTpcXG4gKlxcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxcbiAqXFxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXFxuICpcXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cXG5cXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxcbiAqL1xcbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXFxuXFxuLypcXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXFxuICovXFxuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXFxuXFxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXFxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcXG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxcbiAgICA/IDB4N2ZmZmZmZmZcXG4gICAgOiAweDNmZmZmZmZmXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XFxuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXFxuICB9XFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXFxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXFxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcXG4gICAgfVxcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxcbiAgfVxcblxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuLyoqXFxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXFxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXFxuICpcXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXFxuICovXFxuXFxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XFxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgLy8gQ29tbW9uIGNhc2UuXFxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcXG4gICAgICApXFxuICAgIH1cXG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcXG4gIH1cXG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cXG5cXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XFxuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgcmV0dXJuIGFyclxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXFxuICB9XFxuXFxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcXG59XFxuXFxuLyoqXFxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXFxuICogQnVmZmVyLmZyb20oYXJyYXkpXFxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxcbiAqKi9cXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XFxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcXG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcXG4gICAgICB2YWx1ZTogbnVsbCxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwic2l6ZVxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFwic2l6ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIGFzc2VydFNpemUoc2l6ZSlcXG4gIGlmIChzaXplIDw9IDApIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxcbiAgfVxcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcXG4gIH1cXG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcXG4gKiovXFxuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXFxufVxcblxcbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xcbiAgICAgIHRoYXRbaV0gPSAwXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbi8qKlxcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICogKi9cXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXFxufVxcbi8qKlxcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqL1xcbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXFxufVxcblxcbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xcbiAgfVxcblxcbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImVuY29kaW5nXFxcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcXG4gIH1cXG5cXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXFxuXFxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcblxcbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XFxuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxcbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcXG4gIH1cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXFxuXFxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnb2Zmc2V0XFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuXFxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFxcJ2xlbmd0aFxcXFwnIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxcbiAgfSBlbHNlIHtcXG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxcbiAgICB0aGF0ID0gYXJyYXlcXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXFxuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxcbiAgfVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcXG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxcblxcbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gdGhhdFxcbiAgICB9XFxuXFxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcXG4gICAgcmV0dXJuIHRoYXRcXG4gIH1cXG5cXG4gIGlmIChvYmopIHtcXG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXFxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxcbiAgICB9XFxuXFxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXFxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxcbiAgfVxcbiAgcmV0dXJuIGxlbmd0aCB8IDBcXG59XFxuXFxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XFxuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcXG4gICAgbGVuZ3RoID0gMFxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcXG59XFxuXFxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IGEubGVuZ3RoXFxuICB2YXIgeSA9IGIubGVuZ3RoXFxuXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xcbiAgICAgIHggPSBhW2ldXFxuICAgICAgeSA9IGJbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgY2FzZSAnYXNjaWknOlxcbiAgICBjYXNlICdsYXRpbjEnOlxcbiAgICBjYXNlICdiaW5hcnknOlxcbiAgICBjYXNlICdiYXNlNjQnOlxcbiAgICBjYXNlICd1Y3MyJzpcXG4gICAgY2FzZSAndWNzLTInOlxcbiAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcXG4gIH1cXG5cXG4gIHZhciBpXFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgbGVuZ3RoID0gMFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcXG4gIHZhciBwb3MgPSAwXFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXFxuICAgIH1cXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXFxuICAgIHBvcyArPSBidWYubGVuZ3RoXFxuICB9XFxuICByZXR1cm4gYnVmZmVyXFxufVxcblxcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxcbiAgfVxcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXFxuICB9XFxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsZW5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgY2FzZSB1bmRlZmluZWQ6XFxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXFxuXFxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG5cXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXFxcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcXFwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcXG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXFxuXFxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXFxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gMCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXFxuICBlbmQgPj4+PSAwXFxuICBzdGFydCA+Pj49IDBcXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcblxcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXFxuXFxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xcbiAgdmFyIGkgPSBiW25dXFxuICBiW25dID0gYlttXVxcbiAgYlttXSA9IGlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXFxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XFxuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XFxuICB2YXIgc3RyID0gJydcXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXFxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcXG4gIH1cXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgc3RhcnQgPSAwXFxuICB9XFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcXG4gIH1cXG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzU3RhcnQgPSAwXFxuICB9XFxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XFxuICAgIHJldHVybiAtMVxcbiAgfVxcbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMVxcbiAgfVxcblxcbiAgc3RhcnQgPj4+PSAwXFxuICBlbmQgPj4+PSAwXFxuICB0aGlzU3RhcnQgPj4+PSAwXFxuICB0aGlzRW5kID4+Pj0gMFxcblxcbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcXG5cXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXFxuXFxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xcbiAgICAgIHggPSB0aGlzQ29weVtpXVxcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxcbi8vXFxuLy8gQXJndW1lbnRzOlxcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXFxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XFxuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcXG5cXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxcbiAgICBieXRlT2Zmc2V0ID0gMFxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcXG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXFxuICB9XFxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXFxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcXG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXFxcImZvb1xcXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcXG4gIH1cXG5cXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXFxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcXG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcXG4gICAgZWxzZSByZXR1cm4gLTFcXG4gIH1cXG5cXG4gIC8vIE5vcm1hbGl6ZSB2YWxcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxcbiAgfVxcblxcbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXFxuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIC0xXFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXFxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBpZiAoZGlyKSB7XFxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXFxuICB9XFxuXFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxcbn1cXG5cXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XFxuICB2YXIgaW5kZXhTaXplID0gMVxcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXFxuXFxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgfVxcbiAgICAgIGluZGV4U2l6ZSA9IDJcXG4gICAgICBhcnJMZW5ndGggLz0gMlxcbiAgICAgIHZhbExlbmd0aCAvPSAyXFxuICAgICAgYnl0ZU9mZnNldCAvPSAyXFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XFxuICAgICAgcmV0dXJuIGJ1ZltpXVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBpXFxuICBpZiAoZGlyKSB7XFxuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcXG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB2YXIgZm91bmQgPSB0cnVlXFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxcbn1cXG5cXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKCFsZW5ndGgpIHtcXG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICB9IGVsc2Uge1xcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XFxuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXFxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXFxuXFxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXFxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXFxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gICAgb2Zmc2V0ID0gMFxcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gb2Zmc2V0XFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXFxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxcbiAgICB9XFxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXFxuICB9IGVsc2Uge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xcbiAgICApXFxuICB9XFxuXFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xcblxcbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XFxuICByZXR1cm4ge1xcbiAgICB0eXBlOiAnQnVmZmVyJyxcXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuICB2YXIgcmVzID0gW11cXG5cXG4gIHZhciBpID0gc3RhcnRcXG4gIHdoaWxlIChpIDwgZW5kKSB7XFxuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXFxuICAgICAgOiAxXFxuXFxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcXG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XFxuXFxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XFxuICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XFxuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMzpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXFxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcXG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXFxuICAgIH1cXG5cXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcXG4gIH1cXG5cXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxcbn1cXG5cXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXFxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxcblxcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XFxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxcbiAgfVxcblxcbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcXFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXFxcIi5cXG4gIHZhciByZXMgPSAnJ1xcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoaSA8IGxlbikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcXG4gICAgICBTdHJpbmcsXFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxcbiAgICApXFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcXG5cXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cXG5cXG4gIHZhciBvdXQgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiBvdXRcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxcbiAgdmFyIHJlcyA9ICcnXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgc3RhcnQgPSB+fnN0YXJ0XFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXFxuXFxuICBpZiAoc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ICs9IGxlblxcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcXG4gICAgc3RhcnQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCAwKSB7XFxuICAgIGVuZCArPSBsZW5cXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XFxuICAgIGVuZCA9IGxlblxcbiAgfVxcblxcbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgdmFyIG5ld0J1ZlxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XFxuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuZXdCdWZcXG59XFxuXFxuLypcXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cXG4gKi9cXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuICB9XFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXFxuICB2YXIgbXVsID0gMVxcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcXG4gIH1cXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gdGhpc1tvZmZzZXRdXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXFxuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxcbiAgfVxcbiAgbXVsICo9IDB4ODBcXG5cXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXFxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxcbiAgfVxcbiAgbXVsICo9IDB4ODBcXG5cXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImJ1ZmZlclxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXFxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXFxuICB9XFxuXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXFxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XFxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcXG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSAwXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IDBcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcXG5cXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXFxuICB9XFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IDBcXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xcbiAgICAgIHN1YiA9IDFcXG4gICAgfVxcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAxXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxcbiAgcmV0dXJuIG9mZnNldCArIDhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XFxuXFxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXFxuXFxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXFxuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxcblxcbiAgLy8gQXJlIHdlIG9vYj9cXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxcbiAgfVxcblxcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XFxuICB2YXIgaVxcblxcbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XFxuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcXG4gICAgICB0YXJnZXQsXFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxcbiAgICAgIHRhcmdldFN0YXJ0XFxuICAgIClcXG4gIH1cXG5cXG4gIHJldHVybiBsZW5cXG59XFxuXFxuLy8gVXNhZ2U6XFxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXFxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXFxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXFxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcXG4gICAgICBzdGFydCA9IDBcXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBlbmRcXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgICB9XFxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XFxuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XFxuICAgICAgICB2YWwgPSBjb2RlXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIHZhbCA9IHZhbCAmIDI1NVxcbiAgfVxcblxcbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXFxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXFxuICB9XFxuXFxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXFxuXFxuICBpZiAoIXZhbCkgdmFsID0gMFxcblxcbiAgdmFyIGlcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgICAgdGhpc1tpXSA9IHZhbFxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxcbiAgICAgID8gdmFsXFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXFxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcXG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG4vLyBIRUxQRVIgRlVOQ1RJT05TXFxuLy8gPT09PT09PT09PT09PT09PVxcblxcbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXFxcLzAtOUEtWmEtei1fXS9nXFxuXFxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcXFxuIGFuZCBcXFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XFxuICAgIHN0ciA9IHN0ciArICc9J1xcbiAgfVxcbiAgcmV0dXJuIHN0clxcbn1cXG5cXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcXG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKVxcbn1cXG5cXG5mdW5jdGlvbiB0b0hleCAobikge1xcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXFxuICByZXR1cm4gbi50b1N0cmluZygxNilcXG59XFxuXFxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcXG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcXG4gIHZhciBjb2RlUG9pbnRcXG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcXG4gIHZhciBieXRlcyA9IFtdXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXFxuXFxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcXG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcXG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcXG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gdmFsaWQgbGVhZFxcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxcblxcbiAgICAgICAgY29udGludWVcXG4gICAgICB9XFxuXFxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcXG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxcbiAgICAgICAgY29udGludWVcXG4gICAgICB9XFxuXFxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgfVxcblxcbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxcblxcbiAgICAvLyBlbmNvZGUgdXRmOFxcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVzXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XFxuICB2YXIgYnl0ZUFycmF5ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxcbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXFxuICB9XFxuICByZXR1cm4gYnl0ZUFycmF5XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XFxuICB2YXIgYywgaGksIGxvXFxuICB2YXIgYnl0ZUFycmF5ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xcblxcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcXG4gICAgaGkgPSBjID4+IDhcXG4gICAgbG8gPSBjICUgMjU2XFxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxcbiAgICBieXRlQXJyYXkucHVzaChoaSlcXG4gIH1cXG5cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XFxuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXFxufVxcblxcbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXFxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxcbiAgfVxcbiAgcmV0dXJuIGlcXG59XFxuXFxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCJiYXNlNjQtanNcXFwiOjM5LFxcXCJpZWVlNzU0XFxcIjo2NSxcXFwiaXNhcnJheVxcXCI6Njh9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChCdWZmZXIpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcblxcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSkge1xcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xcbiAgfVxcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMse1xcXCJpc0J1ZmZlclxcXCI6cmVxdWlyZShcXFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXFxcIil9KVxcbn0se1xcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiOjY3fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9ETVAgPSBjb252ZXJ0Q2hhbmdlc1RvRE1QO1xcbi8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXFxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XFxuICB2YXIgcmV0ID0gW10sXFxuICAgICAgY2hhbmdlID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG4gICAgICBvcGVyYXRpb24gPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG4gICAgICBvcGVyYXRpb24gPSAxO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuICAgICAgb3BlcmF0aW9uID0gLTE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3BlcmF0aW9uID0gMDtcXG4gICAgfVxcblxcbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcXG4gIH1cXG4gIHJldHVybiByZXQ7XFxufVxcblxcblxcbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvWE1MID0gY29udmVydENoYW5nZXNUb1hNTDtcXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcXG4gIHZhciByZXQgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuICAgICAgcmV0LnB1c2goJzxkZWw+Jyk7XFxuICAgIH1cXG5cXG4gICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcXG5cXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcbiAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcXG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcXG59XFxuXFxuZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XFxuICB2YXIgbiA9IHM7XFxuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xcbiAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xcbiAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcbiAgbiA9IG4ucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7Jyk7XFxuXFxuICByZXR1cm4gbjtcXG59XFxuXFxuXFxufSx7fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmFycmF5RGlmZiA9IHVuZGVmaW5lZDtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZBcnJheXMgPSBkaWZmQXJyYXlzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBhcnJheURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcnJheURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddKCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuYXJyYXlEaWZmLnRva2VuaXplID0gYXJyYXlEaWZmLmpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHJldHVybiB2YWx1ZS5zbGljZSgpO1xcbn07XFxuXFxuZnVuY3Rpb24gZGlmZkFycmF5cyhvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHtcXG4gIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xcbn1cXG5cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjo0OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0c1snZGVmYXVsdCddID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9EaWZmO1xcbmZ1bmN0aW9uIERpZmYoKSB7fVxcblxcbkRpZmYucHJvdG90eXBlID0geyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcXG5cXG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xcbiAgICAgIG9wdGlvbnMgPSB7fTtcXG4gICAgfVxcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcXG4gICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcXG4gICAgICAgIH0sIDApO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXFxuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XFxuICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XFxuXFxuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcXG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xcblxcbiAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XFxuICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcXG4gICAgdmFyIG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XFxuICAgIHZhciBiZXN0UGF0aCA9IFt7IG5ld1BvczogLTEsIGNvbXBvbmVudHM6IFtdIH1dO1xcblxcbiAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xcbiAgICB2YXIgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XFxuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xcbiAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxcbiAgICAgIHJldHVybiBkb25lKFt7IHZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSwgY291bnQ6IG5ld1N0cmluZy5sZW5ndGggfV0pO1xcbiAgICB9XFxuXFxuICAgIC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XFxuICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcXG4gICAgICAgIHZhciBiYXNlUGF0aCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuICAgICAgICB2YXIgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxcbiAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXSxcXG4gICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xcbiAgICAgICAgaWYgKGFkZFBhdGgpIHtcXG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcXG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXFxuICAgICAgICAgICAgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IF9vbGRQb3MgJiYgX29sZFBvcyA8IG9sZExlbjtcXG4gICAgICAgIGlmICghY2FuQWRkICYmICFjYW5SZW1vdmUpIHtcXG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXFxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcXG4gICAgICAgIGlmICghY2FuQWRkIHx8IGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSB7XFxuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xcbiAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcXG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XFxuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XFxuXFxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxcbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xcbiAgICAgICAgICByZXR1cm4gZG9uZShidWlsZFZhbHVlcyhzZWxmLCBiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgc2VsZi51c2VMb25nZXN0VG9rZW4pKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cXG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBlZGl0TGVuZ3RoKys7XFxuICAgIH1cXG5cXG4gICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxcbiAgICAvLyBpcyBwcm9kdWNlZC5cXG4gICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XFxuICAgICAgICAgICAgZXhlYygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCAwKTtcXG4gICAgICB9KSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcXG4gICAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xcbiAgICAgICAgaWYgKHJldCkge1xcbiAgICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wdXNoQ29tcG9uZW50OiBmdW5jdGlvbiBwdXNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGFkZGVkLCByZW1vdmVkKSB7XFxuICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xcbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcXG4gICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcXG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7IGNvdW50OiBsYXN0LmNvdW50ICsgMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29tcG9uZW50cy5wdXNoKHsgY291bnQ6IDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9KTtcXG4gICAgfVxcbiAgfSxcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9leHRyYWN0Q29tbW9uOiBmdW5jdGlvbiBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XFxuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcXG4gICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcXG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcXG4gICAgICBuZXdQb3MrKztcXG4gICAgICBvbGRQb3MrKztcXG4gICAgICBjb21tb25Db3VudCsrO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb21tb25Db3VudCkge1xcbiAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7IGNvdW50OiBjb21tb25Db3VudCB9KTtcXG4gICAgfVxcblxcbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XFxuICAgIHJldHVybiBvbGRQb3M7XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2VxdWFsczogZnVuY3Rpb24gZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XFxuICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcXG4gIH0sXFxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XFxuICAgIHZhciByZXQgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChhcnJheVtpXSkge1xcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfSxcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3Rva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xcbiAgfSxcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9qb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XFxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcXG4gIHZhciBjb21wb25lbnRQb3MgPSAwLFxcbiAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxcbiAgICAgIG5ld1BvcyA9IDAsXFxuICAgICAgb2xkUG9zID0gMDtcXG5cXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XFxuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XFxuICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XFxuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcXG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xcbiAgICAgIH1cXG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcbiAgICAgIC8vIENvbW1vbiBjYXNlXFxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcXG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcXG4gICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcbiAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXFxuICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcXG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcXG4gICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQuIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlXFxuICAvLyB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cXG4gIHZhciBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcXG4gIGlmIChjb21wb25lbnRMZW4gPiAxICYmIChsYXN0Q29tcG9uZW50LmFkZGVkIHx8IGxhc3RDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XFxuICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gbGFzdENvbXBvbmVudC52YWx1ZTtcXG4gICAgY29tcG9uZW50cy5wb3AoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb21wb25lbnRzO1xcbn1cXG5cXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xcbiAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XFxufVxcblxcblxcbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy5jaGFyYWN0ZXJEaWZmID0gdW5kZWZpbmVkO1xcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNoYXJzID0gZGlmZkNoYXJzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBjaGFyYWN0ZXJEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2hhcmFjdGVyRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10oKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5mdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxufVxcblxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjQ4fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmNzc0RpZmYgPSB1bmRlZmluZWQ7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ3NzID0gZGlmZkNzcztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gcmVxdWlyZSgnLi9iYXNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgY3NzRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nzc0RpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddKCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXFxccyspLyk7XFxufTtcXG5cXG5mdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcbiAgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcbn1cXG5cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjo0OH1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy5qc29uRGlmZiA9IHVuZGVmaW5lZDtcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmSnNvbiA9IGRpZmZKc29uO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gcmVxdWlyZSgnLi9iYXNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSByZXF1aXJlKCcuL2xpbmUnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxuXFxudmFyIG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG52YXIganNvbkRpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9qc29uRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10oKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG4vLyBEaXNjcmltaW5hdGUgYmV0d2VlbiB0d28gbGluZXMgb2YgcHJldHR5LXByaW50ZWQsIHNlcmlhbGl6ZWQgSlNPTiB3aGVyZSBvbmUgb2YgdGhlbSBoYXMgYVxcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0Olxcbmpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XFxuXFxuanNvbkRpZmYudG9rZW5pemUgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUubGluZURpZmYuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdG9rZW5pemU7XFxuanNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSB0aGlzLm9wdGlvbnMudW5kZWZpbmVkUmVwbGFjZW1lbnQ7XFxuXFxuXFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlKSwgZnVuY3Rpb24gKGssIHYpIHtcXG4gICAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWRSZXBsYWNlbWVudDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdjtcXG4gIH0sICcgICcpO1xcbn07XFxuanNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XFxuICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXS4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wcm90b3R5cGUuZXF1YWxzKGxlZnQucmVwbGFjZSgvLChbXFxcXHJcXFxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJykpXFxuICApO1xcbn07XFxuXFxuZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcXG4gIHJldHVybiBqc29uRGlmZi5kaWZmKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKTtcXG59XFxuXFxuLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXFxuLy8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXFxcInN0YWNrXFxcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuXFxuZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spIHtcXG4gIHN0YWNrID0gc3RhY2sgfHwgW107XFxuICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcXG5cXG4gIHZhciBpID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgY2Fub25pY2FsaXplZE9iaiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XFxuICAgIHN0YWNrLnB1c2gob2JqKTtcXG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcXG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrKTtcXG4gICAgfVxcbiAgICBzdGFjay5wb3AoKTtcXG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcXG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICB9XFxuXFxuICBpZiAob2JqICYmIG9iai50b0pTT04pIHtcXG4gICAgb2JqID0gb2JqLnRvSlNPTigpO1xcbiAgfVxcblxcbiAgaWYgKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKHR5cGVvZiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xcbiAgICBzdGFjay5wdXNoKG9iaik7XFxuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcbiAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxcbiAgICAgICAga2V5ID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcXG4gICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBrZXkgPSBzb3J0ZWRLZXlzW2ldO1xcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xcbiAgICB9XFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcbiAgfSBlbHNlIHtcXG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcXG4gIH1cXG4gIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xcbn1cXG5cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjo0OCxcXFwiLi9saW5lXFxcIjo1Mn1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy5saW5lRGlmZiA9IHVuZGVmaW5lZDtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZMaW5lcyA9IGRpZmZMaW5lcztcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmVHJpbW1lZExpbmVzID0gZGlmZlRyaW1tZWRMaW5lcztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gcmVxdWlyZSgnLi9iYXNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcmFtcyA9IHJlcXVpcmUoJy4uL3V0aWwvcGFyYW1zJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBsaW5lRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2xpbmVEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICB2YXIgcmV0TGluZXMgPSBbXSxcXG4gICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXFxcbnxcXFxcclxcXFxuKS8pO1xcblxcbiAgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXFxuICBpZiAoIWxpbmVzQW5kTmV3bGluZXNbbGluZXNBbmROZXdsaW5lcy5sZW5ndGggLSAxXSkge1xcbiAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xcbiAgfVxcblxcbiAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XFxuXFxuICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XFxuICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gbGluZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcXG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcXG4gICAgICB9XFxuICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJldExpbmVzO1xcbn07XFxuXFxuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG59XFxuZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG4gIHZhciBvcHRpb25zID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyYW1zLmdlbmVyYXRlT3B0aW9ucykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oY2FsbGJhY2ssIHsgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZSB9KTtcXG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG59XFxuXFxuXFxufSx7XFxcIi4uL3V0aWwvcGFyYW1zXFxcIjo2MCxcXFwiLi9iYXNlXFxcIjo0OH1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy5zZW50ZW5jZURpZmYgPSB1bmRlZmluZWQ7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmU2VudGVuY2VzID0gZGlmZlNlbnRlbmNlcztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gcmVxdWlyZSgnLi9iYXNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgc2VudGVuY2VEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc2VudGVuY2VEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbnNlbnRlbmNlRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxcXFMuKz9bLiE/XSkoPz1cXFxccyt8JCkvKTtcXG59O1xcblxcbmZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gc2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG59XFxuXFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6NDh9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMud29yZERpZmYgPSB1bmRlZmluZWQ7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHMgPSBkaWZmV29yZHM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzV2l0aFNwYWNlID0gZGlmZldvcmRzV2l0aFNwYWNlO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyYW1zID0gcmVxdWlyZSgnLi4vdXRpbC9wYXJhbXMnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxuXFxuLy8gQmFzZWQgb24gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fc2NyaXB0X2luX1VuaWNvZGVcXG4vL1xcbi8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcXG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXFxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXFxuLy8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXFxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0ZcXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0Rlxcbi8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cXG4vLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXFxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcXG4vLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXFxuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXFxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcXG4vLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxcbnZhciBleHRlbmRlZFdvcmRDaGFycyA9IC9eW0EtWmEtelxcXFx4QzAtXFxcXHUwMkM2XFxcXHUwMkM4LVxcXFx1MDJEN1xcXFx1MDJERS1cXFxcdTAyRkZcXFxcdTFFMDAtXFxcXHUxRUZGXSskLztcXG5cXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xcXFxTLztcXG5cXG52YXIgd29yZERpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi93b3JkRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10oKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG53b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcXG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcXG59O1xcbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhcXFxccyt8XFxcXGIpLyk7XFxuXFxuICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXFxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2ldKSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpICsgMl0pKSB7XFxuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XFxuICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XFxuICAgICAgaS0tO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdG9rZW5zO1xcbn07XFxuXFxuZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcbiAgdmFyIG9wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJhbXMuZ2VuZXJhdGVPcHRpb25zKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhjYWxsYmFjaywgeyBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlIH0pO1xcbiAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcbn1cXG5mdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcbn1cXG5cXG5cXG59LHtcXFwiLi4vdXRpbC9wYXJhbXNcXFwiOjYwLFxcXCIuL2Jhc2VcXFwiOjQ4fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGV4cG9ydHMucGFyc2VQYXRjaCA9IGV4cG9ydHMuYXBwbHlQYXRjaGVzID0gZXhwb3J0cy5hcHBseVBhdGNoID0gZXhwb3J0cy5jcmVhdGVQYXRjaCA9IGV4cG9ydHMuY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGV4cG9ydHMuc3RydWN0dXJlZFBhdGNoID0gZXhwb3J0cy5kaWZmQXJyYXlzID0gZXhwb3J0cy5kaWZmSnNvbiA9IGV4cG9ydHMuZGlmZkNzcyA9IGV4cG9ydHMuZGlmZlNlbnRlbmNlcyA9IGV4cG9ydHMuZGlmZlRyaW1tZWRMaW5lcyA9IGV4cG9ydHMuZGlmZkxpbmVzID0gZXhwb3J0cy5kaWZmV29yZHNXaXRoU3BhY2UgPSBleHBvcnRzLmRpZmZXb3JkcyA9IGV4cG9ydHMuZGlmZkNoYXJzID0gZXhwb3J0cy5EaWZmID0gdW5kZWZpbmVkO1xcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IHJlcXVpcmUoJy4vZGlmZi9iYXNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NoYXJhY3RlciA9IHJlcXVpcmUoJy4vZGlmZi9jaGFyYWN0ZXInKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL193b3JkID0gcmVxdWlyZSgnLi9kaWZmL3dvcmQnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gcmVxdWlyZSgnLi9kaWZmL2xpbmUnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19zZW50ZW5jZSA9IHJlcXVpcmUoJy4vZGlmZi9zZW50ZW5jZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NzcyA9IHJlcXVpcmUoJy4vZGlmZi9jc3MnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19qc29uID0gcmVxdWlyZSgnLi9kaWZmL2pzb24nKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19hcnJheSA9IHJlcXVpcmUoJy4vZGlmZi9hcnJheScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FwcGx5ID0gcmVxdWlyZSgnLi9wYXRjaC9hcHBseScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gcmVxdWlyZSgnLi9wYXRjaC9wYXJzZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NyZWF0ZSA9IHJlcXVpcmUoJy4vcGF0Y2gvY3JlYXRlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fZG1wID0gcmVxdWlyZSgnLi9jb252ZXJ0L2RtcCcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3htbCA9IHJlcXVpcmUoJy4vY29udmVydC94bWwnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovRGlmZiA9IF9iYXNlMlsnZGVmYXVsdCddO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDaGFycyA9IF9jaGFyYWN0ZXIuZGlmZkNoYXJzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3JkcyA9IF93b3JkLmRpZmZXb3JkcztcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHNXaXRoU3BhY2UgPSBfd29yZC5kaWZmV29yZHNXaXRoU3BhY2U7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkxpbmVzID0gX2xpbmUuZGlmZkxpbmVzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZUcmltbWVkTGluZXMgPSBfbGluZS5kaWZmVHJpbW1lZExpbmVzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZTZW50ZW5jZXMgPSBfc2VudGVuY2UuZGlmZlNlbnRlbmNlcztcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ3NzID0gX2Nzcy5kaWZmQ3NzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZKc29uID0gX2pzb24uZGlmZkpzb247XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkFycmF5cyA9IF9hcnJheS5kaWZmQXJyYXlzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3N0cnVjdHVyZWRQYXRjaCA9IF9jcmVhdGUuc3RydWN0dXJlZFBhdGNoO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVR3b0ZpbGVzUGF0Y2ggPSBfY3JlYXRlLmNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlUGF0Y2ggPSBfY3JlYXRlLmNyZWF0ZVBhdGNoO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2ggPSBfYXBwbHkuYXBwbHlQYXRjaDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoZXMgPSBfYXBwbHkuYXBwbHlQYXRjaGVzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3BhcnNlUGF0Y2ggPSBfcGFyc2UucGFyc2VQYXRjaDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvRE1QID0gX2RtcC5jb252ZXJ0Q2hhbmdlc1RvRE1QO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9YTUwgPSBfeG1sLmNvbnZlcnRDaGFuZ2VzVG9YTUw7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2Fub25pY2FsaXplID0gX2pzb24uY2Fub25pY2FsaXplOyAvKiBTZWUgTElDRU5TRSBmaWxlIGZvciB0ZXJtcyBvZiB1c2UgKi9cXG5cXG4vKlxcbiAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cXG4gKlxcbiAqIFRoaXMgbGlicmFyeSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIEFQSVM6XFxuICogSnNEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXFxuICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXFxcYiByZWdleCkgZGlmZiB3aGljaCBpZ25vcmVzIHdoaXRlc3BhY2VcXG4gKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcXG4gKlxcbiAqIEpzRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XFxuICpcXG4gKiBUaGVzZSBtZXRob2RzIGFyZSBiYXNlZCBvbiB0aGUgaW1wbGVtZW50YXRpb24gcHJvcG9zZWQgaW5cXG4gKiBcXFwiQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIGl0cyBWYXJpYXRpb25zXFxcIiAoTXllcnMsIDE5ODYpLlxcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNC42OTI3XFxuICovXFxuXFxuXFxufSx7XFxcIi4vY29udmVydC9kbXBcXFwiOjQ1LFxcXCIuL2NvbnZlcnQveG1sXFxcIjo0NixcXFwiLi9kaWZmL2FycmF5XFxcIjo0NyxcXFwiLi9kaWZmL2Jhc2VcXFwiOjQ4LFxcXCIuL2RpZmYvY2hhcmFjdGVyXFxcIjo0OSxcXFwiLi9kaWZmL2Nzc1xcXCI6NTAsXFxcIi4vZGlmZi9qc29uXFxcIjo1MSxcXFwiLi9kaWZmL2xpbmVcXFwiOjUyLFxcXCIuL2RpZmYvc2VudGVuY2VcXFwiOjUzLFxcXCIuL2RpZmYvd29yZFxcXCI6NTQsXFxcIi4vcGF0Y2gvYXBwbHlcXFwiOjU2LFxcXCIuL3BhdGNoL2NyZWF0ZVxcXCI6NTcsXFxcIi4vcGF0Y2gvcGFyc2VcXFwiOjU4fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19kaXN0YW5jZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vdXRpbC9kaXN0YW5jZS1pdGVyYXRvcicpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG52YXIgX2Rpc3RhbmNlSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2VJdGVyYXRvcik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYpIHtcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XFxuXFxuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XFxuICAgIHVuaURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmlEaWZmKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XFxuICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xcbiAgICB9XFxuXFxuICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xcbiAgfVxcblxcbiAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XFxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vKSxcXG4gICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdL2cpIHx8IFtdLFxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcXG4gICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmUsIG9wZXJhdGlvbiwgcGF0Y2hDb250ZW50KSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCove1xcbiAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZSA9PT0gcGF0Y2hDb250ZW50XFxuICAgICk7XFxuICB9LFxcbiAgICAgIGVycm9yQ291bnQgPSAwLFxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcXG4gICAgICBtaW5MaW5lID0gMCxcXG4gICAgICBvZmZzZXQgPSAwLFxcbiAgICAgIHJlbW92ZUVPRk5MID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG4gICAgICBhZGRFT0ZOTCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuICAvKipcXG4gICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xcbiAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZVswXSxcXG4gICAgICAgICAgY29udGVudCA9IGxpbmUuc3Vic3RyKDEpO1xcblxcbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xcbiAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcXG4gICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcXG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xcblxcbiAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHRvUG9zKys7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaHVuayA9IGh1bmtzW2ldLFxcbiAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXFxuICAgICAgICBsb2NhbE9mZnNldCA9IDAsXFxuICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xcblxcbiAgICB2YXIgaXRlcmF0b3IgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9kaXN0YW5jZUl0ZXJhdG9yMlsnZGVmYXVsdCddKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XFxuXFxuICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcXG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcXG4gICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XFxuICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XFxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xcbiAgfVxcblxcbiAgLy8gQXBwbHkgcGF0Y2ggaHVua3NcXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBodW5rcy5sZW5ndGg7IF9pKyspIHtcXG4gICAgdmFyIF9odW5rID0gaHVua3NbX2ldLFxcbiAgICAgICAgX3RvUG9zID0gX2h1bmsub2Zmc2V0ICsgX2h1bmsubmV3U3RhcnQgLSAxO1xcbiAgICBpZiAoX2h1bmsubmV3TGluZXMgPT0gMCkge1xcbiAgICAgIF90b1BvcysrO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICB2YXIgbGluZSA9IF9odW5rLmxpbmVzW2pdLFxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lWzBdLFxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5zdWJzdHIoMSksXFxuICAgICAgICAgIGRlbGltaXRlciA9IF9odW5rLmxpbmVkZWxpbWl0ZXJzW2pdO1xcblxcbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xcbiAgICAgICAgX3RvUG9zKys7XFxuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xcbiAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMSk7XFxuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XFxuICAgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xcbiAgICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDAsIGRlbGltaXRlcik7XFxuICAgICAgICAgIF90b1BvcysrO1xcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcXFxcXCcpIHtcXG4gICAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0aW9uID0gX2h1bmsubGluZXNbaiAtIDFdID8gX2h1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcXG4gICAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcXG4gICAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xcbiAgICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBIYW5kbGUgRU9GTkwgaW5zZXJ0aW9uL3JlbW92YWxcXG4gIGlmIChyZW1vdmVFT0ZOTCkge1xcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XFxuICAgICAgbGluZXMucG9wKCk7XFxuICAgICAgZGVsaW1pdGVycy5wb3AoKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xcbiAgICBsaW5lcy5wdXNoKCcnKTtcXG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXFxcbicpO1xcbiAgfVxcbiAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcXG4gICAgbGluZXNbX2tdID0gbGluZXNbX2tdICsgZGVsaW1pdGVyc1tfa107XFxuICB9XFxuICByZXR1cm4gbGluZXMuam9pbignJyk7XFxufVxcblxcbi8vIFdyYXBwZXIgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSBmaWxlIHBhdGNoZXMgdmlhIGNhbGxiYWNrcy5cXG5mdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xcbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xcbiAgICB1bmlEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyc2UucGFyc2VQYXRjaCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odW5pRGlmZik7XFxuICB9XFxuXFxuICB2YXIgY3VycmVudEluZGV4ID0gMDtcXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcXG4gICAgdmFyIGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XFxuICAgIGlmICghaW5kZXgpIHtcXG4gICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZSgpO1xcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcXG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyKSB7XFxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9XFxuICBwcm9jZXNzSW5kZXgoKTtcXG59XFxuXFxuXFxufSx7XFxcIi4uL3V0aWwvZGlzdGFuY2UtaXRlcmF0b3JcXFwiOjU5LFxcXCIuL3BhcnNlXFxcIjo1OH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zdHJ1Y3R1cmVkUGF0Y2ggPSBzdHJ1Y3R1cmVkUGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gcmVxdWlyZSgnLi4vZGlmZi9saW5lJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuICBpZiAoIW9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IHt9O1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XFxuICB9XFxuXFxuICB2YXIgZGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2xpbmUuZGlmZkxpbmVzKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuICBkaWZmLnB1c2goeyB2YWx1ZTogJycsIGxpbmVzOiBbXSB9KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcXG5cXG4gIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xcbiAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xcbiAgICAgIHJldHVybiAnICcgKyBlbnRyeTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICB2YXIgaHVua3MgPSBbXTtcXG4gIHZhciBvbGRSYW5nZVN0YXJ0ID0gMCxcXG4gICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcXG4gICAgICBjdXJSYW5nZSA9IFtdLFxcbiAgICAgIG9sZExpbmUgPSAxLFxcbiAgICAgIG5ld0xpbmUgPSAxO1xcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovaSkge1xcbiAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXFxuICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXFxcbiQvLCAnJykuc3BsaXQoJ1xcXFxuJyk7XFxuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcXG5cXG4gICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbiAgICAgIHZhciBfY3VyUmFuZ2U7XFxuXFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG4gICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxcbiAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xcbiAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcXG4gICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xcbiAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XFxuXFxuICAgICAgICBpZiAocHJldikge1xcbiAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcXG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XFxuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XFxuICAgICAgfSkpKTtcXG5cXG4gICAgICAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXFxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcXG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xcbiAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XFxuICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbiAgICAgICAgICB2YXIgX2N1clJhbmdlMjtcXG5cXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG4gICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UyID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlMiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb250ZXh0TGluZXMobGluZXMpKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICAgICAgICAgIHZhciBfY3VyUmFuZ2UzO1xcblxcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbiAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcXG4gICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZTMgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UzIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKSk7XFxuXFxuICAgICAgICAgIHZhciBodW5rID0ge1xcbiAgICAgICAgICAgIG9sZFN0YXJ0OiBvbGRSYW5nZVN0YXJ0LFxcbiAgICAgICAgICAgIG9sZExpbmVzOiBvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxcbiAgICAgICAgICAgIG5ld0xpbmVzOiBuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxcbiAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXFxuICAgICAgICAgICAgdmFyIG9sZEVPRk5ld2xpbmUgPSAvXFxcXG4kLy50ZXN0KG9sZFN0cik7XFxuICAgICAgICAgICAgdmFyIG5ld0VPRk5ld2xpbmUgPSAvXFxcXG4kLy50ZXN0KG5ld1N0cik7XFxuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAwICYmICFvbGRFT0ZOZXdsaW5lKSB7XFxuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXFxuICAgICAgICAgICAgICBjdXJSYW5nZS5zcGxpY2UoaHVuay5vbGRMaW5lcywgMCwgJ1xcXFxcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvbGRFT0ZOZXdsaW5lIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XFxuICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XFxuXFxuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcXG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbiAgICBfbG9vcCggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9pKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxcbiAgICBvbGRIZWFkZXI6IG9sZEhlYWRlciwgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXFxuICAgIGh1bmtzOiBodW5rc1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xcbiAgdmFyIGRpZmYgPSBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xcblxcbiAgdmFyIHJldCA9IFtdO1xcbiAgaWYgKG9sZEZpbGVOYW1lID09IG5ld0ZpbGVOYW1lKSB7XFxuICAgIHJldC5wdXNoKCdJbmRleDogJyArIG9sZEZpbGVOYW1lKTtcXG4gIH1cXG4gIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XFxuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBkaWZmLm9sZEhlYWRlcikpO1xcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFxcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaHVuayA9IGRpZmYuaHVua3NbaV07XFxuICAgIHJldC5wdXNoKCdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzICsgJyBAQCcpO1xcbiAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldC5qb2luKCdcXFxcbicpICsgJ1xcXFxuJztcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlUGF0Y2goZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xcbiAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xcbn1cXG5cXG5cXG59LHtcXFwiLi4vZGlmZi9saW5lXFxcIjo1Mn1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wYXJzZVBhdGNoID0gcGFyc2VQYXRjaDtcXG5mdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XFxuXFxuICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vKSxcXG4gICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS9nKSB8fCBbXSxcXG4gICAgICBsaXN0ID0gW10sXFxuICAgICAgaSA9IDA7XFxuXFxuICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xcbiAgICB2YXIgaW5kZXggPSB7fTtcXG4gICAgbGlzdC5wdXNoKGluZGV4KTtcXG5cXG4gICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxcbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldO1xcblxcbiAgICAgIC8vIEZpbGUgaGVhZGVyIGZvdW5kLCBlbmQgcGFyc2luZyBkaWZmIG1ldGFkYXRhXFxuICAgICAgaWYgKC9eKFxcXFwtXFxcXC1cXFxcLXxcXFxcK1xcXFwrXFxcXCt8QEApXFxcXHMvLnRlc3QobGluZSkpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBEaWZmIGluZGV4XFxuICAgICAgdmFyIGhlYWRlciA9IC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFxcXHcrKSspXFxcXHMrKC4rPylcXFxccyokLy5leGVjKGxpbmUpO1xcbiAgICAgIGlmIChoZWFkZXIpIHtcXG4gICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpKys7XFxuICAgIH1cXG5cXG4gICAgLy8gUGFyc2UgZmlsZSBoZWFkZXJzIGlmIHRoZXkgYXJlIGRlZmluZWQuIFVuaWZpZWQgZGlmZiByZXF1aXJlcyB0aGVtLCBidXRcXG4gICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXFxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XFxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XFxuXFxuICAgIC8vIFBhcnNlIGh1bmtzXFxuICAgIGluZGV4Lmh1bmtzID0gW107XFxuXFxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcXG4gICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xcblxcbiAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXFxcLVxcXFwtXFxcXC18XFxcXCtcXFxcK1xcXFwrKVxcXFxzLy50ZXN0KF9saW5lKSkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xcbiAgICAgICAgaW5kZXguaHVua3MucHVzaChwYXJzZUh1bmsoKSk7XFxuICAgICAgfSBlbHNlIGlmIChfbGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xcbiAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsaW5lICcgKyAoaSArIDEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoX2xpbmUpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaSsrO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcXG4gIC8vIGFyZSBjb25zdW1lZC5cXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xcbiAgICB2YXIgaGVhZGVyUGF0dGVybiA9IC9eKC0tLXxcXFxcK1xcXFwrXFxcXCspXFxcXHMrKFtcXFxcUyBdKikoPzpcXFxcdCguKj8pXFxcXHMqKT8kLztcXG4gICAgdmFyIGZpbGVIZWFkZXIgPSBoZWFkZXJQYXR0ZXJuLmV4ZWMoZGlmZnN0cltpXSk7XFxuICAgIGlmIChmaWxlSGVhZGVyKSB7XFxuICAgICAgdmFyIGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcXG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVIZWFkZXJbMl07XFxuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0hlYWRlciddID0gZmlsZUhlYWRlclszXTtcXG5cXG4gICAgICBpKys7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFBhcnNlcyBhIGh1bmtcXG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxcbiAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xcbiAgICB2YXIgY2h1bmtIZWFkZXJJbmRleCA9IGksXFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXFxuICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXFxcZCspKD86LChcXFxcZCspKT8gXFxcXCsoXFxcXGQrKSg/OiwoXFxcXGQrKSk/IEBALyk7XFxuXFxuICAgIHZhciBodW5rID0ge1xcbiAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXFxuICAgICAgb2xkTGluZXM6ICtjaHVua0hlYWRlclsyXSB8fCAxLFxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXFxuICAgICAgbmV3TGluZXM6ICtjaHVua0hlYWRlcls0XSB8fCAxLFxcbiAgICAgIGxpbmVzOiBbXSxcXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cXG4gICAgfTtcXG5cXG4gICAgdmFyIGFkZENvdW50ID0gMCxcXG4gICAgICAgIHJlbW92ZUNvdW50ID0gMDtcXG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCAnLS0tJyBjb3VsZCBiZSBtaXN0YWtlbiBmb3IgdGhlIFxcXCJyZW1vdmUgbGluZVxcXCIgb3BlcmF0aW9uXFxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxcbiAgICAgIGlmIChkaWZmc3RyW2ldLmluZGV4T2YoJy0tLSAnKSA9PT0gMCAmJiBpICsgMiA8IGRpZmZzdHIubGVuZ3RoICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMCAmJiBkaWZmc3RyW2kgKyAyXS5pbmRleE9mKCdAQCcpID09PSAwKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgdmFyIG9wZXJhdGlvbiA9IGRpZmZzdHJbaV1bMF07XFxuXFxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFxcXFxcJykge1xcbiAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xcbiAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcXFxuJyk7XFxuXFxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcXG4gICAgICAgICAgYWRkQ291bnQrKztcXG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcXG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcXG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcXG4gICAgICAgICAgYWRkQ291bnQrKztcXG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxcbiAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcXG4gICAgICBodW5rLm5ld0xpbmVzID0gMDtcXG4gICAgfVxcbiAgICBpZiAoIXJlbW92ZUNvdW50ICYmIGh1bmsub2xkTGluZXMgPT09IDEpIHtcXG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcXG4gICAgfVxcblxcbiAgICAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcXG4gICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xcbiAgICAgIH1cXG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBodW5rO1xcbiAgfVxcblxcbiAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcbiAgICBwYXJzZUluZGV4KCk7XFxuICB9XFxuXFxuICByZXR1cm4gbGlzdDtcXG59XFxuXFxuXFxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIChzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xcbiAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxcbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcXG4gICAgICBsb2NhbE9mZnNldCA9IDE7XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XFxuICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xcbiAgICAgICAgbG9jYWxPZmZzZXQrKztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcXG4gICAgICAvLyBhZnRlciBvZmZzZXQgbG9jYXRpb24gKG9yIGRlc2lyZWQgbG9jYXRpb24gb24gZmlyc3QgaXRlcmF0aW9uKVxcbiAgICAgIGlmIChzdGFydCArIGxvY2FsT2Zmc2V0IDw9IG1heExpbmUpIHtcXG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xcbiAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xcbiAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJlZm9yZSB0ZXh0IGJlZ2lubmluZywgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cXG4gICAgICBpZiAobWluTGluZSA8PSBzdGFydCAtIGxvY2FsT2Zmc2V0KSB7XFxuICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XFxuICAgICAgfVxcblxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcXG4gICAgfVxcblxcbiAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmdodCwgdGhlblxcbiAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxcbiAgfTtcXG59O1xcblxcblxcbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9nZW5lcmF0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnM7XFxuZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XFxuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXG4gICAgICAgIGRlZmF1bHRzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkZWZhdWx0cztcXG59XFxuXFxuXFxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFxcXFxce30oKVtcXFxcXV4kKyo/Ll0vZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcXG5cXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcXG5cXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgJ1xcXFxcXFxcJCYnKTtcXG59O1xcblxcbn0se31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XFxuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XFxuXFxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXFxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xcblxcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xcbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuXFxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXFxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XFxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XFxuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXFxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXFxcImVycm9yXFxcIiBldmVudC4gKCcgKyBlciArICcpJyk7XFxuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xcbiAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcXG4gICAgcmV0dXJuIGZhbHNlO1xcblxcbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgLy8gZmFzdCBjYXNlc1xcbiAgICAgIGNhc2UgMTpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMjpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAzOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIC8vIHNsb3dlclxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcXG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICB2YXIgbTtcXG5cXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuXFxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcXFwibmV3TGlzdGVuZXJcXFwiISBCZWZvcmVcXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFxcXCJuZXdMaXN0ZW5lclxcXCIuXFxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcXG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXFxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xcbiAgZWxzZVxcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xcblxcbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XFxuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xcbiAgICB9XFxuXFxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XFxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XFxuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXFxuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XFxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgdmFyIGZpcmVkID0gZmFsc2U7XFxuXFxuICBmdW5jdGlvbiBnKCkge1xcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xcblxcbiAgICBpZiAoIWZpcmVkKSB7XFxuICAgICAgZmlyZWQgPSB0cnVlO1xcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcXG4gIHRoaXMub24odHlwZSwgZyk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcXG5cXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcXG4gIHBvc2l0aW9uID0gLTE7XFxuXFxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcXG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcXG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xcblxcbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XFxuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xcbiAgICAgICAgcG9zaXRpb24gPSBpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChwb3NpdGlvbiA8IDApXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXFxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XFxuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XFxuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XFxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcXG4gICAgfVxcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XFxuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xcbiAgICAvLyBMSUZPIG9yZGVyXFxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XFxuICB9XFxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciByZXQ7XFxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICByZXQgPSBbXTtcXG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XFxuICBlbHNlXFxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIGlmICh0aGlzLl9ldmVudHMpIHtcXG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxcbiAgICAgIHJldHVybiAxO1xcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcXG4gIH1cXG4gIHJldHVybiAwO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xcbn07XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuXFxufSx7fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLy8gR3Jvd2wgLSBDb3B5cmlnaHQgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT4gKE1JVCBMaWNlbnNlZClcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNcXG4gICwgZnMgPSByZXF1aXJlKCdmcycpXFxuICAsIHBhdGggPSByZXF1aXJlKCdwYXRoJylcXG4gICwgZXhpc3RzID0gZnMuZXhpc3RzU3luYyB8fCBwYXRoLmV4aXN0c1N5bmNcXG4gICwgb3MgPSByZXF1aXJlKCdvcycpXFxuICAsIHF1b3RlID0gSlNPTi5zdHJpbmdpZnlcXG4gICwgY21kO1xcblxcbmZ1bmN0aW9uIHdoaWNoKG5hbWUpIHtcXG4gIHZhciBwYXRocyA9IHByb2Nlc3MuZW52LlBBVEguc3BsaXQoJzonKTtcXG4gIHZhciBsb2M7XFxuXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgbG9jID0gcGF0aC5qb2luKHBhdGhzW2ldLCBuYW1lKTtcXG4gICAgaWYgKGV4aXN0cyhsb2MpKSByZXR1cm4gbG9jO1xcbiAgfVxcbn1cXG5cXG5zd2l0Y2gob3MudHlwZSgpKSB7XFxuICBjYXNlICdEYXJ3aW4nOlxcbiAgICBpZiAod2hpY2goJ3Rlcm1pbmFsLW5vdGlmaWVyJykpIHtcXG4gICAgICBjbWQgPSB7XFxuICAgICAgICAgIHR5cGU6IFxcXCJEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyXFxcIlxcbiAgICAgICAgLCBwa2c6IFxcXCJ0ZXJtaW5hbC1ub3RpZmllclxcXCJcXG4gICAgICAgICwgbXNnOiAnLW1lc3NhZ2UnXFxuICAgICAgICAsIHRpdGxlOiAnLXRpdGxlJ1xcbiAgICAgICAgLCBzdWJ0aXRsZTogJy1zdWJ0aXRsZSdcXG4gICAgICAgICwgaWNvbjogJy1hcHBJY29uJ1xcbiAgICAgICAgLCBzb3VuZDogICctc291bmQnXFxuICAgICAgICAsIHVybDogJy1vcGVuJ1xcbiAgICAgICAgLCBwcmlvcml0eToge1xcbiAgICAgICAgICAgICAgY21kOiAnLWV4ZWN1dGUnXFxuICAgICAgICAgICAgLCByYW5nZTogW11cXG4gICAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY21kID0ge1xcbiAgICAgICAgICB0eXBlOiBcXFwiRGFyd2luLUdyb3dsXFxcIlxcbiAgICAgICAgLCBwa2c6IFxcXCJncm93bG5vdGlmeVxcXCJcXG4gICAgICAgICwgbXNnOiAnLW0nXFxuICAgICAgICAsIHN0aWNreTogJy0tc3RpY2t5J1xcbiAgICAgICAgLCBwcmlvcml0eToge1xcbiAgICAgICAgICAgICAgY21kOiAnLS1wcmlvcml0eSdcXG4gICAgICAgICAgICAsIHJhbmdlOiBbXFxuICAgICAgICAgICAgICAgIC0yXFxuICAgICAgICAgICAgICAsIC0xXFxuICAgICAgICAgICAgICAsIDBcXG4gICAgICAgICAgICAgICwgMVxcbiAgICAgICAgICAgICAgLCAyXFxuICAgICAgICAgICAgICAsIFxcXCJWZXJ5IExvd1xcXCJcXG4gICAgICAgICAgICAgICwgXFxcIk1vZGVyYXRlXFxcIlxcbiAgICAgICAgICAgICAgLCBcXFwiTm9ybWFsXFxcIlxcbiAgICAgICAgICAgICAgLCBcXFwiSGlnaFxcXCJcXG4gICAgICAgICAgICAgICwgXFxcIkVtZXJnZW5jeVxcXCJcXG4gICAgICAgICAgICBdXFxuICAgICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGJyZWFrO1xcbiAgY2FzZSAnTGludXgnOlxcbiAgICBpZiAod2hpY2goJ2dyb3dsJykpIHtcXG4gICAgICBjbWQgPSB7XFxuICAgICAgICAgIHR5cGU6IFxcXCJMaW51eC1Hcm93bFxcXCJcXG4gICAgICAgICwgcGtnOiBcXFwiZ3Jvd2xcXFwiXFxuICAgICAgICAsIG1zZzogJy1tJ1xcbiAgICAgICAgLCB0aXRsZTogJy10aXRsZSdcXG4gICAgICAgICwgc3VidGl0bGU6ICctc3VidGl0bGUnXFxuICAgICAgICAsIGhvc3Q6IHtcXG4gICAgICAgICAgICBjbWQ6ICctSCdcXG4gICAgICAgICAgLCBob3N0bmFtZTogJzE5Mi4xNjguMzMuMSdcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNtZCA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcIkxpbnV4XFxcIlxcbiAgICAgICAgLCBwa2c6IFxcXCJub3RpZnktc2VuZFxcXCJcXG4gICAgICAgICwgbXNnOiAnJ1xcbiAgICAgICAgLCBzdGlja3k6ICctdCAwJ1xcbiAgICAgICAgLCBpY29uOiAnLWknXFxuICAgICAgICAsIHByaW9yaXR5OiB7XFxuICAgICAgICAgICAgY21kOiAnLXUnXFxuICAgICAgICAgICwgcmFuZ2U6IFtcXG4gICAgICAgICAgICAgIFxcXCJsb3dcXFwiXFxuICAgICAgICAgICAgLCBcXFwibm9ybWFsXFxcIlxcbiAgICAgICAgICAgICwgXFxcImNyaXRpY2FsXFxcIlxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBicmVhaztcXG4gIGNhc2UgJ1dpbmRvd3NfTlQnOlxcbiAgICBjbWQgPSB7XFxuICAgICAgICB0eXBlOiBcXFwiV2luZG93c1xcXCJcXG4gICAgICAsIHBrZzogXFxcImdyb3dsbm90aWZ5XFxcIlxcbiAgICAgICwgbXNnOiAnJ1xcbiAgICAgICwgc3RpY2t5OiAnL3M6dHJ1ZSdcXG4gICAgICAsIHRpdGxlOiAnL3Q6J1xcbiAgICAgICwgaWNvbjogJy9pOidcXG4gICAgICAsIHVybDogJy9jdTonXFxuICAgICAgLCBwcmlvcml0eToge1xcbiAgICAgICAgICAgIGNtZDogJy9wOidcXG4gICAgICAgICAgLCByYW5nZTogW1xcbiAgICAgICAgICAgICAgLTJcXG4gICAgICAgICAgICAsIC0xXFxuICAgICAgICAgICAgLCAwXFxuICAgICAgICAgICAgLCAxXFxuICAgICAgICAgICAgLCAyXFxuICAgICAgICAgIF1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgYnJlYWs7XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBgZ3Jvd2xgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyb3dsO1xcblxcbi8qKlxcbiAqIE5vZGUtZ3Jvd2wgdmVyc2lvbi5cXG4gKi9cXG5cXG5leHBvcnRzLnZlcnNpb24gPSAnMS40LjEnXFxuXFxuLyoqXFxuICogU2VuZCBncm93bCBub3RpZmljYXRpb24gX21zZ18gd2l0aCBfb3B0aW9uc18uXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogIC0gdGl0bGUgICBOb3RpZmljYXRpb24gdGl0bGVcXG4gKiAgLSBzdGlja3kgIE1ha2UgdGhlIG5vdGlmaWNhdGlvbiBzdGljayAoZGVmYXVsdHMgdG8gZmFsc2UpXFxuICogIC0gcHJpb3JpdHkgIFNwZWNpZnkgYW4gaW50IG9yIG5hbWVkIGtleSAoZGVmYXVsdCBpcyAwKVxcbiAqICAtIG5hbWUgICAgQXBwbGljYXRpb24gbmFtZSAoZGVmYXVsdHMgdG8gZ3Jvd2xub3RpZnkpXFxuICogIC0gc291bmQgICBTb3VuZCBlZmVjdCAoIGluIE9TeCBkZWZpbmVkIGluIHByZWZlcmVuY2VzIC0+IHNvdW5kIC0+IGVmZmVjdHMpICogd29ya3Mgb25seSBpbiBPU1ggPiAxMC44eFxcbiAqICAtIGltYWdlXFxuICogICAgLSBwYXRoIHRvIGFuIGljb24gc2V0cyAtLWljb25wYXRoXFxuICogICAgLSBwYXRoIHRvIGFuIGltYWdlIHNldHMgLS1pbWFnZVxcbiAqICAgIC0gY2FwaXRhbGl6ZWQgd29yZCBzZXRzIC0tYXBwSWNvblxcbiAqICAgIC0gZmlsZW5hbWUgdXNlcyBleHRuYW1lIGFzIC0taWNvblxcbiAqICAgIC0gb3RoZXJ3aXNlIHRyZWF0ZWQgYXMgLS1pY29uXFxuICpcXG4gKiBFeGFtcGxlczpcXG4gKlxcbiAqICAgZ3Jvd2woJ05ldyBlbWFpbCcpXFxuICogICBncm93bCgnNSBuZXcgZW1haWxzJywgeyB0aXRsZTogJ1RodW5kZXJiaXJkJyB9KVxcbiAqICAgZ3Jvd2woJzUgbmV3IGVtYWlscycsIHsgdGl0bGU6ICdUaHVuZGVyYmlyZCcsIHNvdW5kOiAnUHVycicgfSlcXG4gKiAgIGdyb3dsKCdFbWFpbCBzZW50JywgZnVuY3Rpb24oKXtcXG4gKiAgICAgLy8gLi4uIG5vdGlmaWNhdGlvbiBzZW50XFxuICogICB9KVxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGdyb3dsKG1zZywgb3B0aW9ucywgZm4pIHtcXG4gIHZhciBpbWFnZVxcbiAgICAsIGFyZ3NcXG4gICAgLCBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxcbiAgICAsIGZuID0gZm4gfHwgZnVuY3Rpb24oKXt9O1xcblxcbiAgaWYgKG9wdGlvbnMuZXhlYykge1xcbiAgICBjbWQgPSB7XFxuICAgICAgICB0eXBlOiBcXFwiQ3VzdG9tXFxcIlxcbiAgICAgICwgcGtnOiBvcHRpb25zLmV4ZWNcXG4gICAgICAsIHJhbmdlOiBbXVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gbm9vcFxcbiAgaWYgKCFjbWQpIHJldHVybiBmbihuZXcgRXJyb3IoJ2dyb3dsIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybScpKTtcXG4gIGFyZ3MgPSBbY21kLnBrZ107XFxuXFxuICAvLyBpbWFnZVxcbiAgaWYgKGltYWdlID0gb3B0aW9ucy5pbWFnZSkge1xcbiAgICBzd2l0Y2goY21kLnR5cGUpIHtcXG4gICAgICBjYXNlICdEYXJ3aW4tR3Jvd2wnOlxcbiAgICAgICAgdmFyIGZsYWcsIGV4dCA9IHBhdGguZXh0bmFtZShpbWFnZSkuc3Vic3RyKDEpXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCBleHQgPT0gJ2ljbnMnICYmICdpY29ucGF0aCdcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8IC9eW0EtWl0vLnRlc3QoaW1hZ2UpICYmICdhcHBJY29uJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgL15wbmd8Z2lmfGpwZT9nJC8udGVzdChleHQpICYmICdpbWFnZSdcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8IGV4dCAmJiAoaW1hZ2UgPSBleHQpICYmICdpY29uJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgJ2ljb24nXFxuICAgICAgICBhcmdzLnB1c2goJy0tJyArIGZsYWcsIHF1b3RlKGltYWdlKSlcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ0Rhcndpbi1Ob3RpZmljYXRpb25DZW50ZXInOlxcbiAgICAgICAgYXJncy5wdXNoKGNtZC5pY29uLCBxdW90ZShpbWFnZSkpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnTGludXgnOlxcbiAgICAgICAgYXJncy5wdXNoKGNtZC5pY29uLCBxdW90ZShpbWFnZSkpO1xcbiAgICAgICAgLy8gbGlibm90aWZ5IGRlZmF1bHRzIHRvIHN0aWNreSwgc2V0IGEgaGludCBmb3IgdHJhbnNpZW50IG5vdGlmaWNhdGlvbnNcXG4gICAgICAgIGlmICghb3B0aW9ucy5zdGlja3kpIGFyZ3MucHVzaCgnLS1oaW50PWludDp0cmFuc2llbnQ6MScpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnV2luZG93cyc6XFxuICAgICAgICBhcmdzLnB1c2goY21kLmljb24gKyBxdW90ZShpbWFnZSkpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIHN0aWNreVxcbiAgaWYgKG9wdGlvbnMuc3RpY2t5KSBhcmdzLnB1c2goY21kLnN0aWNreSk7XFxuXFxuICAvLyBwcmlvcml0eVxcbiAgaWYgKG9wdGlvbnMucHJpb3JpdHkpIHtcXG4gICAgdmFyIHByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eSArICcnO1xcbiAgICB2YXIgY2hlY2tpbmRleE9mID0gY21kLnByaW9yaXR5LnJhbmdlLmluZGV4T2YocHJpb3JpdHkpO1xcbiAgICBpZiAofmNtZC5wcmlvcml0eS5yYW5nZS5pbmRleE9mKHByaW9yaXR5KSkge1xcbiAgICAgIGFyZ3MucHVzaChjbWQucHJpb3JpdHksIG9wdGlvbnMucHJpb3JpdHkpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvL3NvdW5kXFxuICBpZihvcHRpb25zLnNvdW5kICYmIGNtZC50eXBlID09PSAnRGFyd2luLU5vdGlmaWNhdGlvbkNlbnRlcicpe1xcbiAgICBhcmdzLnB1c2goY21kLnNvdW5kLCBvcHRpb25zLnNvdW5kKVxcbiAgfVxcblxcbiAgLy8gbmFtZVxcbiAgaWYgKG9wdGlvbnMubmFtZSAmJiBjbWQudHlwZSA9PT0gXFxcIkRhcndpbi1Hcm93bFxcXCIpIHtcXG4gICAgYXJncy5wdXNoKCctLW5hbWUnLCBvcHRpb25zLm5hbWUpO1xcbiAgfVxcblxcbiAgc3dpdGNoKGNtZC50eXBlKSB7XFxuICAgIGNhc2UgJ0Rhcndpbi1Hcm93bCc6XFxuICAgICAgYXJncy5wdXNoKGNtZC5tc2cpO1xcbiAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKSk7XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ0Rhcndpbi1Ob3RpZmljYXRpb25DZW50ZXInOlxcbiAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICB2YXIgc3RyaW5naWZpZWRNc2cgPSBxdW90ZShtc2cpO1xcbiAgICAgIHZhciBlc2NhcGVkTXNnID0gc3RyaW5naWZpZWRNc2cucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpO1xcbiAgICAgIGFyZ3MucHVzaChlc2NhcGVkTXNnKTtcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xcbiAgICAgICAgYXJncy5wdXNoKGNtZC50aXRsZSk7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIH1cXG4gICAgICBpZiAob3B0aW9ucy5zdWJ0aXRsZSkge1xcbiAgICAgICAgYXJncy5wdXNoKGNtZC5zdWJ0aXRsZSk7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy5zdWJ0aXRsZSkpO1xcbiAgICAgIH1cXG4gICAgICBpZiAob3B0aW9ucy51cmwpIHtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQudXJsKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnVybCkpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnTGludXgtR3Jvd2wnOlxcbiAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICBhcmdzLnB1c2gocXVvdGUobXNnKS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIGlmIChjbWQuaG9zdCkge1xcbiAgICAgICAgYXJncy5wdXNoKGNtZC5ob3N0LmNtZCwgY21kLmhvc3QuaG9zdG5hbWUpXFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdMaW51eCc6XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUobXNnKS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhcmdzLnB1c2gocXVvdGUobXNnKS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJykpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnV2luZG93cyc6XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpKTtcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkgYXJncy5wdXNoKGNtZC50aXRsZSArIHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICBpZiAob3B0aW9ucy51cmwpIGFyZ3MucHVzaChjbWQudXJsICsgcXVvdGUob3B0aW9ucy51cmwpKTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnQ3VzdG9tJzpcXG4gICAgICBhcmdzWzBdID0gKGZ1bmN0aW9uKG9yaWdDb21tYW5kKSB7XFxuICAgICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMudGl0bGVcXG4gICAgICAgICAgPyBvcHRpb25zLnRpdGxlICsgJzogJyArIG1zZ1xcbiAgICAgICAgICA6IG1zZztcXG4gICAgICAgIHZhciBjb21tYW5kID0gb3JpZ0NvbW1hbmQucmVwbGFjZSgvKF58W14lXSklcy9nLCAnJDEnICsgcXVvdGUobWVzc2FnZSkpO1xcbiAgICAgICAgaWYgKGNvbW1hbmQgPT09IG9yaWdDb21tYW5kKSBhcmdzLnB1c2gocXVvdGUobWVzc2FnZSkpO1xcbiAgICAgICAgcmV0dXJuIGNvbW1hbmQ7XFxuICAgICAgfSkoYXJnc1swXSk7XFxuICAgICAgYnJlYWs7XFxuICB9XFxuXFxuICAvLyBleGVjdXRlXFxuICBleGVjKGFyZ3Muam9pbignICcpLCBmbik7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJjaGlsZF9wcm9jZXNzXFxcIjo0MixcXFwiZnNcXFwiOjQyLFxcXCJvc1xcXCI6ODAsXFxcInBhdGhcXFwiOjQyfV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKiEgaHR0cHM6Ly9tdGhzLmJlL2hlIHYxLjEuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXFxuOyhmdW5jdGlvbihyb290KSB7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYC5cXG5cXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xcblxcblxcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxcblxcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcXG5cXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YC5cXG5cXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xcblxcdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xcblxcdFxcdHJvb3QgPSBmcmVlR2xvYmFsO1xcblxcdH1cXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHQvLyBBbGwgYXN0cmFsIHN5bWJvbHMuXFxuXFx0dmFyIHJlZ2V4QXN0cmFsU3ltYm9scyA9IC9bXFxcXHVEODAwLVxcXFx1REJGRl1bXFxcXHVEQzAwLVxcXFx1REZGRl0vZztcXG5cXHQvLyBBbGwgQVNDSUkgc3ltYm9scyAobm90IGp1c3QgcHJpbnRhYmxlIEFTQ0lJKSBleGNlcHQgdGhvc2UgbGlzdGVkIGluIHRoZVxcblxcdC8vIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlLlxcblxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzXFxuXFx0dmFyIHJlZ2V4QXNjaWlXaGl0ZWxpc3QgPSAvW1xcXFx4MDEtXFxcXHg3Rl0vZztcXG5cXHQvLyBBbGwgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IEFTQ0lJIG5ld2xpbmVzLCBwcmludGFibGUgQVNDSUkgc3ltYm9scywgb3JcXG5cXHQvLyBjb2RlIHBvaW50cyBsaXN0ZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlIG9uXFxuXFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXMuXFxuXFx0dmFyIHJlZ2V4Qm1wV2hpdGVsaXN0ID0gL1tcXFxceDAxLVxcXFx0XFxcXHgwQlxcXFxmXFxcXHgwRS1cXFxceDFGXFxcXHg3RlxcXFx4ODFcXFxceDhEXFxcXHg4RlxcXFx4OTBcXFxceDlEXFxcXHhBMC1cXFxcdUZGRkZdL2c7XFxuXFxuXFx0dmFyIHJlZ2V4RW5jb2RlTm9uQXNjaWkgPSAvPFxcXFx1MjBEMnw9XFxcXHUyMEU1fD5cXFxcdTIwRDJ8XFxcXHUyMDVGXFxcXHUyMDBBfFxcXFx1MjE5RFxcXFx1MDMzOHxcXFxcdTIyMDJcXFxcdTAzMzh8XFxcXHUyMjIwXFxcXHUyMEQyfFxcXFx1MjIyOVxcXFx1RkUwMHxcXFxcdTIyMkFcXFxcdUZFMDB8XFxcXHUyMjNDXFxcXHUyMEQyfFxcXFx1MjIzRFxcXFx1MDMzMXxcXFxcdTIyM0VcXFxcdTAzMzN8XFxcXHUyMjQyXFxcXHUwMzM4fFxcXFx1MjI0QlxcXFx1MDMzOHxcXFxcdTIyNERcXFxcdTIwRDJ8XFxcXHUyMjRFXFxcXHUwMzM4fFxcXFx1MjI0RlxcXFx1MDMzOHxcXFxcdTIyNTBcXFxcdTAzMzh8XFxcXHUyMjYxXFxcXHUyMEU1fFxcXFx1MjI2NFxcXFx1MjBEMnxcXFxcdTIyNjVcXFxcdTIwRDJ8XFxcXHUyMjY2XFxcXHUwMzM4fFxcXFx1MjI2N1xcXFx1MDMzOHxcXFxcdTIyNjhcXFxcdUZFMDB8XFxcXHUyMjY5XFxcXHVGRTAwfFxcXFx1MjI2QVxcXFx1MDMzOHxcXFxcdTIyNkFcXFxcdTIwRDJ8XFxcXHUyMjZCXFxcXHUwMzM4fFxcXFx1MjI2QlxcXFx1MjBEMnxcXFxcdTIyN0ZcXFxcdTAzMzh8XFxcXHUyMjgyXFxcXHUyMEQyfFxcXFx1MjI4M1xcXFx1MjBEMnxcXFxcdTIyOEFcXFxcdUZFMDB8XFxcXHUyMjhCXFxcXHVGRTAwfFxcXFx1MjI4RlxcXFx1MDMzOHxcXFxcdTIyOTBcXFxcdTAzMzh8XFxcXHUyMjkzXFxcXHVGRTAwfFxcXFx1MjI5NFxcXFx1RkUwMHxcXFxcdTIyQjRcXFxcdTIwRDJ8XFxcXHUyMkI1XFxcXHUyMEQyfFxcXFx1MjJEOFxcXFx1MDMzOHxcXFxcdTIyRDlcXFxcdTAzMzh8XFxcXHUyMkRBXFxcXHVGRTAwfFxcXFx1MjJEQlxcXFx1RkUwMHxcXFxcdTIyRjVcXFxcdTAzMzh8XFxcXHUyMkY5XFxcXHUwMzM4fFxcXFx1MjkzM1xcXFx1MDMzOHxcXFxcdTI5Q0ZcXFxcdTAzMzh8XFxcXHUyOUQwXFxcXHUwMzM4fFxcXFx1MkE2RFxcXFx1MDMzOHxcXFxcdTJBNzBcXFxcdTAzMzh8XFxcXHUyQTdEXFxcXHUwMzM4fFxcXFx1MkE3RVxcXFx1MDMzOHxcXFxcdTJBQTFcXFxcdTAzMzh8XFxcXHUyQUEyXFxcXHUwMzM4fFxcXFx1MkFBQ1xcXFx1RkUwMHxcXFxcdTJBQURcXFxcdUZFMDB8XFxcXHUyQUFGXFxcXHUwMzM4fFxcXFx1MkFCMFxcXFx1MDMzOHxcXFxcdTJBQzVcXFxcdTAzMzh8XFxcXHUyQUM2XFxcXHUwMzM4fFxcXFx1MkFDQlxcXFx1RkUwMHxcXFxcdTJBQ0NcXFxcdUZFMDB8XFxcXHUyQUZEXFxcXHUyMEU1fFtcXFxceEEwLVxcXFx1MDExM1xcXFx1MDExNi1cXFxcdTAxMjJcXFxcdTAxMjQtXFxcXHUwMTJCXFxcXHUwMTJFLVxcXFx1MDE0RFxcXFx1MDE1MC1cXFxcdTAxN0VcXFxcdTAxOTJcXFxcdTAxQjVcXFxcdTAxRjVcXFxcdTAyMzdcXFxcdTAyQzZcXFxcdTAyQzdcXFxcdTAyRDgtXFxcXHUwMkREXFxcXHUwMzExXFxcXHUwMzkxLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzQTlcXFxcdTAzQjEtXFxcXHUwM0M5XFxcXHUwM0QxXFxcXHUwM0QyXFxcXHUwM0Q1XFxcXHUwM0Q2XFxcXHUwM0RDXFxcXHUwM0REXFxcXHUwM0YwXFxcXHUwM0YxXFxcXHUwM0Y1XFxcXHUwM0Y2XFxcXHUwNDAxLVxcXFx1MDQwQ1xcXFx1MDQwRS1cXFxcdTA0NEZcXFxcdTA0NTEtXFxcXHUwNDVDXFxcXHUwNDVFXFxcXHUwNDVGXFxcXHUyMDAyLVxcXFx1MjAwNVxcXFx1MjAwNy1cXFxcdTIwMTBcXFxcdTIwMTMtXFxcXHUyMDE2XFxcXHUyMDE4LVxcXFx1MjAxQVxcXFx1MjAxQy1cXFxcdTIwMUVcXFxcdTIwMjAtXFxcXHUyMDIyXFxcXHUyMDI1XFxcXHUyMDI2XFxcXHUyMDMwLVxcXFx1MjAzNVxcXFx1MjAzOVxcXFx1MjAzQVxcXFx1MjAzRVxcXFx1MjA0MVxcXFx1MjA0M1xcXFx1MjA0NFxcXFx1MjA0RlxcXFx1MjA1N1xcXFx1MjA1Ri1cXFxcdTIwNjNcXFxcdTIwQUNcXFxcdTIwREJcXFxcdTIwRENcXFxcdTIxMDJcXFxcdTIxMDVcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1LVxcXFx1MjExRVxcXFx1MjEyMlxcXFx1MjEyNFxcXFx1MjEyNy1cXFxcdTIxMjlcXFxcdTIxMkNcXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTMxXFxcXHUyMTMzLVxcXFx1MjEzOFxcXFx1MjE0NS1cXFxcdTIxNDhcXFxcdTIxNTMtXFxcXHUyMTVFXFxcXHUyMTkwLVxcXFx1MjE5QlxcXFx1MjE5RC1cXFxcdTIxQTdcXFxcdTIxQTktXFxcXHUyMUFFXFxcXHUyMUIwLVxcXFx1MjFCM1xcXFx1MjFCNS1cXFxcdTIxQjdcXFxcdTIxQkEtXFxcXHUyMURCXFxcXHUyMUREXFxcXHUyMUU0XFxcXHUyMUU1XFxcXHUyMUY1XFxcXHUyMUZELVxcXFx1MjIwNVxcXFx1MjIwNy1cXFxcdTIyMDlcXFxcdTIyMEJcXFxcdTIyMENcXFxcdTIyMEYtXFxcXHUyMjE0XFxcXHUyMjE2LVxcXFx1MjIxOFxcXFx1MjIxQVxcXFx1MjIxRC1cXFxcdTIyMzhcXFxcdTIyM0EtXFxcXHUyMjU3XFxcXHUyMjU5XFxcXHUyMjVBXFxcXHUyMjVDXFxcXHUyMjVGLVxcXFx1MjI2MlxcXFx1MjI2NC1cXFxcdTIyOEJcXFxcdTIyOEQtXFxcXHUyMjlCXFxcXHUyMjlELVxcXFx1MjJBNVxcXFx1MjJBNy1cXFxcdTIyQjBcXFxcdTIyQjItXFxcXHUyMkJCXFxcXHUyMkJELVxcXFx1MjJEQlxcXFx1MjJERS1cXFxcdTIyRTNcXFxcdTIyRTYtXFxcXHUyMkY3XFxcXHUyMkY5LVxcXFx1MjJGRVxcXFx1MjMwNVxcXFx1MjMwNlxcXFx1MjMwOC1cXFxcdTIzMTBcXFxcdTIzMTJcXFxcdTIzMTNcXFxcdTIzMTVcXFxcdTIzMTZcXFxcdTIzMUMtXFxcXHUyMzFGXFxcXHUyMzIyXFxcXHUyMzIzXFxcXHUyMzJEXFxcXHUyMzJFXFxcXHUyMzM2XFxcXHUyMzNEXFxcXHUyMzNGXFxcXHUyMzdDXFxcXHUyM0IwXFxcXHUyM0IxXFxcXHUyM0I0LVxcXFx1MjNCNlxcXFx1MjNEQy1cXFxcdTIzREZcXFxcdTIzRTJcXFxcdTIzRTdcXFxcdTI0MjNcXFxcdTI0QzhcXFxcdTI1MDBcXFxcdTI1MDJcXFxcdTI1MENcXFxcdTI1MTBcXFxcdTI1MTRcXFxcdTI1MThcXFxcdTI1MUNcXFxcdTI1MjRcXFxcdTI1MkNcXFxcdTI1MzRcXFxcdTI1M0NcXFxcdTI1NTAtXFxcXHUyNTZDXFxcXHUyNTgwXFxcXHUyNTg0XFxcXHUyNTg4XFxcXHUyNTkxLVxcXFx1MjU5M1xcXFx1MjVBMVxcXFx1MjVBQVxcXFx1MjVBQlxcXFx1MjVBRFxcXFx1MjVBRVxcXFx1MjVCMVxcXFx1MjVCMy1cXFxcdTI1QjVcXFxcdTI1QjhcXFxcdTI1QjlcXFxcdTI1QkQtXFxcXHUyNUJGXFxcXHUyNUMyXFxcXHUyNUMzXFxcXHUyNUNBXFxcXHUyNUNCXFxcXHUyNUVDXFxcXHUyNUVGXFxcXHUyNUY4LVxcXFx1MjVGQ1xcXFx1MjYwNVxcXFx1MjYwNlxcXFx1MjYwRVxcXFx1MjY0MFxcXFx1MjY0MlxcXFx1MjY2MFxcXFx1MjY2M1xcXFx1MjY2NVxcXFx1MjY2NlxcXFx1MjY2QVxcXFx1MjY2RC1cXFxcdTI2NkZcXFxcdTI3MTNcXFxcdTI3MTdcXFxcdTI3MjBcXFxcdTI3MzZcXFxcdTI3NThcXFxcdTI3NzJcXFxcdTI3NzNcXFxcdTI3QzhcXFxcdTI3QzlcXFxcdTI3RTYtXFxcXHUyN0VEXFxcXHUyN0Y1LVxcXFx1MjdGQVxcXFx1MjdGQ1xcXFx1MjdGRlxcXFx1MjkwMi1cXFxcdTI5MDVcXFxcdTI5MEMtXFxcXHUyOTEzXFxcXHUyOTE2XFxcXHUyOTE5LVxcXFx1MjkyMFxcXFx1MjkyMy1cXFxcdTI5MkFcXFxcdTI5MzNcXFxcdTI5MzUtXFxcXHUyOTM5XFxcXHUyOTNDXFxcXHUyOTNEXFxcXHUyOTQ1XFxcXHUyOTQ4LVxcXFx1Mjk0QlxcXFx1Mjk0RS1cXFxcdTI5NzZcXFxcdTI5NzhcXFxcdTI5NzlcXFxcdTI5N0ItXFxcXHUyOTdGXFxcXHUyOTg1XFxcXHUyOTg2XFxcXHUyOThCLVxcXFx1Mjk5NlxcXFx1Mjk5QVxcXFx1Mjk5Q1xcXFx1Mjk5RFxcXFx1MjlBNC1cXFxcdTI5QjdcXFxcdTI5QjlcXFxcdTI5QkJcXFxcdTI5QkNcXFxcdTI5QkUtXFxcXHUyOUM1XFxcXHUyOUM5XFxcXHUyOUNELVxcXFx1MjlEMFxcXFx1MjlEQy1cXFxcdTI5REVcXFxcdTI5RTMtXFxcXHUyOUU1XFxcXHUyOUVCXFxcXHUyOUY0XFxcXHUyOUY2XFxcXHUyQTAwLVxcXFx1MkEwMlxcXFx1MkEwNFxcXFx1MkEwNlxcXFx1MkEwQ1xcXFx1MkEwRFxcXFx1MkExMC1cXFxcdTJBMTdcXFxcdTJBMjItXFxcXHUyQTI3XFxcXHUyQTI5XFxcXHUyQTJBXFxcXHUyQTJELVxcXFx1MkEzMVxcXFx1MkEzMy1cXFxcdTJBM0NcXFxcdTJBM0ZcXFxcdTJBNDBcXFxcdTJBNDItXFxcXHUyQTREXFxcXHUyQTUwXFxcXHUyQTUzLVxcXFx1MkE1OFxcXFx1MkE1QS1cXFxcdTJBNURcXFxcdTJBNUZcXFxcdTJBNjZcXFxcdTJBNkFcXFxcdTJBNkQtXFxcXHUyQTc1XFxcXHUyQTc3LVxcXFx1MkE5QVxcXFx1MkE5RC1cXFxcdTJBQTJcXFxcdTJBQTQtXFxcXHUyQUIwXFxcXHUyQUIzLVxcXFx1MkFDOFxcXFx1MkFDQlxcXFx1MkFDQ1xcXFx1MkFDRi1cXFxcdTJBREJcXFxcdTJBRTRcXFxcdTJBRTYtXFxcXHUyQUU5XFxcXHUyQUVCLVxcXFx1MkFGM1xcXFx1MkFGRFxcXFx1RkIwMC1cXFxcdUZCMDRdfFxcXFx1RDgzNVtcXFxcdURDOUNcXFxcdURDOUVcXFxcdURDOUZcXFxcdURDQTJcXFxcdURDQTVcXFxcdURDQTZcXFxcdURDQTktXFxcXHVEQ0FDXFxcXHVEQ0FFLVxcXFx1RENCOVxcXFx1RENCQlxcXFx1RENCRC1cXFxcdURDQzNcXFxcdURDQzUtXFxcXHVEQ0NGXFxcXHVERDA0XFxcXHVERDA1XFxcXHVERDA3LVxcXFx1REQwQVxcXFx1REQwRC1cXFxcdUREMTRcXFxcdUREMTYtXFxcXHVERDFDXFxcXHVERDFFLVxcXFx1REQzOVxcXFx1REQzQi1cXFxcdUREM0VcXFxcdURENDAtXFxcXHVERDQ0XFxcXHVERDQ2XFxcXHVERDRBLVxcXFx1REQ1MFxcXFx1REQ1Mi1cXFxcdURENkJdL2c7XFxuXFx0dmFyIGVuY29kZU1hcCA9IHsnXFxcXHhBRCc6J3NoeScsJ1xcXFx1MjAwQyc6J3p3bmonLCdcXFxcdTIwMEQnOid6d2onLCdcXFxcdTIwMEUnOidscm0nLCdcXFxcdTIwNjMnOidpYycsJ1xcXFx1MjA2Mic6J2l0JywnXFxcXHUyMDYxJzonYWYnLCdcXFxcdTIwMEYnOidybG0nLCdcXFxcdTIwMEInOidaZXJvV2lkdGhTcGFjZScsJ1xcXFx1MjA2MCc6J05vQnJlYWsnLCdcXFxcdTAzMTEnOidEb3duQnJldmUnLCdcXFxcdTIwREInOid0ZG90JywnXFxcXHUyMERDJzonRG90RG90JywnXFxcXHQnOidUYWInLCdcXFxcbic6J05ld0xpbmUnLCdcXFxcdTIwMDgnOidwdW5jc3AnLCdcXFxcdTIwNUYnOidNZWRpdW1TcGFjZScsJ1xcXFx1MjAwOSc6J3RoaW5zcCcsJ1xcXFx1MjAwQSc6J2hhaXJzcCcsJ1xcXFx1MjAwNCc6J2Vtc3AxMycsJ1xcXFx1MjAwMic6J2Vuc3AnLCdcXFxcdTIwMDUnOidlbXNwMTQnLCdcXFxcdTIwMDMnOidlbXNwJywnXFxcXHUyMDA3JzonbnVtc3AnLCdcXFxceEEwJzonbmJzcCcsJ1xcXFx1MjA1RlxcXFx1MjAwQSc6J1RoaWNrU3BhY2UnLCdcXFxcdTIwM0UnOidvbGluZScsJ18nOidsb3diYXInLCdcXFxcdTIwMTAnOidkYXNoJywnXFxcXHUyMDEzJzonbmRhc2gnLCdcXFxcdTIwMTQnOidtZGFzaCcsJ1xcXFx1MjAxNSc6J2hvcmJhcicsJywnOidjb21tYScsJzsnOidzZW1pJywnXFxcXHUyMDRGJzonYnNlbWknLCc6JzonY29sb24nLCdcXFxcdTJBNzQnOidDb2xvbmUnLCchJzonZXhjbCcsJ1xcXFx4QTEnOidpZXhjbCcsJz8nOidxdWVzdCcsJ1xcXFx4QkYnOidpcXVlc3QnLCcuJzoncGVyaW9kJywnXFxcXHUyMDI1JzonbmxkcicsJ1xcXFx1MjAyNic6J21sZHInLCdcXFxceEI3JzonbWlkZG90JywnXFxcXCcnOidhcG9zJywnXFxcXHUyMDE4JzonbHNxdW8nLCdcXFxcdTIwMTknOidyc3F1bycsJ1xcXFx1MjAxQSc6J3NicXVvJywnXFxcXHUyMDM5JzonbHNhcXVvJywnXFxcXHUyMDNBJzoncnNhcXVvJywnXFxcIic6J3F1b3QnLCdcXFxcdTIwMUMnOidsZHF1bycsJ1xcXFx1MjAxRCc6J3JkcXVvJywnXFxcXHUyMDFFJzonYmRxdW8nLCdcXFxceEFCJzonbGFxdW8nLCdcXFxceEJCJzoncmFxdW8nLCcoJzonbHBhcicsJyknOidycGFyJywnWyc6J2xzcWInLCddJzoncnNxYicsJ3snOidsY3ViJywnfSc6J3JjdWInLCdcXFxcdTIzMDgnOidsY2VpbCcsJ1xcXFx1MjMwOSc6J3JjZWlsJywnXFxcXHUyMzBBJzonbGZsb29yJywnXFxcXHUyMzBCJzoncmZsb29yJywnXFxcXHUyOTg1JzonbG9wYXInLCdcXFxcdTI5ODYnOidyb3BhcicsJ1xcXFx1Mjk4Qic6J2xicmtlJywnXFxcXHUyOThDJzoncmJya2UnLCdcXFxcdTI5OEQnOidsYnJrc2x1JywnXFxcXHUyOThFJzoncmJya3NsZCcsJ1xcXFx1Mjk4Ric6J2xicmtzbGQnLCdcXFxcdTI5OTAnOidyYnJrc2x1JywnXFxcXHUyOTkxJzonbGFuZ2QnLCdcXFxcdTI5OTInOidyYW5nZCcsJ1xcXFx1Mjk5Myc6J2xwYXJsdCcsJ1xcXFx1Mjk5NCc6J3JwYXJndCcsJ1xcXFx1Mjk5NSc6J2d0bFBhcicsJ1xcXFx1Mjk5Nic6J2x0clBhcicsJ1xcXFx1MjdFNic6J2xvYnJrJywnXFxcXHUyN0U3Jzoncm9icmsnLCdcXFxcdTI3RTgnOidsYW5nJywnXFxcXHUyN0U5JzoncmFuZycsJ1xcXFx1MjdFQSc6J0xhbmcnLCdcXFxcdTI3RUInOidSYW5nJywnXFxcXHUyN0VDJzonbG9hbmcnLCdcXFxcdTI3RUQnOidyb2FuZycsJ1xcXFx1Mjc3Mic6J2xiYnJrJywnXFxcXHUyNzczJzoncmJicmsnLCdcXFxcdTIwMTYnOidWZXJ0JywnXFxcXHhBNyc6J3NlY3QnLCdcXFxceEI2JzoncGFyYScsJ0AnOidjb21tYXQnLCcqJzonYXN0JywnLyc6J3NvbCcsJ3VuZGVmaW5lZCc6bnVsbCwnJic6J2FtcCcsJyMnOidudW0nLCclJzoncGVyY250JywnXFxcXHUyMDMwJzoncGVybWlsJywnXFxcXHUyMDMxJzoncGVydGVuaycsJ1xcXFx1MjAyMCc6J2RhZ2dlcicsJ1xcXFx1MjAyMSc6J0RhZ2dlcicsJ1xcXFx1MjAyMic6J2J1bGwnLCdcXFxcdTIwNDMnOidoeWJ1bGwnLCdcXFxcdTIwMzInOidwcmltZScsJ1xcXFx1MjAzMyc6J1ByaW1lJywnXFxcXHUyMDM0JzondHByaW1lJywnXFxcXHUyMDU3JzoncXByaW1lJywnXFxcXHUyMDM1JzonYnByaW1lJywnXFxcXHUyMDQxJzonY2FyZXQnLCdgJzonZ3JhdmUnLCdcXFxceEI0JzonYWN1dGUnLCdcXFxcdTAyREMnOid0aWxkZScsJ14nOidIYXQnLCdcXFxceEFGJzonbWFjcicsJ1xcXFx1MDJEOCc6J2JyZXZlJywnXFxcXHUwMkQ5JzonZG90JywnXFxcXHhBOCc6J2RpZScsJ1xcXFx1MDJEQSc6J3JpbmcnLCdcXFxcdTAyREQnOidkYmxhYycsJ1xcXFx4QjgnOidjZWRpbCcsJ1xcXFx1MDJEQic6J29nb24nLCdcXFxcdTAyQzYnOidjaXJjJywnXFxcXHUwMkM3JzonY2Fyb24nLCdcXFxceEIwJzonZGVnJywnXFxcXHhBOSc6J2NvcHknLCdcXFxceEFFJzoncmVnJywnXFxcXHUyMTE3JzonY29weXNyJywnXFxcXHUyMTE4Jzond3AnLCdcXFxcdTIxMUUnOidyeCcsJ1xcXFx1MjEyNyc6J21obycsJ1xcXFx1MjEyOSc6J2lpb3RhJywnXFxcXHUyMTkwJzonbGFycicsJ1xcXFx1MjE5QSc6J25sYXJyJywnXFxcXHUyMTkyJzoncmFycicsJ1xcXFx1MjE5Qic6J25yYXJyJywnXFxcXHUyMTkxJzondWFycicsJ1xcXFx1MjE5Myc6J2RhcnInLCdcXFxcdTIxOTQnOidoYXJyJywnXFxcXHUyMUFFJzonbmhhcnInLCdcXFxcdTIxOTUnOid2YXJyJywnXFxcXHUyMTk2JzonbndhcnInLCdcXFxcdTIxOTcnOiduZWFycicsJ1xcXFx1MjE5OCc6J3NlYXJyJywnXFxcXHUyMTk5Jzonc3dhcnInLCdcXFxcdTIxOUQnOidyYXJydycsJ1xcXFx1MjE5RFxcXFx1MDMzOCc6J25yYXJydycsJ1xcXFx1MjE5RSc6J0xhcnInLCdcXFxcdTIxOUYnOidVYXJyJywnXFxcXHUyMUEwJzonUmFycicsJ1xcXFx1MjFBMSc6J0RhcnInLCdcXFxcdTIxQTInOidsYXJydGwnLCdcXFxcdTIxQTMnOidyYXJydGwnLCdcXFxcdTIxQTQnOidtYXBzdG9sZWZ0JywnXFxcXHUyMUE1JzonbWFwc3RvdXAnLCdcXFxcdTIxQTYnOidtYXAnLCdcXFxcdTIxQTcnOidtYXBzdG9kb3duJywnXFxcXHUyMUE5JzonbGFycmhrJywnXFxcXHUyMUFBJzoncmFycmhrJywnXFxcXHUyMUFCJzonbGFycmxwJywnXFxcXHUyMUFDJzoncmFycmxwJywnXFxcXHUyMUFEJzonaGFycncnLCdcXFxcdTIxQjAnOidsc2gnLCdcXFxcdTIxQjEnOidyc2gnLCdcXFxcdTIxQjInOidsZHNoJywnXFxcXHUyMUIzJzoncmRzaCcsJ1xcXFx1MjFCNSc6J2NyYXJyJywnXFxcXHUyMUI2JzonY3VsYXJyJywnXFxcXHUyMUI3JzonY3VyYXJyJywnXFxcXHUyMUJBJzonb2xhcnInLCdcXFxcdTIxQkInOidvcmFycicsJ1xcXFx1MjFCQyc6J2xoYXJ1JywnXFxcXHUyMUJEJzonbGhhcmQnLCdcXFxcdTIxQkUnOid1aGFycicsJ1xcXFx1MjFCRic6J3VoYXJsJywnXFxcXHUyMUMwJzoncmhhcnUnLCdcXFxcdTIxQzEnOidyaGFyZCcsJ1xcXFx1MjFDMic6J2RoYXJyJywnXFxcXHUyMUMzJzonZGhhcmwnLCdcXFxcdTIxQzQnOidybGFycicsJ1xcXFx1MjFDNSc6J3VkYXJyJywnXFxcXHUyMUM2JzonbHJhcnInLCdcXFxcdTIxQzcnOidsbGFycicsJ1xcXFx1MjFDOCc6J3V1YXJyJywnXFxcXHUyMUM5JzoncnJhcnInLCdcXFxcdTIxQ0EnOidkZGFycicsJ1xcXFx1MjFDQic6J2xyaGFyJywnXFxcXHUyMUNDJzoncmxoYXInLCdcXFxcdTIxRDAnOidsQXJyJywnXFxcXHUyMUNEJzonbmxBcnInLCdcXFxcdTIxRDEnOid1QXJyJywnXFxcXHUyMUQyJzonckFycicsJ1xcXFx1MjFDRic6J25yQXJyJywnXFxcXHUyMUQzJzonZEFycicsJ1xcXFx1MjFENCc6J2lmZicsJ1xcXFx1MjFDRSc6J25oQXJyJywnXFxcXHUyMUQ1JzondkFycicsJ1xcXFx1MjFENic6J253QXJyJywnXFxcXHUyMUQ3JzonbmVBcnInLCdcXFxcdTIxRDgnOidzZUFycicsJ1xcXFx1MjFEOSc6J3N3QXJyJywnXFxcXHUyMURBJzonbEFhcnInLCdcXFxcdTIxREInOidyQWFycicsJ1xcXFx1MjFERCc6J3ppZ3JhcnInLCdcXFxcdTIxRTQnOidsYXJyYicsJ1xcXFx1MjFFNSc6J3JhcnJiJywnXFxcXHUyMUY1JzonZHVhcnInLCdcXFxcdTIxRkQnOidsb2FycicsJ1xcXFx1MjFGRSc6J3JvYXJyJywnXFxcXHUyMUZGJzonaG9hcnInLCdcXFxcdTIyMDAnOidmb3JhbGwnLCdcXFxcdTIyMDEnOidjb21wJywnXFxcXHUyMjAyJzoncGFydCcsJ1xcXFx1MjIwMlxcXFx1MDMzOCc6J25wYXJ0JywnXFxcXHUyMjAzJzonZXhpc3QnLCdcXFxcdTIyMDQnOiduZXhpc3QnLCdcXFxcdTIyMDUnOidlbXB0eScsJ1xcXFx1MjIwNyc6J0RlbCcsJ1xcXFx1MjIwOCc6J2luJywnXFxcXHUyMjA5Jzonbm90aW4nLCdcXFxcdTIyMEInOiduaScsJ1xcXFx1MjIwQyc6J25vdG5pJywnXFxcXHUwM0Y2JzonYmVwc2knLCdcXFxcdTIyMEYnOidwcm9kJywnXFxcXHUyMjEwJzonY29wcm9kJywnXFxcXHUyMjExJzonc3VtJywnKyc6J3BsdXMnLCdcXFxceEIxJzoncG0nLCdcXFxceEY3JzonZGl2JywnXFxcXHhENyc6J3RpbWVzJywnPCc6J2x0JywnXFxcXHUyMjZFJzonbmx0JywnPFxcXFx1MjBEMic6J252bHQnLCc9JzonZXF1YWxzJywnXFxcXHUyMjYwJzonbmUnLCc9XFxcXHUyMEU1JzonYm5lJywnXFxcXHUyQTc1JzonRXF1YWwnLCc+JzonZ3QnLCdcXFxcdTIyNkYnOiduZ3QnLCc+XFxcXHUyMEQyJzonbnZndCcsJ1xcXFx4QUMnOidub3QnLCd8JzondmVydCcsJ1xcXFx4QTYnOidicnZiYXInLCdcXFxcdTIyMTInOidtaW51cycsJ1xcXFx1MjIxMyc6J21wJywnXFxcXHUyMjE0JzoncGx1c2RvJywnXFxcXHUyMDQ0JzonZnJhc2wnLCdcXFxcdTIyMTYnOidzZXRtbicsJ1xcXFx1MjIxNyc6J2xvd2FzdCcsJ1xcXFx1MjIxOCc6J2NvbXBmbicsJ1xcXFx1MjIxQSc6J1NxcnQnLCdcXFxcdTIyMUQnOidwcm9wJywnXFxcXHUyMjFFJzonaW5maW4nLCdcXFxcdTIyMUYnOidhbmdydCcsJ1xcXFx1MjIyMCc6J2FuZycsJ1xcXFx1MjIyMFxcXFx1MjBEMic6J25hbmcnLCdcXFxcdTIyMjEnOidhbmdtc2QnLCdcXFxcdTIyMjInOidhbmdzcGgnLCdcXFxcdTIyMjMnOidtaWQnLCdcXFxcdTIyMjQnOidubWlkJywnXFxcXHUyMjI1JzoncGFyJywnXFxcXHUyMjI2JzonbnBhcicsJ1xcXFx1MjIyNyc6J2FuZCcsJ1xcXFx1MjIyOCc6J29yJywnXFxcXHUyMjI5JzonY2FwJywnXFxcXHUyMjI5XFxcXHVGRTAwJzonY2FwcycsJ1xcXFx1MjIyQSc6J2N1cCcsJ1xcXFx1MjIyQVxcXFx1RkUwMCc6J2N1cHMnLCdcXFxcdTIyMkInOidpbnQnLCdcXFxcdTIyMkMnOidJbnQnLCdcXFxcdTIyMkQnOid0aW50JywnXFxcXHUyQTBDJzoncWludCcsJ1xcXFx1MjIyRSc6J29pbnQnLCdcXFxcdTIyMkYnOidDb25pbnQnLCdcXFxcdTIyMzAnOidDY29uaW50JywnXFxcXHUyMjMxJzonY3dpbnQnLCdcXFxcdTIyMzInOidjd2NvbmludCcsJ1xcXFx1MjIzMyc6J2F3Y29uaW50JywnXFxcXHUyMjM0JzondGhlcmU0JywnXFxcXHUyMjM1JzonYmVjYXVzJywnXFxcXHUyMjM2JzoncmF0aW8nLCdcXFxcdTIyMzcnOidDb2xvbicsJ1xcXFx1MjIzOCc6J21pbnVzZCcsJ1xcXFx1MjIzQSc6J21ERG90JywnXFxcXHUyMjNCJzonaG9tdGh0JywnXFxcXHUyMjNDJzonc2ltJywnXFxcXHUyMjQxJzonbnNpbScsJ1xcXFx1MjIzQ1xcXFx1MjBEMic6J252c2ltJywnXFxcXHUyMjNEJzonYnNpbScsJ1xcXFx1MjIzRFxcXFx1MDMzMSc6J3JhY2UnLCdcXFxcdTIyM0UnOidhYycsJ1xcXFx1MjIzRVxcXFx1MDMzMyc6J2FjRScsJ1xcXFx1MjIzRic6J2FjZCcsJ1xcXFx1MjI0MCc6J3dyJywnXFxcXHUyMjQyJzonZXNpbScsJ1xcXFx1MjI0MlxcXFx1MDMzOCc6J25lc2ltJywnXFxcXHUyMjQzJzonc2ltZScsJ1xcXFx1MjI0NCc6J25zaW1lJywnXFxcXHUyMjQ1JzonY29uZycsJ1xcXFx1MjI0Nyc6J25jb25nJywnXFxcXHUyMjQ2Jzonc2ltbmUnLCdcXFxcdTIyNDgnOidhcCcsJ1xcXFx1MjI0OSc6J25hcCcsJ1xcXFx1MjI0QSc6J2FwZScsJ1xcXFx1MjI0Qic6J2FwaWQnLCdcXFxcdTIyNEJcXFxcdTAzMzgnOiduYXBpZCcsJ1xcXFx1MjI0Qyc6J2Jjb25nJywnXFxcXHUyMjREJzonQ3VwQ2FwJywnXFxcXHUyMjZEJzonTm90Q3VwQ2FwJywnXFxcXHUyMjREXFxcXHUyMEQyJzonbnZhcCcsJ1xcXFx1MjI0RSc6J2J1bXAnLCdcXFxcdTIyNEVcXFxcdTAzMzgnOiduYnVtcCcsJ1xcXFx1MjI0Ric6J2J1bXBlJywnXFxcXHUyMjRGXFxcXHUwMzM4JzonbmJ1bXBlJywnXFxcXHUyMjUwJzonZG90ZXEnLCdcXFxcdTIyNTBcXFxcdTAzMzgnOiduZWRvdCcsJ1xcXFx1MjI1MSc6J2VEb3QnLCdcXFxcdTIyNTInOidlZkRvdCcsJ1xcXFx1MjI1Myc6J2VyRG90JywnXFxcXHUyMjU0JzonY29sb25lJywnXFxcXHUyMjU1JzonZWNvbG9uJywnXFxcXHUyMjU2JzonZWNpcicsJ1xcXFx1MjI1Nyc6J2NpcmUnLCdcXFxcdTIyNTknOid3ZWRnZXEnLCdcXFxcdTIyNUEnOid2ZWVlcScsJ1xcXFx1MjI1Qyc6J3RyaWUnLCdcXFxcdTIyNUYnOidlcXVlc3QnLCdcXFxcdTIyNjEnOidlcXVpdicsJ1xcXFx1MjI2Mic6J25lcXVpdicsJ1xcXFx1MjI2MVxcXFx1MjBFNSc6J2JuZXF1aXYnLCdcXFxcdTIyNjQnOidsZScsJ1xcXFx1MjI3MCc6J25sZScsJ1xcXFx1MjI2NFxcXFx1MjBEMic6J252bGUnLCdcXFxcdTIyNjUnOidnZScsJ1xcXFx1MjI3MSc6J25nZScsJ1xcXFx1MjI2NVxcXFx1MjBEMic6J252Z2UnLCdcXFxcdTIyNjYnOidsRScsJ1xcXFx1MjI2NlxcXFx1MDMzOCc6J25sRScsJ1xcXFx1MjI2Nyc6J2dFJywnXFxcXHUyMjY3XFxcXHUwMzM4JzonbmdFJywnXFxcXHUyMjY4XFxcXHVGRTAwJzonbHZuRScsJ1xcXFx1MjI2OCc6J2xuRScsJ1xcXFx1MjI2OSc6J2duRScsJ1xcXFx1MjI2OVxcXFx1RkUwMCc6J2d2bkUnLCdcXFxcdTIyNkEnOidsbCcsJ1xcXFx1MjI2QVxcXFx1MDMzOCc6J25MdHYnLCdcXFxcdTIyNkFcXFxcdTIwRDInOiduTHQnLCdcXFxcdTIyNkInOidnZycsJ1xcXFx1MjI2QlxcXFx1MDMzOCc6J25HdHYnLCdcXFxcdTIyNkJcXFxcdTIwRDInOiduR3QnLCdcXFxcdTIyNkMnOid0d2l4dCcsJ1xcXFx1MjI3Mic6J2xzaW0nLCdcXFxcdTIyNzQnOidubHNpbScsJ1xcXFx1MjI3Myc6J2dzaW0nLCdcXFxcdTIyNzUnOiduZ3NpbScsJ1xcXFx1MjI3Nic6J2xnJywnXFxcXHUyMjc4JzonbnRsZycsJ1xcXFx1MjI3Nyc6J2dsJywnXFxcXHUyMjc5JzonbnRnbCcsJ1xcXFx1MjI3QSc6J3ByJywnXFxcXHUyMjgwJzonbnByJywnXFxcXHUyMjdCJzonc2MnLCdcXFxcdTIyODEnOiduc2MnLCdcXFxcdTIyN0MnOidwcmN1ZScsJ1xcXFx1MjJFMCc6J25wcmN1ZScsJ1xcXFx1MjI3RCc6J3NjY3VlJywnXFxcXHUyMkUxJzonbnNjY3VlJywnXFxcXHUyMjdFJzoncHJzaW0nLCdcXFxcdTIyN0YnOidzY3NpbScsJ1xcXFx1MjI3RlxcXFx1MDMzOCc6J05vdFN1Y2NlZWRzVGlsZGUnLCdcXFxcdTIyODInOidzdWInLCdcXFxcdTIyODQnOiduc3ViJywnXFxcXHUyMjgyXFxcXHUyMEQyJzondm5zdWInLCdcXFxcdTIyODMnOidzdXAnLCdcXFxcdTIyODUnOiduc3VwJywnXFxcXHUyMjgzXFxcXHUyMEQyJzondm5zdXAnLCdcXFxcdTIyODYnOidzdWJlJywnXFxcXHUyMjg4JzonbnN1YmUnLCdcXFxcdTIyODcnOidzdXBlJywnXFxcXHUyMjg5JzonbnN1cGUnLCdcXFxcdTIyOEFcXFxcdUZFMDAnOid2c3VibmUnLCdcXFxcdTIyOEEnOidzdWJuZScsJ1xcXFx1MjI4QlxcXFx1RkUwMCc6J3ZzdXBuZScsJ1xcXFx1MjI4Qic6J3N1cG5lJywnXFxcXHUyMjhEJzonY3VwZG90JywnXFxcXHUyMjhFJzondXBsdXMnLCdcXFxcdTIyOEYnOidzcXN1YicsJ1xcXFx1MjI4RlxcXFx1MDMzOCc6J05vdFNxdWFyZVN1YnNldCcsJ1xcXFx1MjI5MCc6J3Nxc3VwJywnXFxcXHUyMjkwXFxcXHUwMzM4JzonTm90U3F1YXJlU3VwZXJzZXQnLCdcXFxcdTIyOTEnOidzcXN1YmUnLCdcXFxcdTIyRTInOiduc3FzdWJlJywnXFxcXHUyMjkyJzonc3FzdXBlJywnXFxcXHUyMkUzJzonbnNxc3VwZScsJ1xcXFx1MjI5Myc6J3NxY2FwJywnXFxcXHUyMjkzXFxcXHVGRTAwJzonc3FjYXBzJywnXFxcXHUyMjk0Jzonc3FjdXAnLCdcXFxcdTIyOTRcXFxcdUZFMDAnOidzcWN1cHMnLCdcXFxcdTIyOTUnOidvcGx1cycsJ1xcXFx1MjI5Nic6J29taW51cycsJ1xcXFx1MjI5Nyc6J290aW1lcycsJ1xcXFx1MjI5OCc6J29zb2wnLCdcXFxcdTIyOTknOidvZG90JywnXFxcXHUyMjlBJzonb2NpcicsJ1xcXFx1MjI5Qic6J29hc3QnLCdcXFxcdTIyOUQnOidvZGFzaCcsJ1xcXFx1MjI5RSc6J3BsdXNiJywnXFxcXHUyMjlGJzonbWludXNiJywnXFxcXHUyMkEwJzondGltZXNiJywnXFxcXHUyMkExJzonc2RvdGInLCdcXFxcdTIyQTInOid2ZGFzaCcsJ1xcXFx1MjJBQyc6J252ZGFzaCcsJ1xcXFx1MjJBMyc6J2Rhc2h2JywnXFxcXHUyMkE0JzondG9wJywnXFxcXHUyMkE1JzonYm90JywnXFxcXHUyMkE3JzonbW9kZWxzJywnXFxcXHUyMkE4JzondkRhc2gnLCdcXFxcdTIyQUQnOidudkRhc2gnLCdcXFxcdTIyQTknOidWZGFzaCcsJ1xcXFx1MjJBRSc6J25WZGFzaCcsJ1xcXFx1MjJBQSc6J1Z2ZGFzaCcsJ1xcXFx1MjJBQic6J1ZEYXNoJywnXFxcXHUyMkFGJzonblZEYXNoJywnXFxcXHUyMkIwJzoncHJ1cmVsJywnXFxcXHUyMkIyJzondmx0cmknLCdcXFxcdTIyRUEnOidubHRyaScsJ1xcXFx1MjJCMyc6J3ZydHJpJywnXFxcXHUyMkVCJzonbnJ0cmknLCdcXFxcdTIyQjQnOidsdHJpZScsJ1xcXFx1MjJFQyc6J25sdHJpZScsJ1xcXFx1MjJCNFxcXFx1MjBEMic6J252bHRyaWUnLCdcXFxcdTIyQjUnOidydHJpZScsJ1xcXFx1MjJFRCc6J25ydHJpZScsJ1xcXFx1MjJCNVxcXFx1MjBEMic6J252cnRyaWUnLCdcXFxcdTIyQjYnOidvcmlnb2YnLCdcXFxcdTIyQjcnOidpbW9mJywnXFxcXHUyMkI4JzonbXVtYXAnLCdcXFxcdTIyQjknOidoZXJjb24nLCdcXFxcdTIyQkEnOidpbnRjYWwnLCdcXFxcdTIyQkInOid2ZWViYXInLCdcXFxcdTIyQkQnOidiYXJ2ZWUnLCdcXFxcdTIyQkUnOidhbmdydHZiJywnXFxcXHUyMkJGJzonbHJ0cmknLCdcXFxcdTIyQzAnOidXZWRnZScsJ1xcXFx1MjJDMSc6J1ZlZScsJ1xcXFx1MjJDMic6J3hjYXAnLCdcXFxcdTIyQzMnOid4Y3VwJywnXFxcXHUyMkM0JzonZGlhbScsJ1xcXFx1MjJDNSc6J3Nkb3QnLCdcXFxcdTIyQzYnOidTdGFyJywnXFxcXHUyMkM3JzonZGl2b254JywnXFxcXHUyMkM4JzonYm93dGllJywnXFxcXHUyMkM5JzonbHRpbWVzJywnXFxcXHUyMkNBJzoncnRpbWVzJywnXFxcXHUyMkNCJzonbHRocmVlJywnXFxcXHUyMkNDJzoncnRocmVlJywnXFxcXHUyMkNEJzonYnNpbWUnLCdcXFxcdTIyQ0UnOidjdXZlZScsJ1xcXFx1MjJDRic6J2N1d2VkJywnXFxcXHUyMkQwJzonU3ViJywnXFxcXHUyMkQxJzonU3VwJywnXFxcXHUyMkQyJzonQ2FwJywnXFxcXHUyMkQzJzonQ3VwJywnXFxcXHUyMkQ0JzonZm9yaycsJ1xcXFx1MjJENSc6J2VwYXInLCdcXFxcdTIyRDYnOidsdGRvdCcsJ1xcXFx1MjJENyc6J2d0ZG90JywnXFxcXHUyMkQ4JzonTGwnLCdcXFxcdTIyRDhcXFxcdTAzMzgnOiduTGwnLCdcXFxcdTIyRDknOidHZycsJ1xcXFx1MjJEOVxcXFx1MDMzOCc6J25HZycsJ1xcXFx1MjJEQVxcXFx1RkUwMCc6J2xlc2cnLCdcXFxcdTIyREEnOidsZWcnLCdcXFxcdTIyREInOidnZWwnLCdcXFxcdTIyREJcXFxcdUZFMDAnOidnZXNsJywnXFxcXHUyMkRFJzonY3VlcHInLCdcXFxcdTIyREYnOidjdWVzYycsJ1xcXFx1MjJFNic6J2xuc2ltJywnXFxcXHUyMkU3JzonZ25zaW0nLCdcXFxcdTIyRTgnOidwcm5zaW0nLCdcXFxcdTIyRTknOidzY25zaW0nLCdcXFxcdTIyRUUnOid2ZWxsaXAnLCdcXFxcdTIyRUYnOidjdGRvdCcsJ1xcXFx1MjJGMCc6J3V0ZG90JywnXFxcXHUyMkYxJzonZHRkb3QnLCdcXFxcdTIyRjInOidkaXNpbicsJ1xcXFx1MjJGMyc6J2lzaW5zdicsJ1xcXFx1MjJGNCc6J2lzaW5zJywnXFxcXHUyMkY1JzonaXNpbmRvdCcsJ1xcXFx1MjJGNVxcXFx1MDMzOCc6J25vdGluZG90JywnXFxcXHUyMkY2Jzonbm90aW52YycsJ1xcXFx1MjJGNyc6J25vdGludmInLCdcXFxcdTIyRjknOidpc2luRScsJ1xcXFx1MjJGOVxcXFx1MDMzOCc6J25vdGluRScsJ1xcXFx1MjJGQSc6J25pc2QnLCdcXFxcdTIyRkInOid4bmlzJywnXFxcXHUyMkZDJzonbmlzJywnXFxcXHUyMkZEJzonbm90bml2YycsJ1xcXFx1MjJGRSc6J25vdG5pdmInLCdcXFxcdTIzMDUnOidiYXJ3ZWQnLCdcXFxcdTIzMDYnOidCYXJ3ZWQnLCdcXFxcdTIzMEMnOidkcmNyb3AnLCdcXFxcdTIzMEQnOidkbGNyb3AnLCdcXFxcdTIzMEUnOid1cmNyb3AnLCdcXFxcdTIzMEYnOid1bGNyb3AnLCdcXFxcdTIzMTAnOidibm90JywnXFxcXHUyMzEyJzoncHJvZmxpbmUnLCdcXFxcdTIzMTMnOidwcm9mc3VyZicsJ1xcXFx1MjMxNSc6J3RlbHJlYycsJ1xcXFx1MjMxNic6J3RhcmdldCcsJ1xcXFx1MjMxQyc6J3VsY29ybicsJ1xcXFx1MjMxRCc6J3VyY29ybicsJ1xcXFx1MjMxRSc6J2RsY29ybicsJ1xcXFx1MjMxRic6J2RyY29ybicsJ1xcXFx1MjMyMic6J2Zyb3duJywnXFxcXHUyMzIzJzonc21pbGUnLCdcXFxcdTIzMkQnOidjeWxjdHknLCdcXFxcdTIzMkUnOidwcm9mYWxhcicsJ1xcXFx1MjMzNic6J3RvcGJvdCcsJ1xcXFx1MjMzRCc6J292YmFyJywnXFxcXHUyMzNGJzonc29sYmFyJywnXFxcXHUyMzdDJzonYW5nemFycicsJ1xcXFx1MjNCMCc6J2xtb3VzdCcsJ1xcXFx1MjNCMSc6J3Jtb3VzdCcsJ1xcXFx1MjNCNCc6J3RicmsnLCdcXFxcdTIzQjUnOidiYnJrJywnXFxcXHUyM0I2JzonYmJya3RicmsnLCdcXFxcdTIzREMnOidPdmVyUGFyZW50aGVzaXMnLCdcXFxcdTIzREQnOidVbmRlclBhcmVudGhlc2lzJywnXFxcXHUyM0RFJzonT3ZlckJyYWNlJywnXFxcXHUyM0RGJzonVW5kZXJCcmFjZScsJ1xcXFx1MjNFMic6J3RycGV6aXVtJywnXFxcXHUyM0U3JzonZWxpbnRlcnMnLCdcXFxcdTI0MjMnOidibGFuaycsJ1xcXFx1MjUwMCc6J2JveGgnLCdcXFxcdTI1MDInOidib3h2JywnXFxcXHUyNTBDJzonYm94ZHInLCdcXFxcdTI1MTAnOidib3hkbCcsJ1xcXFx1MjUxNCc6J2JveHVyJywnXFxcXHUyNTE4JzonYm94dWwnLCdcXFxcdTI1MUMnOidib3h2cicsJ1xcXFx1MjUyNCc6J2JveHZsJywnXFxcXHUyNTJDJzonYm94aGQnLCdcXFxcdTI1MzQnOidib3hodScsJ1xcXFx1MjUzQyc6J2JveHZoJywnXFxcXHUyNTUwJzonYm94SCcsJ1xcXFx1MjU1MSc6J2JveFYnLCdcXFxcdTI1NTInOidib3hkUicsJ1xcXFx1MjU1Myc6J2JveERyJywnXFxcXHUyNTU0JzonYm94RFInLCdcXFxcdTI1NTUnOidib3hkTCcsJ1xcXFx1MjU1Nic6J2JveERsJywnXFxcXHUyNTU3JzonYm94REwnLCdcXFxcdTI1NTgnOidib3h1UicsJ1xcXFx1MjU1OSc6J2JveFVyJywnXFxcXHUyNTVBJzonYm94VVInLCdcXFxcdTI1NUInOidib3h1TCcsJ1xcXFx1MjU1Qyc6J2JveFVsJywnXFxcXHUyNTVEJzonYm94VUwnLCdcXFxcdTI1NUUnOidib3h2UicsJ1xcXFx1MjU1Ric6J2JveFZyJywnXFxcXHUyNTYwJzonYm94VlInLCdcXFxcdTI1NjEnOidib3h2TCcsJ1xcXFx1MjU2Mic6J2JveFZsJywnXFxcXHUyNTYzJzonYm94VkwnLCdcXFxcdTI1NjQnOidib3hIZCcsJ1xcXFx1MjU2NSc6J2JveGhEJywnXFxcXHUyNTY2JzonYm94SEQnLCdcXFxcdTI1NjcnOidib3hIdScsJ1xcXFx1MjU2OCc6J2JveGhVJywnXFxcXHUyNTY5JzonYm94SFUnLCdcXFxcdTI1NkEnOidib3h2SCcsJ1xcXFx1MjU2Qic6J2JveFZoJywnXFxcXHUyNTZDJzonYm94VkgnLCdcXFxcdTI1ODAnOid1aGJsaycsJ1xcXFx1MjU4NCc6J2xoYmxrJywnXFxcXHUyNTg4JzonYmxvY2snLCdcXFxcdTI1OTEnOidibGsxNCcsJ1xcXFx1MjU5Mic6J2JsazEyJywnXFxcXHUyNTkzJzonYmxrMzQnLCdcXFxcdTI1QTEnOidzcXUnLCdcXFxcdTI1QUEnOidzcXVmJywnXFxcXHUyNUFCJzonRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCdcXFxcdTI1QUQnOidyZWN0JywnXFxcXHUyNUFFJzonbWFya2VyJywnXFxcXHUyNUIxJzonZmx0bnMnLCdcXFxcdTI1QjMnOid4dXRyaScsJ1xcXFx1MjVCNCc6J3V0cmlmJywnXFxcXHUyNUI1JzondXRyaScsJ1xcXFx1MjVCOCc6J3J0cmlmJywnXFxcXHUyNUI5JzoncnRyaScsJ1xcXFx1MjVCRCc6J3hkdHJpJywnXFxcXHUyNUJFJzonZHRyaWYnLCdcXFxcdTI1QkYnOidkdHJpJywnXFxcXHUyNUMyJzonbHRyaWYnLCdcXFxcdTI1QzMnOidsdHJpJywnXFxcXHUyNUNBJzonbG96JywnXFxcXHUyNUNCJzonY2lyJywnXFxcXHUyNUVDJzondHJpZG90JywnXFxcXHUyNUVGJzoneGNpcmMnLCdcXFxcdTI1RjgnOid1bHRyaScsJ1xcXFx1MjVGOSc6J3VydHJpJywnXFxcXHUyNUZBJzonbGx0cmknLCdcXFxcdTI1RkInOidFbXB0eVNtYWxsU3F1YXJlJywnXFxcXHUyNUZDJzonRmlsbGVkU21hbGxTcXVhcmUnLCdcXFxcdTI2MDUnOidzdGFyZicsJ1xcXFx1MjYwNic6J3N0YXInLCdcXFxcdTI2MEUnOidwaG9uZScsJ1xcXFx1MjY0MCc6J2ZlbWFsZScsJ1xcXFx1MjY0Mic6J21hbGUnLCdcXFxcdTI2NjAnOidzcGFkZXMnLCdcXFxcdTI2NjMnOidjbHVicycsJ1xcXFx1MjY2NSc6J2hlYXJ0cycsJ1xcXFx1MjY2Nic6J2RpYW1zJywnXFxcXHUyNjZBJzonc3VuZycsJ1xcXFx1MjcxMyc6J2NoZWNrJywnXFxcXHUyNzE3JzonY3Jvc3MnLCdcXFxcdTI3MjAnOidtYWx0JywnXFxcXHUyNzM2Jzonc2V4dCcsJ1xcXFx1Mjc1OCc6J1ZlcnRpY2FsU2VwYXJhdG9yJywnXFxcXHUyN0M4JzonYnNvbGhzdWInLCdcXFxcdTI3QzknOidzdXBoc29sJywnXFxcXHUyN0Y1JzoneGxhcnInLCdcXFxcdTI3RjYnOid4cmFycicsJ1xcXFx1MjdGNyc6J3hoYXJyJywnXFxcXHUyN0Y4JzoneGxBcnInLCdcXFxcdTI3RjknOid4ckFycicsJ1xcXFx1MjdGQSc6J3hoQXJyJywnXFxcXHUyN0ZDJzoneG1hcCcsJ1xcXFx1MjdGRic6J2R6aWdyYXJyJywnXFxcXHUyOTAyJzonbnZsQXJyJywnXFxcXHUyOTAzJzonbnZyQXJyJywnXFxcXHUyOTA0JzonbnZIYXJyJywnXFxcXHUyOTA1JzonTWFwJywnXFxcXHUyOTBDJzonbGJhcnInLCdcXFxcdTI5MEQnOidyYmFycicsJ1xcXFx1MjkwRSc6J2xCYXJyJywnXFxcXHUyOTBGJzonckJhcnInLCdcXFxcdTI5MTAnOidSQmFycicsJ1xcXFx1MjkxMSc6J0REb3RyYWhkJywnXFxcXHUyOTEyJzonVXBBcnJvd0JhcicsJ1xcXFx1MjkxMyc6J0Rvd25BcnJvd0JhcicsJ1xcXFx1MjkxNic6J1JhcnJ0bCcsJ1xcXFx1MjkxOSc6J2xhdGFpbCcsJ1xcXFx1MjkxQSc6J3JhdGFpbCcsJ1xcXFx1MjkxQic6J2xBdGFpbCcsJ1xcXFx1MjkxQyc6J3JBdGFpbCcsJ1xcXFx1MjkxRCc6J2xhcnJmcycsJ1xcXFx1MjkxRSc6J3JhcnJmcycsJ1xcXFx1MjkxRic6J2xhcnJiZnMnLCdcXFxcdTI5MjAnOidyYXJyYmZzJywnXFxcXHUyOTIzJzonbndhcmhrJywnXFxcXHUyOTI0JzonbmVhcmhrJywnXFxcXHUyOTI1Jzonc2VhcmhrJywnXFxcXHUyOTI2Jzonc3dhcmhrJywnXFxcXHUyOTI3JzonbnduZWFyJywnXFxcXHUyOTI4JzondG9lYScsJ1xcXFx1MjkyOSc6J3Rvc2EnLCdcXFxcdTI5MkEnOidzd253YXInLCdcXFxcdTI5MzMnOidyYXJyYycsJ1xcXFx1MjkzM1xcXFx1MDMzOCc6J25yYXJyYycsJ1xcXFx1MjkzNSc6J2N1ZGFycnInLCdcXFxcdTI5MzYnOidsZGNhJywnXFxcXHUyOTM3JzoncmRjYScsJ1xcXFx1MjkzOCc6J2N1ZGFycmwnLCdcXFxcdTI5MzknOidsYXJycGwnLCdcXFxcdTI5M0MnOidjdXJhcnJtJywnXFxcXHUyOTNEJzonY3VsYXJycCcsJ1xcXFx1Mjk0NSc6J3JhcnJwbCcsJ1xcXFx1Mjk0OCc6J2hhcnJjaXInLCdcXFxcdTI5NDknOidVYXJyb2NpcicsJ1xcXFx1Mjk0QSc6J2x1cmRzaGFyJywnXFxcXHUyOTRCJzonbGRydXNoYXInLCdcXFxcdTI5NEUnOidMZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NEYnOidSaWdodFVwRG93blZlY3RvcicsJ1xcXFx1Mjk1MCc6J0Rvd25MZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NTEnOidMZWZ0VXBEb3duVmVjdG9yJywnXFxcXHUyOTUyJzonTGVmdFZlY3RvckJhcicsJ1xcXFx1Mjk1Myc6J1JpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU0JzonUmlnaHRVcFZlY3RvckJhcicsJ1xcXFx1Mjk1NSc6J1JpZ2h0RG93blZlY3RvckJhcicsJ1xcXFx1Mjk1Nic6J0Rvd25MZWZ0VmVjdG9yQmFyJywnXFxcXHUyOTU3JzonRG93blJpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU4JzonTGVmdFVwVmVjdG9yQmFyJywnXFxcXHUyOTU5JzonTGVmdERvd25WZWN0b3JCYXInLCdcXFxcdTI5NUEnOidMZWZ0VGVlVmVjdG9yJywnXFxcXHUyOTVCJzonUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NUMnOidSaWdodFVwVGVlVmVjdG9yJywnXFxcXHUyOTVEJzonUmlnaHREb3duVGVlVmVjdG9yJywnXFxcXHUyOTVFJzonRG93bkxlZnRUZWVWZWN0b3InLCdcXFxcdTI5NUYnOidEb3duUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NjAnOidMZWZ0VXBUZWVWZWN0b3InLCdcXFxcdTI5NjEnOidMZWZ0RG93blRlZVZlY3RvcicsJ1xcXFx1Mjk2Mic6J2xIYXInLCdcXFxcdTI5NjMnOid1SGFyJywnXFxcXHUyOTY0JzonckhhcicsJ1xcXFx1Mjk2NSc6J2RIYXInLCdcXFxcdTI5NjYnOidsdXJ1aGFyJywnXFxcXHUyOTY3JzonbGRyZGhhcicsJ1xcXFx1Mjk2OCc6J3J1bHVoYXInLCdcXFxcdTI5NjknOidyZGxkaGFyJywnXFxcXHUyOTZBJzonbGhhcnVsJywnXFxcXHUyOTZCJzonbGxoYXJkJywnXFxcXHUyOTZDJzoncmhhcnVsJywnXFxcXHUyOTZEJzonbHJoYXJkJywnXFxcXHUyOTZFJzondWRoYXInLCdcXFxcdTI5NkYnOidkdWhhcicsJ1xcXFx1Mjk3MCc6J1JvdW5kSW1wbGllcycsJ1xcXFx1Mjk3MSc6J2VyYXJyJywnXFxcXHUyOTcyJzonc2ltcmFycicsJ1xcXFx1Mjk3Myc6J2xhcnJzaW0nLCdcXFxcdTI5NzQnOidyYXJyc2ltJywnXFxcXHUyOTc1JzoncmFycmFwJywnXFxcXHUyOTc2JzonbHRsYXJyJywnXFxcXHUyOTc4JzonZ3RyYXJyJywnXFxcXHUyOTc5Jzonc3VicmFycicsJ1xcXFx1Mjk3Qic6J3N1cGxhcnInLCdcXFxcdTI5N0MnOidsZmlzaHQnLCdcXFxcdTI5N0QnOidyZmlzaHQnLCdcXFxcdTI5N0UnOid1ZmlzaHQnLCdcXFxcdTI5N0YnOidkZmlzaHQnLCdcXFxcdTI5OUEnOid2emlnemFnJywnXFxcXHUyOTlDJzondmFuZ3J0JywnXFxcXHUyOTlEJzonYW5ncnR2YmQnLCdcXFxcdTI5QTQnOidhbmdlJywnXFxcXHUyOUE1JzoncmFuZ2UnLCdcXFxcdTI5QTYnOidkd2FuZ2xlJywnXFxcXHUyOUE3JzondXdhbmdsZScsJ1xcXFx1MjlBOCc6J2FuZ21zZGFhJywnXFxcXHUyOUE5JzonYW5nbXNkYWInLCdcXFxcdTI5QUEnOidhbmdtc2RhYycsJ1xcXFx1MjlBQic6J2FuZ21zZGFkJywnXFxcXHUyOUFDJzonYW5nbXNkYWUnLCdcXFxcdTI5QUQnOidhbmdtc2RhZicsJ1xcXFx1MjlBRSc6J2FuZ21zZGFnJywnXFxcXHUyOUFGJzonYW5nbXNkYWgnLCdcXFxcdTI5QjAnOidiZW1wdHl2JywnXFxcXHUyOUIxJzonZGVtcHR5dicsJ1xcXFx1MjlCMic6J2NlbXB0eXYnLCdcXFxcdTI5QjMnOidyYWVtcHR5dicsJ1xcXFx1MjlCNCc6J2xhZW1wdHl2JywnXFxcXHUyOUI1Jzonb2hiYXInLCdcXFxcdTI5QjYnOidvbWlkJywnXFxcXHUyOUI3Jzonb3BhcicsJ1xcXFx1MjlCOSc6J29wZXJwJywnXFxcXHUyOUJCJzonb2xjcm9zcycsJ1xcXFx1MjlCQyc6J29kc29sZCcsJ1xcXFx1MjlCRSc6J29sY2lyJywnXFxcXHUyOUJGJzonb2ZjaXInLCdcXFxcdTI5QzAnOidvbHQnLCdcXFxcdTI5QzEnOidvZ3QnLCdcXFxcdTI5QzInOidjaXJzY2lyJywnXFxcXHUyOUMzJzonY2lyRScsJ1xcXFx1MjlDNCc6J3NvbGInLCdcXFxcdTI5QzUnOidic29sYicsJ1xcXFx1MjlDOSc6J2JveGJveCcsJ1xcXFx1MjlDRCc6J3RyaXNiJywnXFxcXHUyOUNFJzoncnRyaWx0cmknLCdcXFxcdTI5Q0YnOidMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5Q0ZcXFxcdTAzMzgnOidOb3RMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5RDAnOidSaWdodFRyaWFuZ2xlQmFyJywnXFxcXHUyOUQwXFxcXHUwMzM4JzonTm90UmlnaHRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEQyc6J2lpbmZpbicsJ1xcXFx1MjlERCc6J2luZmludGllJywnXFxcXHUyOURFJzonbnZpbmZpbicsJ1xcXFx1MjlFMyc6J2VwYXJzbCcsJ1xcXFx1MjlFNCc6J3NtZXBhcnNsJywnXFxcXHUyOUU1JzonZXF2cGFyc2wnLCdcXFxcdTI5RUInOidsb3pmJywnXFxcXHUyOUY0JzonUnVsZURlbGF5ZWQnLCdcXFxcdTI5RjYnOidkc29sJywnXFxcXHUyQTAwJzoneG9kb3QnLCdcXFxcdTJBMDEnOid4b3BsdXMnLCdcXFxcdTJBMDInOid4b3RpbWUnLCdcXFxcdTJBMDQnOid4dXBsdXMnLCdcXFxcdTJBMDYnOid4c3FjdXAnLCdcXFxcdTJBMEQnOidmcGFydGludCcsJ1xcXFx1MkExMCc6J2NpcmZuaW50JywnXFxcXHUyQTExJzonYXdpbnQnLCdcXFxcdTJBMTInOidycHBvbGludCcsJ1xcXFx1MkExMyc6J3NjcG9saW50JywnXFxcXHUyQTE0JzonbnBvbGludCcsJ1xcXFx1MkExNSc6J3BvaW50aW50JywnXFxcXHUyQTE2JzoncXVhdGludCcsJ1xcXFx1MkExNyc6J2ludGxhcmhrJywnXFxcXHUyQTIyJzoncGx1c2NpcicsJ1xcXFx1MkEyMyc6J3BsdXNhY2lyJywnXFxcXHUyQTI0Jzonc2ltcGx1cycsJ1xcXFx1MkEyNSc6J3BsdXNkdScsJ1xcXFx1MkEyNic6J3BsdXNzaW0nLCdcXFxcdTJBMjcnOidwbHVzdHdvJywnXFxcXHUyQTI5JzonbWNvbW1hJywnXFxcXHUyQTJBJzonbWludXNkdScsJ1xcXFx1MkEyRCc6J2xvcGx1cycsJ1xcXFx1MkEyRSc6J3JvcGx1cycsJ1xcXFx1MkEyRic6J0Nyb3NzJywnXFxcXHUyQTMwJzondGltZXNkJywnXFxcXHUyQTMxJzondGltZXNiYXInLCdcXFxcdTJBMzMnOidzbWFzaHAnLCdcXFxcdTJBMzQnOidsb3RpbWVzJywnXFxcXHUyQTM1Jzoncm90aW1lcycsJ1xcXFx1MkEzNic6J290aW1lc2FzJywnXFxcXHUyQTM3JzonT3RpbWVzJywnXFxcXHUyQTM4Jzonb2RpdicsJ1xcXFx1MkEzOSc6J3RyaXBsdXMnLCdcXFxcdTJBM0EnOid0cmltaW51cycsJ1xcXFx1MkEzQic6J3RyaXRpbWUnLCdcXFxcdTJBM0MnOidpcHJvZCcsJ1xcXFx1MkEzRic6J2FtYWxnJywnXFxcXHUyQTQwJzonY2FwZG90JywnXFxcXHUyQTQyJzonbmN1cCcsJ1xcXFx1MkE0Myc6J25jYXAnLCdcXFxcdTJBNDQnOidjYXBhbmQnLCdcXFxcdTJBNDUnOidjdXBvcicsJ1xcXFx1MkE0Nic6J2N1cGNhcCcsJ1xcXFx1MkE0Nyc6J2NhcGN1cCcsJ1xcXFx1MkE0OCc6J2N1cGJyY2FwJywnXFxcXHUyQTQ5JzonY2FwYnJjdXAnLCdcXFxcdTJBNEEnOidjdXBjdXAnLCdcXFxcdTJBNEInOidjYXBjYXAnLCdcXFxcdTJBNEMnOidjY3VwcycsJ1xcXFx1MkE0RCc6J2NjYXBzJywnXFxcXHUyQTUwJzonY2N1cHNzbScsJ1xcXFx1MkE1Myc6J0FuZCcsJ1xcXFx1MkE1NCc6J09yJywnXFxcXHUyQTU1JzonYW5kYW5kJywnXFxcXHUyQTU2Jzonb3JvcicsJ1xcXFx1MkE1Nyc6J29yc2xvcGUnLCdcXFxcdTJBNTgnOidhbmRzbG9wZScsJ1xcXFx1MkE1QSc6J2FuZHYnLCdcXFxcdTJBNUInOidvcnYnLCdcXFxcdTJBNUMnOidhbmRkJywnXFxcXHUyQTVEJzonb3JkJywnXFxcXHUyQTVGJzond2VkYmFyJywnXFxcXHUyQTY2Jzonc2RvdGUnLCdcXFxcdTJBNkEnOidzaW1kb3QnLCdcXFxcdTJBNkQnOidjb25nZG90JywnXFxcXHUyQTZEXFxcXHUwMzM4JzonbmNvbmdkb3QnLCdcXFxcdTJBNkUnOidlYXN0ZXInLCdcXFxcdTJBNkYnOidhcGFjaXInLCdcXFxcdTJBNzAnOidhcEUnLCdcXFxcdTJBNzBcXFxcdTAzMzgnOiduYXBFJywnXFxcXHUyQTcxJzonZXBsdXMnLCdcXFxcdTJBNzInOidwbHVzZScsJ1xcXFx1MkE3Myc6J0VzaW0nLCdcXFxcdTJBNzcnOidlRERvdCcsJ1xcXFx1MkE3OCc6J2VxdWl2REQnLCdcXFxcdTJBNzknOidsdGNpcicsJ1xcXFx1MkE3QSc6J2d0Y2lyJywnXFxcXHUyQTdCJzonbHRxdWVzdCcsJ1xcXFx1MkE3Qyc6J2d0cXVlc3QnLCdcXFxcdTJBN0QnOidsZXMnLCdcXFxcdTJBN0RcXFxcdTAzMzgnOidubGVzJywnXFxcXHUyQTdFJzonZ2VzJywnXFxcXHUyQTdFXFxcXHUwMzM4JzonbmdlcycsJ1xcXFx1MkE3Ric6J2xlc2RvdCcsJ1xcXFx1MkE4MCc6J2dlc2RvdCcsJ1xcXFx1MkE4MSc6J2xlc2RvdG8nLCdcXFxcdTJBODInOidnZXNkb3RvJywnXFxcXHUyQTgzJzonbGVzZG90b3InLCdcXFxcdTJBODQnOidnZXNkb3RvbCcsJ1xcXFx1MkE4NSc6J2xhcCcsJ1xcXFx1MkE4Nic6J2dhcCcsJ1xcXFx1MkE4Nyc6J2xuZScsJ1xcXFx1MkE4OCc6J2duZScsJ1xcXFx1MkE4OSc6J2xuYXAnLCdcXFxcdTJBOEEnOidnbmFwJywnXFxcXHUyQThCJzonbEVnJywnXFxcXHUyQThDJzonZ0VsJywnXFxcXHUyQThEJzonbHNpbWUnLCdcXFxcdTJBOEUnOidnc2ltZScsJ1xcXFx1MkE4Ric6J2xzaW1nJywnXFxcXHUyQTkwJzonZ3NpbWwnLCdcXFxcdTJBOTEnOidsZ0UnLCdcXFxcdTJBOTInOidnbEUnLCdcXFxcdTJBOTMnOidsZXNnZXMnLCdcXFxcdTJBOTQnOidnZXNsZXMnLCdcXFxcdTJBOTUnOidlbHMnLCdcXFxcdTJBOTYnOidlZ3MnLCdcXFxcdTJBOTcnOidlbHNkb3QnLCdcXFxcdTJBOTgnOidlZ3Nkb3QnLCdcXFxcdTJBOTknOidlbCcsJ1xcXFx1MkE5QSc6J2VnJywnXFxcXHUyQTlEJzonc2ltbCcsJ1xcXFx1MkE5RSc6J3NpbWcnLCdcXFxcdTJBOUYnOidzaW1sRScsJ1xcXFx1MkFBMCc6J3NpbWdFJywnXFxcXHUyQUExJzonTGVzc0xlc3MnLCdcXFxcdTJBQTFcXFxcdTAzMzgnOidOb3ROZXN0ZWRMZXNzTGVzcycsJ1xcXFx1MkFBMic6J0dyZWF0ZXJHcmVhdGVyJywnXFxcXHUyQUEyXFxcXHUwMzM4JzonTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCdcXFxcdTJBQTQnOidnbGonLCdcXFxcdTJBQTUnOidnbGEnLCdcXFxcdTJBQTYnOidsdGNjJywnXFxcXHUyQUE3JzonZ3RjYycsJ1xcXFx1MkFBOCc6J2xlc2NjJywnXFxcXHUyQUE5JzonZ2VzY2MnLCdcXFxcdTJBQUEnOidzbXQnLCdcXFxcdTJBQUInOidsYXQnLCdcXFxcdTJBQUMnOidzbXRlJywnXFxcXHUyQUFDXFxcXHVGRTAwJzonc210ZXMnLCdcXFxcdTJBQUQnOidsYXRlJywnXFxcXHUyQUFEXFxcXHVGRTAwJzonbGF0ZXMnLCdcXFxcdTJBQUUnOididW1wRScsJ1xcXFx1MkFBRic6J3ByZScsJ1xcXFx1MkFBRlxcXFx1MDMzOCc6J25wcmUnLCdcXFxcdTJBQjAnOidzY2UnLCdcXFxcdTJBQjBcXFxcdTAzMzgnOiduc2NlJywnXFxcXHUyQUIzJzoncHJFJywnXFxcXHUyQUI0Jzonc2NFJywnXFxcXHUyQUI1JzoncHJuRScsJ1xcXFx1MkFCNic6J3NjbkUnLCdcXFxcdTJBQjcnOidwcmFwJywnXFxcXHUyQUI4Jzonc2NhcCcsJ1xcXFx1MkFCOSc6J3BybmFwJywnXFxcXHUyQUJBJzonc2NuYXAnLCdcXFxcdTJBQkInOidQcicsJ1xcXFx1MkFCQyc6J1NjJywnXFxcXHUyQUJEJzonc3ViZG90JywnXFxcXHUyQUJFJzonc3VwZG90JywnXFxcXHUyQUJGJzonc3VicGx1cycsJ1xcXFx1MkFDMCc6J3N1cHBsdXMnLCdcXFxcdTJBQzEnOidzdWJtdWx0JywnXFxcXHUyQUMyJzonc3VwbXVsdCcsJ1xcXFx1MkFDMyc6J3N1YmVkb3QnLCdcXFxcdTJBQzQnOidzdXBlZG90JywnXFxcXHUyQUM1Jzonc3ViRScsJ1xcXFx1MkFDNVxcXFx1MDMzOCc6J25zdWJFJywnXFxcXHUyQUM2Jzonc3VwRScsJ1xcXFx1MkFDNlxcXFx1MDMzOCc6J25zdXBFJywnXFxcXHUyQUM3Jzonc3Vic2ltJywnXFxcXHUyQUM4Jzonc3Vwc2ltJywnXFxcXHUyQUNCXFxcXHVGRTAwJzondnN1Ym5FJywnXFxcXHUyQUNCJzonc3VibkUnLCdcXFxcdTJBQ0NcXFxcdUZFMDAnOid2c3VwbkUnLCdcXFxcdTJBQ0MnOidzdXBuRScsJ1xcXFx1MkFDRic6J2NzdWInLCdcXFxcdTJBRDAnOidjc3VwJywnXFxcXHUyQUQxJzonY3N1YmUnLCdcXFxcdTJBRDInOidjc3VwZScsJ1xcXFx1MkFEMyc6J3N1YnN1cCcsJ1xcXFx1MkFENCc6J3N1cHN1YicsJ1xcXFx1MkFENSc6J3N1YnN1YicsJ1xcXFx1MkFENic6J3N1cHN1cCcsJ1xcXFx1MkFENyc6J3N1cGhzdWInLCdcXFxcdTJBRDgnOidzdXBkc3ViJywnXFxcXHUyQUQ5JzonZm9ya3YnLCdcXFxcdTJBREEnOid0b3Bmb3JrJywnXFxcXHUyQURCJzonbWxjcCcsJ1xcXFx1MkFFNCc6J0Rhc2h2JywnXFxcXHUyQUU2JzonVmRhc2hsJywnXFxcXHUyQUU3JzonQmFydicsJ1xcXFx1MkFFOCc6J3ZCYXInLCdcXFxcdTJBRTknOid2QmFydicsJ1xcXFx1MkFFQic6J1ZiYXInLCdcXFxcdTJBRUMnOidOb3QnLCdcXFxcdTJBRUQnOidiTm90JywnXFxcXHUyQUVFJzoncm5taWQnLCdcXFxcdTJBRUYnOidjaXJtaWQnLCdcXFxcdTJBRjAnOidtaWRjaXInLCdcXFxcdTJBRjEnOid0b3BjaXInLCdcXFxcdTJBRjInOiduaHBhcicsJ1xcXFx1MkFGMyc6J3BhcnNpbScsJ1xcXFx1MkFGRCc6J3BhcnNsJywnXFxcXHUyQUZEXFxcXHUyMEU1JzonbnBhcnNsJywnXFxcXHUyNjZEJzonZmxhdCcsJ1xcXFx1MjY2RSc6J25hdHVyJywnXFxcXHUyNjZGJzonc2hhcnAnLCdcXFxceEE0JzonY3VycmVuJywnXFxcXHhBMic6J2NlbnQnLCckJzonZG9sbGFyJywnXFxcXHhBMyc6J3BvdW5kJywnXFxcXHhBNSc6J3llbicsJ1xcXFx1MjBBQyc6J2V1cm8nLCdcXFxceEI5Jzonc3VwMScsJ1xcXFx4QkQnOidoYWxmJywnXFxcXHUyMTUzJzonZnJhYzEzJywnXFxcXHhCQyc6J2ZyYWMxNCcsJ1xcXFx1MjE1NSc6J2ZyYWMxNScsJ1xcXFx1MjE1OSc6J2ZyYWMxNicsJ1xcXFx1MjE1Qic6J2ZyYWMxOCcsJ1xcXFx4QjInOidzdXAyJywnXFxcXHUyMTU0JzonZnJhYzIzJywnXFxcXHUyMTU2JzonZnJhYzI1JywnXFxcXHhCMyc6J3N1cDMnLCdcXFxceEJFJzonZnJhYzM0JywnXFxcXHUyMTU3JzonZnJhYzM1JywnXFxcXHUyMTVDJzonZnJhYzM4JywnXFxcXHUyMTU4JzonZnJhYzQ1JywnXFxcXHUyMTVBJzonZnJhYzU2JywnXFxcXHUyMTVEJzonZnJhYzU4JywnXFxcXHUyMTVFJzonZnJhYzc4JywnXFxcXHVEODM1XFxcXHVEQ0I2JzonYXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Mic6J2FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUUnOidhZnInLCdcXFxcdUQ4MzVcXFxcdUREMzgnOidBb3BmJywnXFxcXHVEODM1XFxcXHVERDA0JzonQWZyJywnXFxcXHVEODM1XFxcXHVEQzlDJzonQXNjcicsJ1xcXFx4QUEnOidvcmRmJywnXFxcXHhFMSc6J2FhY3V0ZScsJ1xcXFx4QzEnOidBYWN1dGUnLCdcXFxceEUwJzonYWdyYXZlJywnXFxcXHhDMCc6J0FncmF2ZScsJ1xcXFx1MDEwMyc6J2FicmV2ZScsJ1xcXFx1MDEwMic6J0FicmV2ZScsJ1xcXFx4RTInOidhY2lyYycsJ1xcXFx4QzInOidBY2lyYycsJ1xcXFx4RTUnOidhcmluZycsJ1xcXFx4QzUnOidhbmdzdCcsJ1xcXFx4RTQnOidhdW1sJywnXFxcXHhDNCc6J0F1bWwnLCdcXFxceEUzJzonYXRpbGRlJywnXFxcXHhDMyc6J0F0aWxkZScsJ1xcXFx1MDEwNSc6J2FvZ29uJywnXFxcXHUwMTA0JzonQW9nb24nLCdcXFxcdTAxMDEnOidhbWFjcicsJ1xcXFx1MDEwMCc6J0FtYWNyJywnXFxcXHhFNic6J2FlbGlnJywnXFxcXHhDNic6J0FFbGlnJywnXFxcXHVEODM1XFxcXHVEQ0I3JzonYnNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Myc6J2JvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUYnOidiZnInLCdcXFxcdUQ4MzVcXFxcdUREMzknOidCb3BmJywnXFxcXHUyMTJDJzonQnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwNSc6J0JmcicsJ1xcXFx1RDgzNVxcXFx1REQyMCc6J2NmcicsJ1xcXFx1RDgzNVxcXFx1RENCOCc6J2NzY3InLCdcXFxcdUQ4MzVcXFxcdURENTQnOidjb3BmJywnXFxcXHUyMTJEJzonQ2ZyJywnXFxcXHVEODM1XFxcXHVEQzlFJzonQ3NjcicsJ1xcXFx1MjEwMic6J0NvcGYnLCdcXFxcdTAxMDcnOidjYWN1dGUnLCdcXFxcdTAxMDYnOidDYWN1dGUnLCdcXFxcdTAxMDknOidjY2lyYycsJ1xcXFx1MDEwOCc6J0NjaXJjJywnXFxcXHUwMTBEJzonY2Nhcm9uJywnXFxcXHUwMTBDJzonQ2Nhcm9uJywnXFxcXHUwMTBCJzonY2RvdCcsJ1xcXFx1MDEwQSc6J0Nkb3QnLCdcXFxceEU3JzonY2NlZGlsJywnXFxcXHhDNyc6J0NjZWRpbCcsJ1xcXFx1MjEwNSc6J2luY2FyZScsJ1xcXFx1RDgzNVxcXFx1REQyMSc6J2RmcicsJ1xcXFx1MjE0Nic6J2RkJywnXFxcXHVEODM1XFxcXHVERDU1JzonZG9wZicsJ1xcXFx1RDgzNVxcXFx1RENCOSc6J2RzY3InLCdcXFxcdUQ4MzVcXFxcdURDOUYnOidEc2NyJywnXFxcXHVEODM1XFxcXHVERDA3JzonRGZyJywnXFxcXHUyMTQ1JzonREQnLCdcXFxcdUQ4MzVcXFxcdUREM0InOidEb3BmJywnXFxcXHUwMTBGJzonZGNhcm9uJywnXFxcXHUwMTBFJzonRGNhcm9uJywnXFxcXHUwMTExJzonZHN0cm9rJywnXFxcXHUwMTEwJzonRHN0cm9rJywnXFxcXHhGMCc6J2V0aCcsJ1xcXFx4RDAnOidFVEgnLCdcXFxcdTIxNDcnOidlZScsJ1xcXFx1MjEyRic6J2VzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjInOidlZnInLCdcXFxcdUQ4MzVcXFxcdURENTYnOidlb3BmJywnXFxcXHUyMTMwJzonRXNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOCc6J0VmcicsJ1xcXFx1RDgzNVxcXFx1REQzQyc6J0VvcGYnLCdcXFxceEU5JzonZWFjdXRlJywnXFxcXHhDOSc6J0VhY3V0ZScsJ1xcXFx4RTgnOidlZ3JhdmUnLCdcXFxceEM4JzonRWdyYXZlJywnXFxcXHhFQSc6J2VjaXJjJywnXFxcXHhDQSc6J0VjaXJjJywnXFxcXHUwMTFCJzonZWNhcm9uJywnXFxcXHUwMTFBJzonRWNhcm9uJywnXFxcXHhFQic6J2V1bWwnLCdcXFxceENCJzonRXVtbCcsJ1xcXFx1MDExNyc6J2Vkb3QnLCdcXFxcdTAxMTYnOidFZG90JywnXFxcXHUwMTE5JzonZW9nb24nLCdcXFxcdTAxMTgnOidFb2dvbicsJ1xcXFx1MDExMyc6J2VtYWNyJywnXFxcXHUwMTEyJzonRW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMjMnOidmZnInLCdcXFxcdUQ4MzVcXFxcdURENTcnOidmb3BmJywnXFxcXHVEODM1XFxcXHVEQ0JCJzonZnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOSc6J0ZmcicsJ1xcXFx1RDgzNVxcXFx1REQzRCc6J0ZvcGYnLCdcXFxcdTIxMzEnOidGc2NyJywnXFxcXHVGQjAwJzonZmZsaWcnLCdcXFxcdUZCMDMnOidmZmlsaWcnLCdcXFxcdUZCMDQnOidmZmxsaWcnLCdcXFxcdUZCMDEnOidmaWxpZycsJ2ZqJzonZmpsaWcnLCdcXFxcdUZCMDInOidmbGxpZycsJ1xcXFx1MDE5Mic6J2Zub2YnLCdcXFxcdTIxMEEnOidnc2NyJywnXFxcXHVEODM1XFxcXHVERDU4JzonZ29wZicsJ1xcXFx1RDgzNVxcXFx1REQyNCc6J2dmcicsJ1xcXFx1RDgzNVxcXFx1RENBMic6J0dzY3InLCdcXFxcdUQ4MzVcXFxcdUREM0UnOidHb3BmJywnXFxcXHVEODM1XFxcXHVERDBBJzonR2ZyJywnXFxcXHUwMUY1JzonZ2FjdXRlJywnXFxcXHUwMTFGJzonZ2JyZXZlJywnXFxcXHUwMTFFJzonR2JyZXZlJywnXFxcXHUwMTFEJzonZ2NpcmMnLCdcXFxcdTAxMUMnOidHY2lyYycsJ1xcXFx1MDEyMSc6J2dkb3QnLCdcXFxcdTAxMjAnOidHZG90JywnXFxcXHUwMTIyJzonR2NlZGlsJywnXFxcXHVEODM1XFxcXHVERDI1JzonaGZyJywnXFxcXHUyMTBFJzoncGxhbmNraCcsJ1xcXFx1RDgzNVxcXFx1RENCRCc6J2hzY3InLCdcXFxcdUQ4MzVcXFxcdURENTknOidob3BmJywnXFxcXHUyMTBCJzonSHNjcicsJ1xcXFx1MjEwQyc6J0hmcicsJ1xcXFx1MjEwRCc6J0hvcGYnLCdcXFxcdTAxMjUnOidoY2lyYycsJ1xcXFx1MDEyNCc6J0hjaXJjJywnXFxcXHUyMTBGJzonaGJhcicsJ1xcXFx1MDEyNyc6J2hzdHJvaycsJ1xcXFx1MDEyNic6J0hzdHJvaycsJ1xcXFx1RDgzNVxcXFx1REQ1QSc6J2lvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMjYnOidpZnInLCdcXFxcdUQ4MzVcXFxcdURDQkUnOidpc2NyJywnXFxcXHUyMTQ4JzonaWknLCdcXFxcdUQ4MzVcXFxcdURENDAnOidJb3BmJywnXFxcXHUyMTEwJzonSXNjcicsJ1xcXFx1MjExMSc6J0ltJywnXFxcXHhFRCc6J2lhY3V0ZScsJ1xcXFx4Q0QnOidJYWN1dGUnLCdcXFxceEVDJzonaWdyYXZlJywnXFxcXHhDQyc6J0lncmF2ZScsJ1xcXFx4RUUnOidpY2lyYycsJ1xcXFx4Q0UnOidJY2lyYycsJ1xcXFx4RUYnOidpdW1sJywnXFxcXHhDRic6J0l1bWwnLCdcXFxcdTAxMjknOidpdGlsZGUnLCdcXFxcdTAxMjgnOidJdGlsZGUnLCdcXFxcdTAxMzAnOidJZG90JywnXFxcXHUwMTJGJzonaW9nb24nLCdcXFxcdTAxMkUnOidJb2dvbicsJ1xcXFx1MDEyQic6J2ltYWNyJywnXFxcXHUwMTJBJzonSW1hY3InLCdcXFxcdTAxMzMnOidpamxpZycsJ1xcXFx1MDEzMic6J0lKbGlnJywnXFxcXHUwMTMxJzonaW1hdGgnLCdcXFxcdUQ4MzVcXFxcdURDQkYnOidqc2NyJywnXFxcXHVEODM1XFxcXHVERDVCJzonam9wZicsJ1xcXFx1RDgzNVxcXFx1REQyNyc6J2pmcicsJ1xcXFx1RDgzNVxcXFx1RENBNSc6J0pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMEQnOidKZnInLCdcXFxcdUQ4MzVcXFxcdURENDEnOidKb3BmJywnXFxcXHUwMTM1JzonamNpcmMnLCdcXFxcdTAxMzQnOidKY2lyYycsJ1xcXFx1MDIzNyc6J2ptYXRoJywnXFxcXHVEODM1XFxcXHVERDVDJzona29wZicsJ1xcXFx1RDgzNVxcXFx1RENDMCc6J2tzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjgnOidrZnInLCdcXFxcdUQ4MzVcXFxcdURDQTYnOidLc2NyJywnXFxcXHVEODM1XFxcXHVERDQyJzonS29wZicsJ1xcXFx1RDgzNVxcXFx1REQwRSc6J0tmcicsJ1xcXFx1MDEzNyc6J2tjZWRpbCcsJ1xcXFx1MDEzNic6J0tjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQyOSc6J2xmcicsJ1xcXFx1RDgzNVxcXFx1RENDMSc6J2xzY3InLCdcXFxcdTIxMTMnOidlbGwnLCdcXFxcdUQ4MzVcXFxcdURENUQnOidsb3BmJywnXFxcXHUyMTEyJzonTHNjcicsJ1xcXFx1RDgzNVxcXFx1REQwRic6J0xmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Myc6J0xvcGYnLCdcXFxcdTAxM0EnOidsYWN1dGUnLCdcXFxcdTAxMzknOidMYWN1dGUnLCdcXFxcdTAxM0UnOidsY2Fyb24nLCdcXFxcdTAxM0QnOidMY2Fyb24nLCdcXFxcdTAxM0MnOidsY2VkaWwnLCdcXFxcdTAxM0InOidMY2VkaWwnLCdcXFxcdTAxNDInOidsc3Ryb2snLCdcXFxcdTAxNDEnOidMc3Ryb2snLCdcXFxcdTAxNDAnOidsbWlkb3QnLCdcXFxcdTAxM0YnOidMbWlkb3QnLCdcXFxcdUQ4MzVcXFxcdUREMkEnOidtZnInLCdcXFxcdUQ4MzVcXFxcdURENUUnOidtb3BmJywnXFxcXHVEODM1XFxcXHVEQ0MyJzonbXNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMCc6J01mcicsJ1xcXFx1RDgzNVxcXFx1REQ0NCc6J01vcGYnLCdcXFxcdTIxMzMnOidNc2NyJywnXFxcXHVEODM1XFxcXHVERDJCJzonbmZyJywnXFxcXHVEODM1XFxcXHVERDVGJzonbm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDMyc6J25zY3InLCdcXFxcdTIxMTUnOidOb3BmJywnXFxcXHVEODM1XFxcXHVEQ0E5JzonTnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMSc6J05mcicsJ1xcXFx1MDE0NCc6J25hY3V0ZScsJ1xcXFx1MDE0Myc6J05hY3V0ZScsJ1xcXFx1MDE0OCc6J25jYXJvbicsJ1xcXFx1MDE0Nyc6J05jYXJvbicsJ1xcXFx4RjEnOidudGlsZGUnLCdcXFxceEQxJzonTnRpbGRlJywnXFxcXHUwMTQ2JzonbmNlZGlsJywnXFxcXHUwMTQ1JzonTmNlZGlsJywnXFxcXHUyMTE2JzonbnVtZXJvJywnXFxcXHUwMTRCJzonZW5nJywnXFxcXHUwMTRBJzonRU5HJywnXFxcXHVEODM1XFxcXHVERDYwJzonb29wZicsJ1xcXFx1RDgzNVxcXFx1REQyQyc6J29mcicsJ1xcXFx1MjEzNCc6J29zY3InLCdcXFxcdUQ4MzVcXFxcdURDQUEnOidPc2NyJywnXFxcXHVEODM1XFxcXHVERDEyJzonT2ZyJywnXFxcXHVEODM1XFxcXHVERDQ2JzonT29wZicsJ1xcXFx4QkEnOidvcmRtJywnXFxcXHhGMyc6J29hY3V0ZScsJ1xcXFx4RDMnOidPYWN1dGUnLCdcXFxceEYyJzonb2dyYXZlJywnXFxcXHhEMic6J09ncmF2ZScsJ1xcXFx4RjQnOidvY2lyYycsJ1xcXFx4RDQnOidPY2lyYycsJ1xcXFx4RjYnOidvdW1sJywnXFxcXHhENic6J091bWwnLCdcXFxcdTAxNTEnOidvZGJsYWMnLCdcXFxcdTAxNTAnOidPZGJsYWMnLCdcXFxceEY1Jzonb3RpbGRlJywnXFxcXHhENSc6J090aWxkZScsJ1xcXFx4RjgnOidvc2xhc2gnLCdcXFxceEQ4JzonT3NsYXNoJywnXFxcXHUwMTREJzonb21hY3InLCdcXFxcdTAxNEMnOidPbWFjcicsJ1xcXFx1MDE1Myc6J29lbGlnJywnXFxcXHUwMTUyJzonT0VsaWcnLCdcXFxcdUQ4MzVcXFxcdUREMkQnOidwZnInLCdcXFxcdUQ4MzVcXFxcdURDQzUnOidwc2NyJywnXFxcXHVEODM1XFxcXHVERDYxJzoncG9wZicsJ1xcXFx1MjExOSc6J1BvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTMnOidQZnInLCdcXFxcdUQ4MzVcXFxcdURDQUInOidQc2NyJywnXFxcXHVEODM1XFxcXHVERDYyJzoncW9wZicsJ1xcXFx1RDgzNVxcXFx1REQyRSc6J3FmcicsJ1xcXFx1RDgzNVxcXFx1RENDNic6J3FzY3InLCdcXFxcdUQ4MzVcXFxcdURDQUMnOidRc2NyJywnXFxcXHVEODM1XFxcXHVERDE0JzonUWZyJywnXFxcXHUyMTFBJzonUW9wZicsJ1xcXFx1MDEzOCc6J2tncmVlbicsJ1xcXFx1RDgzNVxcXFx1REQyRic6J3JmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Myc6J3JvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzcnOidyc2NyJywnXFxcXHUyMTFCJzonUnNjcicsJ1xcXFx1MjExQyc6J1JlJywnXFxcXHUyMTFEJzonUm9wZicsJ1xcXFx1MDE1NSc6J3JhY3V0ZScsJ1xcXFx1MDE1NCc6J1JhY3V0ZScsJ1xcXFx1MDE1OSc6J3JjYXJvbicsJ1xcXFx1MDE1OCc6J1JjYXJvbicsJ1xcXFx1MDE1Nyc6J3JjZWRpbCcsJ1xcXFx1MDE1Nic6J1JjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQ2NCc6J3NvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzgnOidzc2NyJywnXFxcXHVEODM1XFxcXHVERDMwJzonc2ZyJywnXFxcXHVEODM1XFxcXHVERDRBJzonU29wZicsJ1xcXFx1RDgzNVxcXFx1REQxNic6J1NmcicsJ1xcXFx1RDgzNVxcXFx1RENBRSc6J1NzY3InLCdcXFxcdTI0QzgnOidvUycsJ1xcXFx1MDE1Qic6J3NhY3V0ZScsJ1xcXFx1MDE1QSc6J1NhY3V0ZScsJ1xcXFx1MDE1RCc6J3NjaXJjJywnXFxcXHUwMTVDJzonU2NpcmMnLCdcXFxcdTAxNjEnOidzY2Fyb24nLCdcXFxcdTAxNjAnOidTY2Fyb24nLCdcXFxcdTAxNUYnOidzY2VkaWwnLCdcXFxcdTAxNUUnOidTY2VkaWwnLCdcXFxceERGJzonc3psaWcnLCdcXFxcdUQ4MzVcXFxcdUREMzEnOid0ZnInLCdcXFxcdUQ4MzVcXFxcdURDQzknOid0c2NyJywnXFxcXHVEODM1XFxcXHVERDY1JzondG9wZicsJ1xcXFx1RDgzNVxcXFx1RENBRic6J1RzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTcnOidUZnInLCdcXFxcdUQ4MzVcXFxcdURENEInOidUb3BmJywnXFxcXHUwMTY1JzondGNhcm9uJywnXFxcXHUwMTY0JzonVGNhcm9uJywnXFxcXHUwMTYzJzondGNlZGlsJywnXFxcXHUwMTYyJzonVGNlZGlsJywnXFxcXHUyMTIyJzondHJhZGUnLCdcXFxcdTAxNjcnOid0c3Ryb2snLCdcXFxcdTAxNjYnOidUc3Ryb2snLCdcXFxcdUQ4MzVcXFxcdURDQ0EnOid1c2NyJywnXFxcXHVEODM1XFxcXHVERDY2JzondW9wZicsJ1xcXFx1RDgzNVxcXFx1REQzMic6J3VmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Qyc6J1VvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTgnOidVZnInLCdcXFxcdUQ4MzVcXFxcdURDQjAnOidVc2NyJywnXFxcXHhGQSc6J3VhY3V0ZScsJ1xcXFx4REEnOidVYWN1dGUnLCdcXFxceEY5JzondWdyYXZlJywnXFxcXHhEOSc6J1VncmF2ZScsJ1xcXFx1MDE2RCc6J3VicmV2ZScsJ1xcXFx1MDE2Qyc6J1VicmV2ZScsJ1xcXFx4RkInOid1Y2lyYycsJ1xcXFx4REInOidVY2lyYycsJ1xcXFx1MDE2Ric6J3VyaW5nJywnXFxcXHUwMTZFJzonVXJpbmcnLCdcXFxceEZDJzondXVtbCcsJ1xcXFx4REMnOidVdW1sJywnXFxcXHUwMTcxJzondWRibGFjJywnXFxcXHUwMTcwJzonVWRibGFjJywnXFxcXHUwMTY5JzondXRpbGRlJywnXFxcXHUwMTY4JzonVXRpbGRlJywnXFxcXHUwMTczJzondW9nb24nLCdcXFxcdTAxNzInOidVb2dvbicsJ1xcXFx1MDE2Qic6J3VtYWNyJywnXFxcXHUwMTZBJzonVW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMzMnOid2ZnInLCdcXFxcdUQ4MzVcXFxcdURENjcnOid2b3BmJywnXFxcXHVEODM1XFxcXHVEQ0NCJzondnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxOSc6J1ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ0RCc6J1ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjEnOidWc2NyJywnXFxcXHVEODM1XFxcXHVERDY4Jzond29wZicsJ1xcXFx1RDgzNVxcXFx1RENDQyc6J3dzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzQnOid3ZnInLCdcXFxcdUQ4MzVcXFxcdURDQjInOidXc2NyJywnXFxcXHVEODM1XFxcXHVERDRFJzonV29wZicsJ1xcXFx1RDgzNVxcXFx1REQxQSc6J1dmcicsJ1xcXFx1MDE3NSc6J3djaXJjJywnXFxcXHUwMTc0JzonV2NpcmMnLCdcXFxcdUQ4MzVcXFxcdUREMzUnOid4ZnInLCdcXFxcdUQ4MzVcXFxcdURDQ0QnOid4c2NyJywnXFxcXHVEODM1XFxcXHVERDY5JzoneG9wZicsJ1xcXFx1RDgzNVxcXFx1REQ0Ric6J1hvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUInOidYZnInLCdcXFxcdUQ4MzVcXFxcdURDQjMnOidYc2NyJywnXFxcXHVEODM1XFxcXHVERDM2JzoneWZyJywnXFxcXHVEODM1XFxcXHVEQ0NFJzoneXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2QSc6J3lvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjQnOidZc2NyJywnXFxcXHVEODM1XFxcXHVERDFDJzonWWZyJywnXFxcXHVEODM1XFxcXHVERDUwJzonWW9wZicsJ1xcXFx4RkQnOid5YWN1dGUnLCdcXFxceEREJzonWWFjdXRlJywnXFxcXHUwMTc3JzoneWNpcmMnLCdcXFxcdTAxNzYnOidZY2lyYycsJ1xcXFx4RkYnOid5dW1sJywnXFxcXHUwMTc4JzonWXVtbCcsJ1xcXFx1RDgzNVxcXFx1RENDRic6J3pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzcnOid6ZnInLCdcXFxcdUQ4MzVcXFxcdURENkInOid6b3BmJywnXFxcXHUyMTI4JzonWmZyJywnXFxcXHUyMTI0JzonWm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCNSc6J1pzY3InLCdcXFxcdTAxN0EnOid6YWN1dGUnLCdcXFxcdTAxNzknOidaYWN1dGUnLCdcXFxcdTAxN0UnOid6Y2Fyb24nLCdcXFxcdTAxN0QnOidaY2Fyb24nLCdcXFxcdTAxN0MnOid6ZG90JywnXFxcXHUwMTdCJzonWmRvdCcsJ1xcXFx1MDFCNSc6J2ltcGVkJywnXFxcXHhGRSc6J3Rob3JuJywnXFxcXHhERSc6J1RIT1JOJywnXFxcXHUwMTQ5JzonbmFwb3MnLCdcXFxcdTAzQjEnOidhbHBoYScsJ1xcXFx1MDM5MSc6J0FscGhhJywnXFxcXHUwM0IyJzonYmV0YScsJ1xcXFx1MDM5Mic6J0JldGEnLCdcXFxcdTAzQjMnOidnYW1tYScsJ1xcXFx1MDM5Myc6J0dhbW1hJywnXFxcXHUwM0I0JzonZGVsdGEnLCdcXFxcdTAzOTQnOidEZWx0YScsJ1xcXFx1MDNCNSc6J2Vwc2knLCdcXFxcdTAzRjUnOidlcHNpdicsJ1xcXFx1MDM5NSc6J0Vwc2lsb24nLCdcXFxcdTAzREQnOidnYW1tYWQnLCdcXFxcdTAzREMnOidHYW1tYWQnLCdcXFxcdTAzQjYnOid6ZXRhJywnXFxcXHUwMzk2JzonWmV0YScsJ1xcXFx1MDNCNyc6J2V0YScsJ1xcXFx1MDM5Nyc6J0V0YScsJ1xcXFx1MDNCOCc6J3RoZXRhJywnXFxcXHUwM0QxJzondGhldGF2JywnXFxcXHUwMzk4JzonVGhldGEnLCdcXFxcdTAzQjknOidpb3RhJywnXFxcXHUwMzk5JzonSW90YScsJ1xcXFx1MDNCQSc6J2thcHBhJywnXFxcXHUwM0YwJzona2FwcGF2JywnXFxcXHUwMzlBJzonS2FwcGEnLCdcXFxcdTAzQkInOidsYW1iZGEnLCdcXFxcdTAzOUInOidMYW1iZGEnLCdcXFxcdTAzQkMnOidtdScsJ1xcXFx4QjUnOidtaWNybycsJ1xcXFx1MDM5Qyc6J011JywnXFxcXHUwM0JEJzonbnUnLCdcXFxcdTAzOUQnOidOdScsJ1xcXFx1MDNCRSc6J3hpJywnXFxcXHUwMzlFJzonWGknLCdcXFxcdTAzQkYnOidvbWljcm9uJywnXFxcXHUwMzlGJzonT21pY3JvbicsJ1xcXFx1MDNDMCc6J3BpJywnXFxcXHUwM0Q2JzoncGl2JywnXFxcXHUwM0EwJzonUGknLCdcXFxcdTAzQzEnOidyaG8nLCdcXFxcdTAzRjEnOidyaG92JywnXFxcXHUwM0ExJzonUmhvJywnXFxcXHUwM0MzJzonc2lnbWEnLCdcXFxcdTAzQTMnOidTaWdtYScsJ1xcXFx1MDNDMic6J3NpZ21hZicsJ1xcXFx1MDNDNCc6J3RhdScsJ1xcXFx1MDNBNCc6J1RhdScsJ1xcXFx1MDNDNSc6J3Vwc2knLCdcXFxcdTAzQTUnOidVcHNpbG9uJywnXFxcXHUwM0QyJzonVXBzaScsJ1xcXFx1MDNDNic6J3BoaScsJ1xcXFx1MDNENSc6J3BoaXYnLCdcXFxcdTAzQTYnOidQaGknLCdcXFxcdTAzQzcnOidjaGknLCdcXFxcdTAzQTcnOidDaGknLCdcXFxcdTAzQzgnOidwc2knLCdcXFxcdTAzQTgnOidQc2knLCdcXFxcdTAzQzknOidvbWVnYScsJ1xcXFx1MDNBOSc6J29obScsJ1xcXFx1MDQzMCc6J2FjeScsJ1xcXFx1MDQxMCc6J0FjeScsJ1xcXFx1MDQzMSc6J2JjeScsJ1xcXFx1MDQxMSc6J0JjeScsJ1xcXFx1MDQzMic6J3ZjeScsJ1xcXFx1MDQxMic6J1ZjeScsJ1xcXFx1MDQzMyc6J2djeScsJ1xcXFx1MDQxMyc6J0djeScsJ1xcXFx1MDQ1Myc6J2dqY3knLCdcXFxcdTA0MDMnOidHSmN5JywnXFxcXHUwNDM0JzonZGN5JywnXFxcXHUwNDE0JzonRGN5JywnXFxcXHUwNDUyJzonZGpjeScsJ1xcXFx1MDQwMic6J0RKY3knLCdcXFxcdTA0MzUnOidpZWN5JywnXFxcXHUwNDE1JzonSUVjeScsJ1xcXFx1MDQ1MSc6J2lvY3knLCdcXFxcdTA0MDEnOidJT2N5JywnXFxcXHUwNDU0JzonanVrY3knLCdcXFxcdTA0MDQnOidKdWtjeScsJ1xcXFx1MDQzNic6J3poY3knLCdcXFxcdTA0MTYnOidaSGN5JywnXFxcXHUwNDM3JzonemN5JywnXFxcXHUwNDE3JzonWmN5JywnXFxcXHUwNDU1JzonZHNjeScsJ1xcXFx1MDQwNSc6J0RTY3knLCdcXFxcdTA0MzgnOidpY3knLCdcXFxcdTA0MTgnOidJY3knLCdcXFxcdTA0NTYnOidpdWtjeScsJ1xcXFx1MDQwNic6J0l1a2N5JywnXFxcXHUwNDU3JzoneWljeScsJ1xcXFx1MDQwNyc6J1lJY3knLCdcXFxcdTA0MzknOidqY3knLCdcXFxcdTA0MTknOidKY3knLCdcXFxcdTA0NTgnOidqc2VyY3knLCdcXFxcdTA0MDgnOidKc2VyY3knLCdcXFxcdTA0M0EnOidrY3knLCdcXFxcdTA0MUEnOidLY3knLCdcXFxcdTA0NUMnOidramN5JywnXFxcXHUwNDBDJzonS0pjeScsJ1xcXFx1MDQzQic6J2xjeScsJ1xcXFx1MDQxQic6J0xjeScsJ1xcXFx1MDQ1OSc6J2xqY3knLCdcXFxcdTA0MDknOidMSmN5JywnXFxcXHUwNDNDJzonbWN5JywnXFxcXHUwNDFDJzonTWN5JywnXFxcXHUwNDNEJzonbmN5JywnXFxcXHUwNDFEJzonTmN5JywnXFxcXHUwNDVBJzonbmpjeScsJ1xcXFx1MDQwQSc6J05KY3knLCdcXFxcdTA0M0UnOidvY3knLCdcXFxcdTA0MUUnOidPY3knLCdcXFxcdTA0M0YnOidwY3knLCdcXFxcdTA0MUYnOidQY3knLCdcXFxcdTA0NDAnOidyY3knLCdcXFxcdTA0MjAnOidSY3knLCdcXFxcdTA0NDEnOidzY3knLCdcXFxcdTA0MjEnOidTY3knLCdcXFxcdTA0NDInOid0Y3knLCdcXFxcdTA0MjInOidUY3knLCdcXFxcdTA0NUInOid0c2hjeScsJ1xcXFx1MDQwQic6J1RTSGN5JywnXFxcXHUwNDQzJzondWN5JywnXFxcXHUwNDIzJzonVWN5JywnXFxcXHUwNDVFJzondWJyY3knLCdcXFxcdTA0MEUnOidVYnJjeScsJ1xcXFx1MDQ0NCc6J2ZjeScsJ1xcXFx1MDQyNCc6J0ZjeScsJ1xcXFx1MDQ0NSc6J2toY3knLCdcXFxcdTA0MjUnOidLSGN5JywnXFxcXHUwNDQ2JzondHNjeScsJ1xcXFx1MDQyNic6J1RTY3knLCdcXFxcdTA0NDcnOidjaGN5JywnXFxcXHUwNDI3JzonQ0hjeScsJ1xcXFx1MDQ1Ric6J2R6Y3knLCdcXFxcdTA0MEYnOidEWmN5JywnXFxcXHUwNDQ4Jzonc2hjeScsJ1xcXFx1MDQyOCc6J1NIY3knLCdcXFxcdTA0NDknOidzaGNoY3knLCdcXFxcdTA0MjknOidTSENIY3knLCdcXFxcdTA0NEEnOidoYXJkY3knLCdcXFxcdTA0MkEnOidIQVJEY3knLCdcXFxcdTA0NEInOid5Y3knLCdcXFxcdTA0MkInOidZY3knLCdcXFxcdTA0NEMnOidzb2Z0Y3knLCdcXFxcdTA0MkMnOidTT0ZUY3knLCdcXFxcdTA0NEQnOidlY3knLCdcXFxcdTA0MkQnOidFY3knLCdcXFxcdTA0NEUnOid5dWN5JywnXFxcXHUwNDJFJzonWVVjeScsJ1xcXFx1MDQ0Ric6J3lhY3knLCdcXFxcdTA0MkYnOidZQWN5JywnXFxcXHUyMTM1JzonYWxlcGgnLCdcXFxcdTIxMzYnOidiZXRoJywnXFxcXHUyMTM3JzonZ2ltZWwnLCdcXFxcdTIxMzgnOidkYWxldGgnfTtcXG5cXG5cXHR2YXIgcmVnZXhFc2NhcGUgPSAvW1xcXCImJzw+YF0vZztcXG5cXHR2YXIgZXNjYXBlTWFwID0ge1xcblxcdFxcdCdcXFwiJzogJyZxdW90OycsXFxuXFx0XFx0JyYnOiAnJmFtcDsnLFxcblxcdFxcdCdcXFxcJyc6ICcmI3gyNzsnLFxcblxcdFxcdCc8JzogJyZsdDsnLFxcblxcdFxcdC8vIFNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHM6IGluIEhUTUwsIHRoZVxcblxcdFxcdC8vIGZvbGxvd2luZyBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IHVubGVzcyBpdOKAmXMgcGFydCBvZiBhIHRhZyBvciBhblxcblxcdFxcdC8vIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gV2XigJlyZSBvbmx5IGVzY2FwaW5nIGl0IHRvIHN1cHBvcnQgdGhvc2VcXG5cXHRcXHQvLyBzaXR1YXRpb25zLCBhbmQgZm9yIFhNTCBzdXBwb3J0LlxcblxcdFxcdCc+JzogJyZndDsnLFxcblxcdFxcdC8vIEluIEludGVybmV0IEV4cGxvcmVyIOKJpCA4LCB0aGUgYmFja3RpY2sgY2hhcmFjdGVyIGNhbiBiZSB1c2VkXFxuXFx0XFx0Ly8gdG8gYnJlYWsgb3V0IG9mICh1bilxdW90ZWQgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLlxcblxcdFxcdC8vIFNlZSBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDIsIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwOCwgYW5kXFxuXFx0XFx0Ly8gaHR0cDovL2h0bWw1c2VjLm9yZy8jMTMzLlxcblxcdFxcdCdgJzogJyYjeDYwOydcXG5cXHR9O1xcblxcblxcdHZhciByZWdleEludmFsaWRFbnRpdHkgPSAvJiMoPzpbeFhdW15hLWZBLUYwLTldfFteMC05eFhdKS87XFxuXFx0dmFyIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludCA9IC9bXFxcXDAtXFxcXHgwOFxcXFx4MEJcXFxceDBFLVxcXFx4MUZcXFxceDdGLVxcXFx4OUZcXFxcdUZERDAtXFxcXHVGREVGXFxcXHVGRkZFXFxcXHVGRkZGXXxbXFxcXHVEODNGXFxcXHVEODdGXFxcXHVEOEJGXFxcXHVEOEZGXFxcXHVEOTNGXFxcXHVEOTdGXFxcXHVEOUJGXFxcXHVEOUZGXFxcXHVEQTNGXFxcXHVEQTdGXFxcXHVEQUJGXFxcXHVEQUZGXFxcXHVEQjNGXFxcXHVEQjdGXFxcXHVEQkJGXFxcXHVEQkZGXVtcXFxcdURGRkVcXFxcdURGRkZdfFtcXFxcdUQ4MDAtXFxcXHVEQkZGXSg/IVtcXFxcdURDMDAtXFxcXHVERkZGXSl8KD86W15cXFxcdUQ4MDAtXFxcXHVEQkZGXXxeKVtcXFxcdURDMDAtXFxcXHVERkZGXS87XFxuXFx0dmFyIHJlZ2V4RGVjb2RlID0gLyYjKFswLTldKykoOz8pfCYjW3hYXShbYS1mQS1GMC05XSspKDs/KXwmKFswLTlhLXpBLVpdKyk7fCYoQWFjdXRlfEFncmF2ZXxBdGlsZGV8Q2NlZGlsfEVhY3V0ZXxFZ3JhdmV8SWFjdXRlfElncmF2ZXxOdGlsZGV8T2FjdXRlfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfFVhY3V0ZXxVZ3JhdmV8WWFjdXRlfGFhY3V0ZXxhZ3JhdmV8YXRpbGRlfGJydmJhcnxjY2VkaWx8Y3VycmVufGRpdmlkZXxlYWN1dGV8ZWdyYXZlfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGlhY3V0ZXxpZ3JhdmV8aXF1ZXN0fG1pZGRvdHxudGlsZGV8b2FjdXRlfG9ncmF2ZXxvc2xhc2h8b3RpbGRlfHBsdXNtbnx1YWN1dGV8dWdyYXZlfHlhY3V0ZXxBRWxpZ3xBY2lyY3xBcmluZ3xFY2lyY3xJY2lyY3xPY2lyY3xUSE9STnxVY2lyY3xhY2lyY3xhY3V0ZXxhZWxpZ3xhcmluZ3xjZWRpbHxlY2lyY3xpY2lyY3xpZXhjbHxsYXF1b3xtaWNyb3xvY2lyY3xwb3VuZHxyYXF1b3xzemxpZ3x0aG9ybnx0aW1lc3x1Y2lyY3xBdW1sfENPUFl8RXVtbHxJdW1sfE91bWx8UVVPVHxVdW1sfGF1bWx8Y2VudHxjb3B5fGV1bWx8aXVtbHxtYWNyfG5ic3B8b3JkZnxvcmRtfG91bWx8cGFyYXxxdW90fHNlY3R8c3VwMXxzdXAyfHN1cDN8dXVtbHx5dW1sfEFNUHxFVEh8UkVHfGFtcHxkZWd8ZXRofG5vdHxyZWd8c2h5fHVtbHx5ZW58R1R8TFR8Z3R8bHQpKFs9YS16QS1aMC05XSk/L2c7XFxuXFx0dmFyIGRlY29kZU1hcCA9IHsnYWFjdXRlJzonXFxcXHhFMScsJ0FhY3V0ZSc6J1xcXFx4QzEnLCdhYnJldmUnOidcXFxcdTAxMDMnLCdBYnJldmUnOidcXFxcdTAxMDInLCdhYyc6J1xcXFx1MjIzRScsJ2FjZCc6J1xcXFx1MjIzRicsJ2FjRSc6J1xcXFx1MjIzRVxcXFx1MDMzMycsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FjeSc6J1xcXFx1MDQzMCcsJ0FjeSc6J1xcXFx1MDQxMCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FmJzonXFxcXHUyMDYxJywnYWZyJzonXFxcXHVEODM1XFxcXHVERDFFJywnQWZyJzonXFxcXHVEODM1XFxcXHVERDA0JywnYWdyYXZlJzonXFxcXHhFMCcsJ0FncmF2ZSc6J1xcXFx4QzAnLCdhbGVmc3ltJzonXFxcXHUyMTM1JywnYWxlcGgnOidcXFxcdTIxMzUnLCdhbHBoYSc6J1xcXFx1MDNCMScsJ0FscGhhJzonXFxcXHUwMzkxJywnYW1hY3InOidcXFxcdTAxMDEnLCdBbWFjcic6J1xcXFx1MDEwMCcsJ2FtYWxnJzonXFxcXHUyQTNGJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhbmQnOidcXFxcdTIyMjcnLCdBbmQnOidcXFxcdTJBNTMnLCdhbmRhbmQnOidcXFxcdTJBNTUnLCdhbmRkJzonXFxcXHUyQTVDJywnYW5kc2xvcGUnOidcXFxcdTJBNTgnLCdhbmR2JzonXFxcXHUyQTVBJywnYW5nJzonXFxcXHUyMjIwJywnYW5nZSc6J1xcXFx1MjlBNCcsJ2FuZ2xlJzonXFxcXHUyMjIwJywnYW5nbXNkJzonXFxcXHUyMjIxJywnYW5nbXNkYWEnOidcXFxcdTI5QTgnLCdhbmdtc2RhYic6J1xcXFx1MjlBOScsJ2FuZ21zZGFjJzonXFxcXHUyOUFBJywnYW5nbXNkYWQnOidcXFxcdTI5QUInLCdhbmdtc2RhZSc6J1xcXFx1MjlBQycsJ2FuZ21zZGFmJzonXFxcXHUyOUFEJywnYW5nbXNkYWcnOidcXFxcdTI5QUUnLCdhbmdtc2RhaCc6J1xcXFx1MjlBRicsJ2FuZ3J0JzonXFxcXHUyMjFGJywnYW5ncnR2Yic6J1xcXFx1MjJCRScsJ2FuZ3J0dmJkJzonXFxcXHUyOTlEJywnYW5nc3BoJzonXFxcXHUyMjIyJywnYW5nc3QnOidcXFxceEM1JywnYW5nemFycic6J1xcXFx1MjM3QycsJ2FvZ29uJzonXFxcXHUwMTA1JywnQW9nb24nOidcXFxcdTAxMDQnLCdhb3BmJzonXFxcXHVEODM1XFxcXHVERDUyJywnQW9wZic6J1xcXFx1RDgzNVxcXFx1REQzOCcsJ2FwJzonXFxcXHUyMjQ4JywnYXBhY2lyJzonXFxcXHUyQTZGJywnYXBlJzonXFxcXHUyMjRBJywnYXBFJzonXFxcXHUyQTcwJywnYXBpZCc6J1xcXFx1MjI0QicsJ2Fwb3MnOidcXFxcJycsJ0FwcGx5RnVuY3Rpb24nOidcXFxcdTIwNjEnLCdhcHByb3gnOidcXFxcdTIyNDgnLCdhcHByb3hlcSc6J1xcXFx1MjI0QScsJ2FyaW5nJzonXFxcXHhFNScsJ0FyaW5nJzonXFxcXHhDNScsJ2FzY3InOidcXFxcdUQ4MzVcXFxcdURDQjYnLCdBc2NyJzonXFxcXHVEODM1XFxcXHVEQzlDJywnQXNzaWduJzonXFxcXHUyMjU0JywnYXN0JzonKicsJ2FzeW1wJzonXFxcXHUyMjQ4JywnYXN5bXBlcSc6J1xcXFx1MjI0RCcsJ2F0aWxkZSc6J1xcXFx4RTMnLCdBdGlsZGUnOidcXFxceEMzJywnYXVtbCc6J1xcXFx4RTQnLCdBdW1sJzonXFxcXHhDNCcsJ2F3Y29uaW50JzonXFxcXHUyMjMzJywnYXdpbnQnOidcXFxcdTJBMTEnLCdiYWNrY29uZyc6J1xcXFx1MjI0QycsJ2JhY2tlcHNpbG9uJzonXFxcXHUwM0Y2JywnYmFja3ByaW1lJzonXFxcXHUyMDM1JywnYmFja3NpbSc6J1xcXFx1MjIzRCcsJ2JhY2tzaW1lcSc6J1xcXFx1MjJDRCcsJ0JhY2tzbGFzaCc6J1xcXFx1MjIxNicsJ0JhcnYnOidcXFxcdTJBRTcnLCdiYXJ2ZWUnOidcXFxcdTIyQkQnLCdiYXJ3ZWQnOidcXFxcdTIzMDUnLCdCYXJ3ZWQnOidcXFxcdTIzMDYnLCdiYXJ3ZWRnZSc6J1xcXFx1MjMwNScsJ2JicmsnOidcXFxcdTIzQjUnLCdiYnJrdGJyayc6J1xcXFx1MjNCNicsJ2Jjb25nJzonXFxcXHUyMjRDJywnYmN5JzonXFxcXHUwNDMxJywnQmN5JzonXFxcXHUwNDExJywnYmRxdW8nOidcXFxcdTIwMUUnLCdiZWNhdXMnOidcXFxcdTIyMzUnLCdiZWNhdXNlJzonXFxcXHUyMjM1JywnQmVjYXVzZSc6J1xcXFx1MjIzNScsJ2JlbXB0eXYnOidcXFxcdTI5QjAnLCdiZXBzaSc6J1xcXFx1MDNGNicsJ2Jlcm5vdSc6J1xcXFx1MjEyQycsJ0Jlcm5vdWxsaXMnOidcXFxcdTIxMkMnLCdiZXRhJzonXFxcXHUwM0IyJywnQmV0YSc6J1xcXFx1MDM5MicsJ2JldGgnOidcXFxcdTIxMzYnLCdiZXR3ZWVuJzonXFxcXHUyMjZDJywnYmZyJzonXFxcXHVEODM1XFxcXHVERDFGJywnQmZyJzonXFxcXHVEODM1XFxcXHVERDA1JywnYmlnY2FwJzonXFxcXHUyMkMyJywnYmlnY2lyYyc6J1xcXFx1MjVFRicsJ2JpZ2N1cCc6J1xcXFx1MjJDMycsJ2JpZ29kb3QnOidcXFxcdTJBMDAnLCdiaWdvcGx1cyc6J1xcXFx1MkEwMScsJ2JpZ290aW1lcyc6J1xcXFx1MkEwMicsJ2JpZ3NxY3VwJzonXFxcXHUyQTA2JywnYmlnc3Rhcic6J1xcXFx1MjYwNScsJ2JpZ3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRCcsJ2JpZ3RyaWFuZ2xldXAnOidcXFxcdTI1QjMnLCdiaWd1cGx1cyc6J1xcXFx1MkEwNCcsJ2JpZ3ZlZSc6J1xcXFx1MjJDMScsJ2JpZ3dlZGdlJzonXFxcXHUyMkMwJywnYmthcm93JzonXFxcXHUyOTBEJywnYmxhY2tsb3plbmdlJzonXFxcXHUyOUVCJywnYmxhY2tzcXVhcmUnOidcXFxcdTI1QUEnLCdibGFja3RyaWFuZ2xlJzonXFxcXHUyNUI0JywnYmxhY2t0cmlhbmdsZWRvd24nOidcXFxcdTI1QkUnLCdibGFja3RyaWFuZ2xlbGVmdCc6J1xcXFx1MjVDMicsJ2JsYWNrdHJpYW5nbGVyaWdodCc6J1xcXFx1MjVCOCcsJ2JsYW5rJzonXFxcXHUyNDIzJywnYmxrMTInOidcXFxcdTI1OTInLCdibGsxNCc6J1xcXFx1MjU5MScsJ2JsazM0JzonXFxcXHUyNTkzJywnYmxvY2snOidcXFxcdTI1ODgnLCdibmUnOic9XFxcXHUyMEU1JywnYm5lcXVpdic6J1xcXFx1MjI2MVxcXFx1MjBFNScsJ2Jub3QnOidcXFxcdTIzMTAnLCdiTm90JzonXFxcXHUyQUVEJywnYm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MycsJ0JvcGYnOidcXFxcdUQ4MzVcXFxcdUREMzknLCdib3QnOidcXFxcdTIyQTUnLCdib3R0b20nOidcXFxcdTIyQTUnLCdib3d0aWUnOidcXFxcdTIyQzgnLCdib3hib3gnOidcXFxcdTI5QzknLCdib3hkbCc6J1xcXFx1MjUxMCcsJ2JveGRMJzonXFxcXHUyNTU1JywnYm94RGwnOidcXFxcdTI1NTYnLCdib3hETCc6J1xcXFx1MjU1NycsJ2JveGRyJzonXFxcXHUyNTBDJywnYm94ZFInOidcXFxcdTI1NTInLCdib3hEcic6J1xcXFx1MjU1MycsJ2JveERSJzonXFxcXHUyNTU0JywnYm94aCc6J1xcXFx1MjUwMCcsJ2JveEgnOidcXFxcdTI1NTAnLCdib3hoZCc6J1xcXFx1MjUyQycsJ2JveGhEJzonXFxcXHUyNTY1JywnYm94SGQnOidcXFxcdTI1NjQnLCdib3hIRCc6J1xcXFx1MjU2NicsJ2JveGh1JzonXFxcXHUyNTM0JywnYm94aFUnOidcXFxcdTI1NjgnLCdib3hIdSc6J1xcXFx1MjU2NycsJ2JveEhVJzonXFxcXHUyNTY5JywnYm94bWludXMnOidcXFxcdTIyOUYnLCdib3hwbHVzJzonXFxcXHUyMjlFJywnYm94dGltZXMnOidcXFxcdTIyQTAnLCdib3h1bCc6J1xcXFx1MjUxOCcsJ2JveHVMJzonXFxcXHUyNTVCJywnYm94VWwnOidcXFxcdTI1NUMnLCdib3hVTCc6J1xcXFx1MjU1RCcsJ2JveHVyJzonXFxcXHUyNTE0JywnYm94dVInOidcXFxcdTI1NTgnLCdib3hVcic6J1xcXFx1MjU1OScsJ2JveFVSJzonXFxcXHUyNTVBJywnYm94dic6J1xcXFx1MjUwMicsJ2JveFYnOidcXFxcdTI1NTEnLCdib3h2aCc6J1xcXFx1MjUzQycsJ2JveHZIJzonXFxcXHUyNTZBJywnYm94VmgnOidcXFxcdTI1NkInLCdib3hWSCc6J1xcXFx1MjU2QycsJ2JveHZsJzonXFxcXHUyNTI0JywnYm94dkwnOidcXFxcdTI1NjEnLCdib3hWbCc6J1xcXFx1MjU2MicsJ2JveFZMJzonXFxcXHUyNTYzJywnYm94dnInOidcXFxcdTI1MUMnLCdib3h2Uic6J1xcXFx1MjU1RScsJ2JveFZyJzonXFxcXHUyNTVGJywnYm94VlInOidcXFxcdTI1NjAnLCdicHJpbWUnOidcXFxcdTIwMzUnLCdicmV2ZSc6J1xcXFx1MDJEOCcsJ0JyZXZlJzonXFxcXHUwMkQ4JywnYnJ2YmFyJzonXFxcXHhBNicsJ2JzY3InOidcXFxcdUQ4MzVcXFxcdURDQjcnLCdCc2NyJzonXFxcXHUyMTJDJywnYnNlbWknOidcXFxcdTIwNEYnLCdic2ltJzonXFxcXHUyMjNEJywnYnNpbWUnOidcXFxcdTIyQ0QnLCdic29sJzonXFxcXFxcXFwnLCdic29sYic6J1xcXFx1MjlDNScsJ2Jzb2xoc3ViJzonXFxcXHUyN0M4JywnYnVsbCc6J1xcXFx1MjAyMicsJ2J1bGxldCc6J1xcXFx1MjAyMicsJ2J1bXAnOidcXFxcdTIyNEUnLCdidW1wZSc6J1xcXFx1MjI0RicsJ2J1bXBFJzonXFxcXHUyQUFFJywnYnVtcGVxJzonXFxcXHUyMjRGJywnQnVtcGVxJzonXFxcXHUyMjRFJywnY2FjdXRlJzonXFxcXHUwMTA3JywnQ2FjdXRlJzonXFxcXHUwMTA2JywnY2FwJzonXFxcXHUyMjI5JywnQ2FwJzonXFxcXHUyMkQyJywnY2FwYW5kJzonXFxcXHUyQTQ0JywnY2FwYnJjdXAnOidcXFxcdTJBNDknLCdjYXBjYXAnOidcXFxcdTJBNEInLCdjYXBjdXAnOidcXFxcdTJBNDcnLCdjYXBkb3QnOidcXFxcdTJBNDAnLCdDYXBpdGFsRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NScsJ2NhcHMnOidcXFxcdTIyMjlcXFxcdUZFMDAnLCdjYXJldCc6J1xcXFx1MjA0MScsJ2Nhcm9uJzonXFxcXHUwMkM3JywnQ2F5bGV5cyc6J1xcXFx1MjEyRCcsJ2NjYXBzJzonXFxcXHUyQTREJywnY2Nhcm9uJzonXFxcXHUwMTBEJywnQ2Nhcm9uJzonXFxcXHUwMTBDJywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjY2lyYyc6J1xcXFx1MDEwOScsJ0NjaXJjJzonXFxcXHUwMTA4JywnQ2NvbmludCc6J1xcXFx1MjIzMCcsJ2NjdXBzJzonXFxcXHUyQTRDJywnY2N1cHNzbSc6J1xcXFx1MkE1MCcsJ2Nkb3QnOidcXFxcdTAxMEInLCdDZG90JzonXFxcXHUwMTBBJywnY2VkaWwnOidcXFxceEI4JywnQ2VkaWxsYSc6J1xcXFx4QjgnLCdjZW1wdHl2JzonXFxcXHUyOUIyJywnY2VudCc6J1xcXFx4QTInLCdjZW50ZXJkb3QnOidcXFxceEI3JywnQ2VudGVyRG90JzonXFxcXHhCNycsJ2Nmcic6J1xcXFx1RDgzNVxcXFx1REQyMCcsJ0Nmcic6J1xcXFx1MjEyRCcsJ2NoY3knOidcXFxcdTA0NDcnLCdDSGN5JzonXFxcXHUwNDI3JywnY2hlY2snOidcXFxcdTI3MTMnLCdjaGVja21hcmsnOidcXFxcdTI3MTMnLCdjaGknOidcXFxcdTAzQzcnLCdDaGknOidcXFxcdTAzQTcnLCdjaXInOidcXFxcdTI1Q0InLCdjaXJjJzonXFxcXHUwMkM2JywnY2lyY2VxJzonXFxcXHUyMjU3JywnY2lyY2xlYXJyb3dsZWZ0JzonXFxcXHUyMUJBJywnY2lyY2xlYXJyb3dyaWdodCc6J1xcXFx1MjFCQicsJ2NpcmNsZWRhc3QnOidcXFxcdTIyOUInLCdjaXJjbGVkY2lyYyc6J1xcXFx1MjI5QScsJ2NpcmNsZWRkYXNoJzonXFxcXHUyMjlEJywnQ2lyY2xlRG90JzonXFxcXHUyMjk5JywnY2lyY2xlZFInOidcXFxceEFFJywnY2lyY2xlZFMnOidcXFxcdTI0QzgnLCdDaXJjbGVNaW51cyc6J1xcXFx1MjI5NicsJ0NpcmNsZVBsdXMnOidcXFxcdTIyOTUnLCdDaXJjbGVUaW1lcyc6J1xcXFx1MjI5NycsJ2NpcmUnOidcXFxcdTIyNTcnLCdjaXJFJzonXFxcXHUyOUMzJywnY2lyZm5pbnQnOidcXFxcdTJBMTAnLCdjaXJtaWQnOidcXFxcdTJBRUYnLCdjaXJzY2lyJzonXFxcXHUyOUMyJywnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFxcXHUyMjMyJywnQ2xvc2VDdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFEJywnQ2xvc2VDdXJseVF1b3RlJzonXFxcXHUyMDE5JywnY2x1YnMnOidcXFxcdTI2NjMnLCdjbHVic3VpdCc6J1xcXFx1MjY2MycsJ2NvbG9uJzonOicsJ0NvbG9uJzonXFxcXHUyMjM3JywnY29sb25lJzonXFxcXHUyMjU0JywnQ29sb25lJzonXFxcXHUyQTc0JywnY29sb25lcSc6J1xcXFx1MjI1NCcsJ2NvbW1hJzonLCcsJ2NvbW1hdCc6J0AnLCdjb21wJzonXFxcXHUyMjAxJywnY29tcGZuJzonXFxcXHUyMjE4JywnY29tcGxlbWVudCc6J1xcXFx1MjIwMScsJ2NvbXBsZXhlcyc6J1xcXFx1MjEwMicsJ2NvbmcnOidcXFxcdTIyNDUnLCdjb25nZG90JzonXFxcXHUyQTZEJywnQ29uZ3J1ZW50JzonXFxcXHUyMjYxJywnY29uaW50JzonXFxcXHUyMjJFJywnQ29uaW50JzonXFxcXHUyMjJGJywnQ29udG91ckludGVncmFsJzonXFxcXHUyMjJFJywnY29wZic6J1xcXFx1RDgzNVxcXFx1REQ1NCcsJ0NvcGYnOidcXFxcdTIxMDInLCdjb3Byb2QnOidcXFxcdTIyMTAnLCdDb3Byb2R1Y3QnOidcXFxcdTIyMTAnLCdjb3B5JzonXFxcXHhBOScsJ0NPUFknOidcXFxceEE5JywnY29weXNyJzonXFxcXHUyMTE3JywnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIzMycsJ2NyYXJyJzonXFxcXHUyMUI1JywnY3Jvc3MnOidcXFxcdTI3MTcnLCdDcm9zcyc6J1xcXFx1MkEyRicsJ2NzY3InOidcXFxcdUQ4MzVcXFxcdURDQjgnLCdDc2NyJzonXFxcXHVEODM1XFxcXHVEQzlFJywnY3N1Yic6J1xcXFx1MkFDRicsJ2NzdWJlJzonXFxcXHUyQUQxJywnY3N1cCc6J1xcXFx1MkFEMCcsJ2NzdXBlJzonXFxcXHUyQUQyJywnY3Rkb3QnOidcXFxcdTIyRUYnLCdjdWRhcnJsJzonXFxcXHUyOTM4JywnY3VkYXJycic6J1xcXFx1MjkzNScsJ2N1ZXByJzonXFxcXHUyMkRFJywnY3Vlc2MnOidcXFxcdTIyREYnLCdjdWxhcnInOidcXFxcdTIxQjYnLCdjdWxhcnJwJzonXFxcXHUyOTNEJywnY3VwJzonXFxcXHUyMjJBJywnQ3VwJzonXFxcXHUyMkQzJywnY3VwYnJjYXAnOidcXFxcdTJBNDgnLCdjdXBjYXAnOidcXFxcdTJBNDYnLCdDdXBDYXAnOidcXFxcdTIyNEQnLCdjdXBjdXAnOidcXFxcdTJBNEEnLCdjdXBkb3QnOidcXFxcdTIyOEQnLCdjdXBvcic6J1xcXFx1MkE0NScsJ2N1cHMnOidcXFxcdTIyMkFcXFxcdUZFMDAnLCdjdXJhcnInOidcXFxcdTIxQjcnLCdjdXJhcnJtJzonXFxcXHUyOTNDJywnY3VybHllcXByZWMnOidcXFxcdTIyREUnLCdjdXJseWVxc3VjYyc6J1xcXFx1MjJERicsJ2N1cmx5dmVlJzonXFxcXHUyMkNFJywnY3VybHl3ZWRnZSc6J1xcXFx1MjJDRicsJ2N1cnJlbic6J1xcXFx4QTQnLCdjdXJ2ZWFycm93bGVmdCc6J1xcXFx1MjFCNicsJ2N1cnZlYXJyb3dyaWdodCc6J1xcXFx1MjFCNycsJ2N1dmVlJzonXFxcXHUyMkNFJywnY3V3ZWQnOidcXFxcdTIyQ0YnLCdjd2NvbmludCc6J1xcXFx1MjIzMicsJ2N3aW50JzonXFxcXHUyMjMxJywnY3lsY3R5JzonXFxcXHUyMzJEJywnZGFnZ2VyJzonXFxcXHUyMDIwJywnRGFnZ2VyJzonXFxcXHUyMDIxJywnZGFsZXRoJzonXFxcXHUyMTM4JywnZGFycic6J1xcXFx1MjE5MycsJ2RBcnInOidcXFxcdTIxRDMnLCdEYXJyJzonXFxcXHUyMUExJywnZGFzaCc6J1xcXFx1MjAxMCcsJ2Rhc2h2JzonXFxcXHUyMkEzJywnRGFzaHYnOidcXFxcdTJBRTQnLCdkYmthcm93JzonXFxcXHUyOTBGJywnZGJsYWMnOidcXFxcdTAyREQnLCdkY2Fyb24nOidcXFxcdTAxMEYnLCdEY2Fyb24nOidcXFxcdTAxMEUnLCdkY3knOidcXFxcdTA0MzQnLCdEY3knOidcXFxcdTA0MTQnLCdkZCc6J1xcXFx1MjE0NicsJ0REJzonXFxcXHUyMTQ1JywnZGRhZ2dlcic6J1xcXFx1MjAyMScsJ2RkYXJyJzonXFxcXHUyMUNBJywnRERvdHJhaGQnOidcXFxcdTI5MTEnLCdkZG90c2VxJzonXFxcXHUyQTc3JywnZGVnJzonXFxcXHhCMCcsJ0RlbCc6J1xcXFx1MjIwNycsJ2RlbHRhJzonXFxcXHUwM0I0JywnRGVsdGEnOidcXFxcdTAzOTQnLCdkZW1wdHl2JzonXFxcXHUyOUIxJywnZGZpc2h0JzonXFxcXHUyOTdGJywnZGZyJzonXFxcXHVEODM1XFxcXHVERDIxJywnRGZyJzonXFxcXHVEODM1XFxcXHVERDA3JywnZEhhcic6J1xcXFx1Mjk2NScsJ2RoYXJsJzonXFxcXHUyMUMzJywnZGhhcnInOidcXFxcdTIxQzInLCdEaWFjcml0aWNhbEFjdXRlJzonXFxcXHhCNCcsJ0RpYWNyaXRpY2FsRG90JzonXFxcXHUwMkQ5JywnRGlhY3JpdGljYWxEb3VibGVBY3V0ZSc6J1xcXFx1MDJERCcsJ0RpYWNyaXRpY2FsR3JhdmUnOidgJywnRGlhY3JpdGljYWxUaWxkZSc6J1xcXFx1MDJEQycsJ2RpYW0nOidcXFxcdTIyQzQnLCdkaWFtb25kJzonXFxcXHUyMkM0JywnRGlhbW9uZCc6J1xcXFx1MjJDNCcsJ2RpYW1vbmRzdWl0JzonXFxcXHUyNjY2JywnZGlhbXMnOidcXFxcdTI2NjYnLCdkaWUnOidcXFxceEE4JywnRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NicsJ2RpZ2FtbWEnOidcXFxcdTAzREQnLCdkaXNpbic6J1xcXFx1MjJGMicsJ2Rpdic6J1xcXFx4RjcnLCdkaXZpZGUnOidcXFxceEY3JywnZGl2aWRlb250aW1lcyc6J1xcXFx1MjJDNycsJ2Rpdm9ueCc6J1xcXFx1MjJDNycsJ2RqY3knOidcXFxcdTA0NTInLCdESmN5JzonXFxcXHUwNDAyJywnZGxjb3JuJzonXFxcXHUyMzFFJywnZGxjcm9wJzonXFxcXHUyMzBEJywnZG9sbGFyJzonJCcsJ2RvcGYnOidcXFxcdUQ4MzVcXFxcdURENTUnLCdEb3BmJzonXFxcXHVEODM1XFxcXHVERDNCJywnZG90JzonXFxcXHUwMkQ5JywnRG90JzonXFxcXHhBOCcsJ0RvdERvdCc6J1xcXFx1MjBEQycsJ2RvdGVxJzonXFxcXHUyMjUwJywnZG90ZXFkb3QnOidcXFxcdTIyNTEnLCdEb3RFcXVhbCc6J1xcXFx1MjI1MCcsJ2RvdG1pbnVzJzonXFxcXHUyMjM4JywnZG90cGx1cyc6J1xcXFx1MjIxNCcsJ2RvdHNxdWFyZSc6J1xcXFx1MjJBMScsJ2RvdWJsZWJhcndlZGdlJzonXFxcXHUyMzA2JywnRG91YmxlQ29udG91ckludGVncmFsJzonXFxcXHUyMjJGJywnRG91YmxlRG90JzonXFxcXHhBOCcsJ0RvdWJsZURvd25BcnJvdyc6J1xcXFx1MjFEMycsJ0RvdWJsZUxlZnRBcnJvdyc6J1xcXFx1MjFEMCcsJ0RvdWJsZUxlZnRSaWdodEFycm93JzonXFxcXHUyMUQ0JywnRG91YmxlTGVmdFRlZSc6J1xcXFx1MkFFNCcsJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjgnLCdEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RkEnLCdEb3VibGVMb25nUmlnaHRBcnJvdyc6J1xcXFx1MjdGOScsJ0RvdWJsZVJpZ2h0QXJyb3cnOidcXFxcdTIxRDInLCdEb3VibGVSaWdodFRlZSc6J1xcXFx1MjJBOCcsJ0RvdWJsZVVwQXJyb3cnOidcXFxcdTIxRDEnLCdEb3VibGVVcERvd25BcnJvdyc6J1xcXFx1MjFENScsJ0RvdWJsZVZlcnRpY2FsQmFyJzonXFxcXHUyMjI1JywnZG93bmFycm93JzonXFxcXHUyMTkzJywnRG93bmFycm93JzonXFxcXHUyMUQzJywnRG93bkFycm93JzonXFxcXHUyMTkzJywnRG93bkFycm93QmFyJzonXFxcXHUyOTEzJywnRG93bkFycm93VXBBcnJvdyc6J1xcXFx1MjFGNScsJ0Rvd25CcmV2ZSc6J1xcXFx1MDMxMScsJ2Rvd25kb3duYXJyb3dzJzonXFxcXHUyMUNBJywnZG93bmhhcnBvb25sZWZ0JzonXFxcXHUyMUMzJywnZG93bmhhcnBvb25yaWdodCc6J1xcXFx1MjFDMicsJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOidcXFxcdTI5NTAnLCdEb3duTGVmdFRlZVZlY3Rvcic6J1xcXFx1Mjk1RScsJ0Rvd25MZWZ0VmVjdG9yJzonXFxcXHUyMUJEJywnRG93bkxlZnRWZWN0b3JCYXInOidcXFxcdTI5NTYnLCdEb3duUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUYnLCdEb3duUmlnaHRWZWN0b3InOidcXFxcdTIxQzEnLCdEb3duUmlnaHRWZWN0b3JCYXInOidcXFxcdTI5NTcnLCdEb3duVGVlJzonXFxcXHUyMkE0JywnRG93blRlZUFycm93JzonXFxcXHUyMUE3JywnZHJia2Fyb3cnOidcXFxcdTI5MTAnLCdkcmNvcm4nOidcXFxcdTIzMUYnLCdkcmNyb3AnOidcXFxcdTIzMEMnLCdkc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I5JywnRHNjcic6J1xcXFx1RDgzNVxcXFx1REM5RicsJ2RzY3knOidcXFxcdTA0NTUnLCdEU2N5JzonXFxcXHUwNDA1JywnZHNvbCc6J1xcXFx1MjlGNicsJ2RzdHJvayc6J1xcXFx1MDExMScsJ0RzdHJvayc6J1xcXFx1MDExMCcsJ2R0ZG90JzonXFxcXHUyMkYxJywnZHRyaSc6J1xcXFx1MjVCRicsJ2R0cmlmJzonXFxcXHUyNUJFJywnZHVhcnInOidcXFxcdTIxRjUnLCdkdWhhcic6J1xcXFx1Mjk2RicsJ2R3YW5nbGUnOidcXFxcdTI5QTYnLCdkemN5JzonXFxcXHUwNDVGJywnRFpjeSc6J1xcXFx1MDQwRicsJ2R6aWdyYXJyJzonXFxcXHUyN0ZGJywnZWFjdXRlJzonXFxcXHhFOScsJ0VhY3V0ZSc6J1xcXFx4QzknLCdlYXN0ZXInOidcXFxcdTJBNkUnLCdlY2Fyb24nOidcXFxcdTAxMUInLCdFY2Fyb24nOidcXFxcdTAxMUEnLCdlY2lyJzonXFxcXHUyMjU2JywnZWNpcmMnOidcXFxceEVBJywnRWNpcmMnOidcXFxceENBJywnZWNvbG9uJzonXFxcXHUyMjU1JywnZWN5JzonXFxcXHUwNDREJywnRWN5JzonXFxcXHUwNDJEJywnZUREb3QnOidcXFxcdTJBNzcnLCdlZG90JzonXFxcXHUwMTE3JywnZURvdCc6J1xcXFx1MjI1MScsJ0Vkb3QnOidcXFxcdTAxMTYnLCdlZSc6J1xcXFx1MjE0NycsJ2VmRG90JzonXFxcXHUyMjUyJywnZWZyJzonXFxcXHVEODM1XFxcXHVERDIyJywnRWZyJzonXFxcXHVEODM1XFxcXHVERDA4JywnZWcnOidcXFxcdTJBOUEnLCdlZ3JhdmUnOidcXFxceEU4JywnRWdyYXZlJzonXFxcXHhDOCcsJ2Vncyc6J1xcXFx1MkE5NicsJ2Vnc2RvdCc6J1xcXFx1MkE5OCcsJ2VsJzonXFxcXHUyQTk5JywnRWxlbWVudCc6J1xcXFx1MjIwOCcsJ2VsaW50ZXJzJzonXFxcXHUyM0U3JywnZWxsJzonXFxcXHUyMTEzJywnZWxzJzonXFxcXHUyQTk1JywnZWxzZG90JzonXFxcXHUyQTk3JywnZW1hY3InOidcXFxcdTAxMTMnLCdFbWFjcic6J1xcXFx1MDExMicsJ2VtcHR5JzonXFxcXHUyMjA1JywnZW1wdHlzZXQnOidcXFxcdTIyMDUnLCdFbXB0eVNtYWxsU3F1YXJlJzonXFxcXHUyNUZCJywnZW1wdHl2JzonXFxcXHUyMjA1JywnRW1wdHlWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUInLCdlbXNwJzonXFxcXHUyMDAzJywnZW1zcDEzJzonXFxcXHUyMDA0JywnZW1zcDE0JzonXFxcXHUyMDA1JywnZW5nJzonXFxcXHUwMTRCJywnRU5HJzonXFxcXHUwMTRBJywnZW5zcCc6J1xcXFx1MjAwMicsJ2VvZ29uJzonXFxcXHUwMTE5JywnRW9nb24nOidcXFxcdTAxMTgnLCdlb3BmJzonXFxcXHVEODM1XFxcXHVERDU2JywnRW9wZic6J1xcXFx1RDgzNVxcXFx1REQzQycsJ2VwYXInOidcXFxcdTIyRDUnLCdlcGFyc2wnOidcXFxcdTI5RTMnLCdlcGx1cyc6J1xcXFx1MkE3MScsJ2Vwc2knOidcXFxcdTAzQjUnLCdlcHNpbG9uJzonXFxcXHUwM0I1JywnRXBzaWxvbic6J1xcXFx1MDM5NScsJ2Vwc2l2JzonXFxcXHUwM0Y1JywnZXFjaXJjJzonXFxcXHUyMjU2JywnZXFjb2xvbic6J1xcXFx1MjI1NScsJ2Vxc2ltJzonXFxcXHUyMjQyJywnZXFzbGFudGd0cic6J1xcXFx1MkE5NicsJ2Vxc2xhbnRsZXNzJzonXFxcXHUyQTk1JywnRXF1YWwnOidcXFxcdTJBNzUnLCdlcXVhbHMnOic9JywnRXF1YWxUaWxkZSc6J1xcXFx1MjI0MicsJ2VxdWVzdCc6J1xcXFx1MjI1RicsJ0VxdWlsaWJyaXVtJzonXFxcXHUyMUNDJywnZXF1aXYnOidcXFxcdTIyNjEnLCdlcXVpdkREJzonXFxcXHUyQTc4JywnZXF2cGFyc2wnOidcXFxcdTI5RTUnLCdlcmFycic6J1xcXFx1Mjk3MScsJ2VyRG90JzonXFxcXHUyMjUzJywnZXNjcic6J1xcXFx1MjEyRicsJ0VzY3InOidcXFxcdTIxMzAnLCdlc2RvdCc6J1xcXFx1MjI1MCcsJ2VzaW0nOidcXFxcdTIyNDInLCdFc2ltJzonXFxcXHUyQTczJywnZXRhJzonXFxcXHUwM0I3JywnRXRhJzonXFxcXHUwMzk3JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZXVybyc6J1xcXFx1MjBBQycsJ2V4Y2wnOichJywnZXhpc3QnOidcXFxcdTIyMDMnLCdFeGlzdHMnOidcXFxcdTIyMDMnLCdleHBlY3RhdGlvbic6J1xcXFx1MjEzMCcsJ2V4cG9uZW50aWFsZSc6J1xcXFx1MjE0NycsJ0V4cG9uZW50aWFsRSc6J1xcXFx1MjE0NycsJ2ZhbGxpbmdkb3RzZXEnOidcXFxcdTIyNTInLCdmY3knOidcXFxcdTA0NDQnLCdGY3knOidcXFxcdTA0MjQnLCdmZW1hbGUnOidcXFxcdTI2NDAnLCdmZmlsaWcnOidcXFxcdUZCMDMnLCdmZmxpZyc6J1xcXFx1RkIwMCcsJ2ZmbGxpZyc6J1xcXFx1RkIwNCcsJ2Zmcic6J1xcXFx1RDgzNVxcXFx1REQyMycsJ0Zmcic6J1xcXFx1RDgzNVxcXFx1REQwOScsJ2ZpbGlnJzonXFxcXHVGQjAxJywnRmlsbGVkU21hbGxTcXVhcmUnOidcXFxcdTI1RkMnLCdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUEnLCdmamxpZyc6J2ZqJywnZmxhdCc6J1xcXFx1MjY2RCcsJ2ZsbGlnJzonXFxcXHVGQjAyJywnZmx0bnMnOidcXFxcdTI1QjEnLCdmbm9mJzonXFxcXHUwMTkyJywnZm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NycsJ0ZvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0QnLCdmb3JhbGwnOidcXFxcdTIyMDAnLCdGb3JBbGwnOidcXFxcdTIyMDAnLCdmb3JrJzonXFxcXHUyMkQ0JywnZm9ya3YnOidcXFxcdTJBRDknLCdGb3VyaWVydHJmJzonXFxcXHUyMTMxJywnZnBhcnRpbnQnOidcXFxcdTJBMEQnLCdmcmFjMTInOidcXFxceEJEJywnZnJhYzEzJzonXFxcXHUyMTUzJywnZnJhYzE0JzonXFxcXHhCQycsJ2ZyYWMxNSc6J1xcXFx1MjE1NScsJ2ZyYWMxNic6J1xcXFx1MjE1OScsJ2ZyYWMxOCc6J1xcXFx1MjE1QicsJ2ZyYWMyMyc6J1xcXFx1MjE1NCcsJ2ZyYWMyNSc6J1xcXFx1MjE1NicsJ2ZyYWMzNCc6J1xcXFx4QkUnLCdmcmFjMzUnOidcXFxcdTIxNTcnLCdmcmFjMzgnOidcXFxcdTIxNUMnLCdmcmFjNDUnOidcXFxcdTIxNTgnLCdmcmFjNTYnOidcXFxcdTIxNUEnLCdmcmFjNTgnOidcXFxcdTIxNUQnLCdmcmFjNzgnOidcXFxcdTIxNUUnLCdmcmFzbCc6J1xcXFx1MjA0NCcsJ2Zyb3duJzonXFxcXHUyMzIyJywnZnNjcic6J1xcXFx1RDgzNVxcXFx1RENCQicsJ0ZzY3InOidcXFxcdTIxMzEnLCdnYWN1dGUnOidcXFxcdTAxRjUnLCdnYW1tYSc6J1xcXFx1MDNCMycsJ0dhbW1hJzonXFxcXHUwMzkzJywnZ2FtbWFkJzonXFxcXHUwM0REJywnR2FtbWFkJzonXFxcXHUwM0RDJywnZ2FwJzonXFxcXHUyQTg2JywnZ2JyZXZlJzonXFxcXHUwMTFGJywnR2JyZXZlJzonXFxcXHUwMTFFJywnR2NlZGlsJzonXFxcXHUwMTIyJywnZ2NpcmMnOidcXFxcdTAxMUQnLCdHY2lyYyc6J1xcXFx1MDExQycsJ2djeSc6J1xcXFx1MDQzMycsJ0djeSc6J1xcXFx1MDQxMycsJ2dkb3QnOidcXFxcdTAxMjEnLCdHZG90JzonXFxcXHUwMTIwJywnZ2UnOidcXFxcdTIyNjUnLCdnRSc6J1xcXFx1MjI2NycsJ2dlbCc6J1xcXFx1MjJEQicsJ2dFbCc6J1xcXFx1MkE4QycsJ2dlcSc6J1xcXFx1MjI2NScsJ2dlcXEnOidcXFxcdTIyNjcnLCdnZXFzbGFudCc6J1xcXFx1MkE3RScsJ2dlcyc6J1xcXFx1MkE3RScsJ2dlc2NjJzonXFxcXHUyQUE5JywnZ2VzZG90JzonXFxcXHUyQTgwJywnZ2VzZG90byc6J1xcXFx1MkE4MicsJ2dlc2RvdG9sJzonXFxcXHUyQTg0JywnZ2VzbCc6J1xcXFx1MjJEQlxcXFx1RkUwMCcsJ2dlc2xlcyc6J1xcXFx1MkE5NCcsJ2dmcic6J1xcXFx1RDgzNVxcXFx1REQyNCcsJ0dmcic6J1xcXFx1RDgzNVxcXFx1REQwQScsJ2dnJzonXFxcXHUyMjZCJywnR2cnOidcXFxcdTIyRDknLCdnZ2cnOidcXFxcdTIyRDknLCdnaW1lbCc6J1xcXFx1MjEzNycsJ2dqY3knOidcXFxcdTA0NTMnLCdHSmN5JzonXFxcXHUwNDAzJywnZ2wnOidcXFxcdTIyNzcnLCdnbGEnOidcXFxcdTJBQTUnLCdnbEUnOidcXFxcdTJBOTInLCdnbGonOidcXFxcdTJBQTQnLCdnbmFwJzonXFxcXHUyQThBJywnZ25hcHByb3gnOidcXFxcdTJBOEEnLCdnbmUnOidcXFxcdTJBODgnLCdnbkUnOidcXFxcdTIyNjknLCdnbmVxJzonXFxcXHUyQTg4JywnZ25lcXEnOidcXFxcdTIyNjknLCdnbnNpbSc6J1xcXFx1MjJFNycsJ2dvcGYnOidcXFxcdUQ4MzVcXFxcdURENTgnLCdHb3BmJzonXFxcXHVEODM1XFxcXHVERDNFJywnZ3JhdmUnOidgJywnR3JlYXRlckVxdWFsJzonXFxcXHUyMjY1JywnR3JlYXRlckVxdWFsTGVzcyc6J1xcXFx1MjJEQicsJ0dyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjcnLCdHcmVhdGVyR3JlYXRlcic6J1xcXFx1MkFBMicsJ0dyZWF0ZXJMZXNzJzonXFxcXHUyMjc3JywnR3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0UnLCdHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzMnLCdnc2NyJzonXFxcXHUyMTBBJywnR3Njcic6J1xcXFx1RDgzNVxcXFx1RENBMicsJ2dzaW0nOidcXFxcdTIyNzMnLCdnc2ltZSc6J1xcXFx1MkE4RScsJ2dzaW1sJzonXFxcXHUyQTkwJywnZ3QnOic+JywnR3QnOidcXFxcdTIyNkInLCdHVCc6Jz4nLCdndGNjJzonXFxcXHUyQUE3JywnZ3RjaXInOidcXFxcdTJBN0EnLCdndGRvdCc6J1xcXFx1MjJENycsJ2d0bFBhcic6J1xcXFx1Mjk5NScsJ2d0cXVlc3QnOidcXFxcdTJBN0MnLCdndHJhcHByb3gnOidcXFxcdTJBODYnLCdndHJhcnInOidcXFxcdTI5NzgnLCdndHJkb3QnOidcXFxcdTIyRDcnLCdndHJlcWxlc3MnOidcXFxcdTIyREInLCdndHJlcXFsZXNzJzonXFxcXHUyQThDJywnZ3RybGVzcyc6J1xcXFx1MjI3NycsJ2d0cnNpbSc6J1xcXFx1MjI3MycsJ2d2ZXJ0bmVxcSc6J1xcXFx1MjI2OVxcXFx1RkUwMCcsJ2d2bkUnOidcXFxcdTIyNjlcXFxcdUZFMDAnLCdIYWNlayc6J1xcXFx1MDJDNycsJ2hhaXJzcCc6J1xcXFx1MjAwQScsJ2hhbGYnOidcXFxceEJEJywnaGFtaWx0JzonXFxcXHUyMTBCJywnaGFyZGN5JzonXFxcXHUwNDRBJywnSEFSRGN5JzonXFxcXHUwNDJBJywnaGFycic6J1xcXFx1MjE5NCcsJ2hBcnInOidcXFxcdTIxRDQnLCdoYXJyY2lyJzonXFxcXHUyOTQ4JywnaGFycncnOidcXFxcdTIxQUQnLCdIYXQnOideJywnaGJhcic6J1xcXFx1MjEwRicsJ2hjaXJjJzonXFxcXHUwMTI1JywnSGNpcmMnOidcXFxcdTAxMjQnLCdoZWFydHMnOidcXFxcdTI2NjUnLCdoZWFydHN1aXQnOidcXFxcdTI2NjUnLCdoZWxsaXAnOidcXFxcdTIwMjYnLCdoZXJjb24nOidcXFxcdTIyQjknLCdoZnInOidcXFxcdUQ4MzVcXFxcdUREMjUnLCdIZnInOidcXFxcdTIxMEMnLCdIaWxiZXJ0U3BhY2UnOidcXFxcdTIxMEInLCdoa3NlYXJvdyc6J1xcXFx1MjkyNScsJ2hrc3dhcm93JzonXFxcXHUyOTI2JywnaG9hcnInOidcXFxcdTIxRkYnLCdob210aHQnOidcXFxcdTIyM0InLCdob29rbGVmdGFycm93JzonXFxcXHUyMUE5JywnaG9va3JpZ2h0YXJyb3cnOidcXFxcdTIxQUEnLCdob3BmJzonXFxcXHVEODM1XFxcXHVERDU5JywnSG9wZic6J1xcXFx1MjEwRCcsJ2hvcmJhcic6J1xcXFx1MjAxNScsJ0hvcml6b250YWxMaW5lJzonXFxcXHUyNTAwJywnaHNjcic6J1xcXFx1RDgzNVxcXFx1RENCRCcsJ0hzY3InOidcXFxcdTIxMEInLCdoc2xhc2gnOidcXFxcdTIxMEYnLCdoc3Ryb2snOidcXFxcdTAxMjcnLCdIc3Ryb2snOidcXFxcdTAxMjYnLCdIdW1wRG93bkh1bXAnOidcXFxcdTIyNEUnLCdIdW1wRXF1YWwnOidcXFxcdTIyNEYnLCdoeWJ1bGwnOidcXFxcdTIwNDMnLCdoeXBoZW4nOidcXFxcdTIwMTAnLCdpYWN1dGUnOidcXFxceEVEJywnSWFjdXRlJzonXFxcXHhDRCcsJ2ljJzonXFxcXHUyMDYzJywnaWNpcmMnOidcXFxceEVFJywnSWNpcmMnOidcXFxceENFJywnaWN5JzonXFxcXHUwNDM4JywnSWN5JzonXFxcXHUwNDE4JywnSWRvdCc6J1xcXFx1MDEzMCcsJ2llY3knOidcXFxcdTA0MzUnLCdJRWN5JzonXFxcXHUwNDE1JywnaWV4Y2wnOidcXFxceEExJywnaWZmJzonXFxcXHUyMUQ0JywnaWZyJzonXFxcXHVEODM1XFxcXHVERDI2JywnSWZyJzonXFxcXHUyMTExJywnaWdyYXZlJzonXFxcXHhFQycsJ0lncmF2ZSc6J1xcXFx4Q0MnLCdpaSc6J1xcXFx1MjE0OCcsJ2lpaWludCc6J1xcXFx1MkEwQycsJ2lpaW50JzonXFxcXHUyMjJEJywnaWluZmluJzonXFxcXHUyOURDJywnaWlvdGEnOidcXFxcdTIxMjknLCdpamxpZyc6J1xcXFx1MDEzMycsJ0lKbGlnJzonXFxcXHUwMTMyJywnSW0nOidcXFxcdTIxMTEnLCdpbWFjcic6J1xcXFx1MDEyQicsJ0ltYWNyJzonXFxcXHUwMTJBJywnaW1hZ2UnOidcXFxcdTIxMTEnLCdJbWFnaW5hcnlJJzonXFxcXHUyMTQ4JywnaW1hZ2xpbmUnOidcXFxcdTIxMTAnLCdpbWFncGFydCc6J1xcXFx1MjExMScsJ2ltYXRoJzonXFxcXHUwMTMxJywnaW1vZic6J1xcXFx1MjJCNycsJ2ltcGVkJzonXFxcXHUwMUI1JywnSW1wbGllcyc6J1xcXFx1MjFEMicsJ2luJzonXFxcXHUyMjA4JywnaW5jYXJlJzonXFxcXHUyMTA1JywnaW5maW4nOidcXFxcdTIyMUUnLCdpbmZpbnRpZSc6J1xcXFx1MjlERCcsJ2lub2RvdCc6J1xcXFx1MDEzMScsJ2ludCc6J1xcXFx1MjIyQicsJ0ludCc6J1xcXFx1MjIyQycsJ2ludGNhbCc6J1xcXFx1MjJCQScsJ2ludGVnZXJzJzonXFxcXHUyMTI0JywnSW50ZWdyYWwnOidcXFxcdTIyMkInLCdpbnRlcmNhbCc6J1xcXFx1MjJCQScsJ0ludGVyc2VjdGlvbic6J1xcXFx1MjJDMicsJ2ludGxhcmhrJzonXFxcXHUyQTE3JywnaW50cHJvZCc6J1xcXFx1MkEzQycsJ0ludmlzaWJsZUNvbW1hJzonXFxcXHUyMDYzJywnSW52aXNpYmxlVGltZXMnOidcXFxcdTIwNjInLCdpb2N5JzonXFxcXHUwNDUxJywnSU9jeSc6J1xcXFx1MDQwMScsJ2lvZ29uJzonXFxcXHUwMTJGJywnSW9nb24nOidcXFxcdTAxMkUnLCdpb3BmJzonXFxcXHVEODM1XFxcXHVERDVBJywnSW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MCcsJ2lvdGEnOidcXFxcdTAzQjknLCdJb3RhJzonXFxcXHUwMzk5JywnaXByb2QnOidcXFxcdTJBM0MnLCdpcXVlc3QnOidcXFxceEJGJywnaXNjcic6J1xcXFx1RDgzNVxcXFx1RENCRScsJ0lzY3InOidcXFxcdTIxMTAnLCdpc2luJzonXFxcXHUyMjA4JywnaXNpbmRvdCc6J1xcXFx1MjJGNScsJ2lzaW5FJzonXFxcXHUyMkY5JywnaXNpbnMnOidcXFxcdTIyRjQnLCdpc2luc3YnOidcXFxcdTIyRjMnLCdpc2ludic6J1xcXFx1MjIwOCcsJ2l0JzonXFxcXHUyMDYyJywnaXRpbGRlJzonXFxcXHUwMTI5JywnSXRpbGRlJzonXFxcXHUwMTI4JywnaXVrY3knOidcXFxcdTA0NTYnLCdJdWtjeSc6J1xcXFx1MDQwNicsJ2l1bWwnOidcXFxceEVGJywnSXVtbCc6J1xcXFx4Q0YnLCdqY2lyYyc6J1xcXFx1MDEzNScsJ0pjaXJjJzonXFxcXHUwMTM0JywnamN5JzonXFxcXHUwNDM5JywnSmN5JzonXFxcXHUwNDE5JywnamZyJzonXFxcXHVEODM1XFxcXHVERDI3JywnSmZyJzonXFxcXHVEODM1XFxcXHVERDBEJywnam1hdGgnOidcXFxcdTAyMzcnLCdqb3BmJzonXFxcXHVEODM1XFxcXHVERDVCJywnSm9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MScsJ2pzY3InOidcXFxcdUQ4MzVcXFxcdURDQkYnLCdKc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E1JywnanNlcmN5JzonXFxcXHUwNDU4JywnSnNlcmN5JzonXFxcXHUwNDA4JywnanVrY3knOidcXFxcdTA0NTQnLCdKdWtjeSc6J1xcXFx1MDQwNCcsJ2thcHBhJzonXFxcXHUwM0JBJywnS2FwcGEnOidcXFxcdTAzOUEnLCdrYXBwYXYnOidcXFxcdTAzRjAnLCdrY2VkaWwnOidcXFxcdTAxMzcnLCdLY2VkaWwnOidcXFxcdTAxMzYnLCdrY3knOidcXFxcdTA0M0EnLCdLY3knOidcXFxcdTA0MUEnLCdrZnInOidcXFxcdUQ4MzVcXFxcdUREMjgnLCdLZnInOidcXFxcdUQ4MzVcXFxcdUREMEUnLCdrZ3JlZW4nOidcXFxcdTAxMzgnLCdraGN5JzonXFxcXHUwNDQ1JywnS0hjeSc6J1xcXFx1MDQyNScsJ2tqY3knOidcXFxcdTA0NUMnLCdLSmN5JzonXFxcXHUwNDBDJywna29wZic6J1xcXFx1RDgzNVxcXFx1REQ1QycsJ0tvcGYnOidcXFxcdUQ4MzVcXFxcdURENDInLCdrc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MwJywnS3Njcic6J1xcXFx1RDgzNVxcXFx1RENBNicsJ2xBYXJyJzonXFxcXHUyMURBJywnbGFjdXRlJzonXFxcXHUwMTNBJywnTGFjdXRlJzonXFxcXHUwMTM5JywnbGFlbXB0eXYnOidcXFxcdTI5QjQnLCdsYWdyYW4nOidcXFxcdTIxMTInLCdsYW1iZGEnOidcXFxcdTAzQkInLCdMYW1iZGEnOidcXFxcdTAzOUInLCdsYW5nJzonXFxcXHUyN0U4JywnTGFuZyc6J1xcXFx1MjdFQScsJ2xhbmdkJzonXFxcXHUyOTkxJywnbGFuZ2xlJzonXFxcXHUyN0U4JywnbGFwJzonXFxcXHUyQTg1JywnTGFwbGFjZXRyZic6J1xcXFx1MjExMicsJ2xhcXVvJzonXFxcXHhBQicsJ2xhcnInOidcXFxcdTIxOTAnLCdsQXJyJzonXFxcXHUyMUQwJywnTGFycic6J1xcXFx1MjE5RScsJ2xhcnJiJzonXFxcXHUyMUU0JywnbGFycmJmcyc6J1xcXFx1MjkxRicsJ2xhcnJmcyc6J1xcXFx1MjkxRCcsJ2xhcnJoayc6J1xcXFx1MjFBOScsJ2xhcnJscCc6J1xcXFx1MjFBQicsJ2xhcnJwbCc6J1xcXFx1MjkzOScsJ2xhcnJzaW0nOidcXFxcdTI5NzMnLCdsYXJydGwnOidcXFxcdTIxQTInLCdsYXQnOidcXFxcdTJBQUInLCdsYXRhaWwnOidcXFxcdTI5MTknLCdsQXRhaWwnOidcXFxcdTI5MUInLCdsYXRlJzonXFxcXHUyQUFEJywnbGF0ZXMnOidcXFxcdTJBQURcXFxcdUZFMDAnLCdsYmFycic6J1xcXFx1MjkwQycsJ2xCYXJyJzonXFxcXHUyOTBFJywnbGJicmsnOidcXFxcdTI3NzInLCdsYnJhY2UnOid7JywnbGJyYWNrJzonWycsJ2xicmtlJzonXFxcXHUyOThCJywnbGJya3NsZCc6J1xcXFx1Mjk4RicsJ2xicmtzbHUnOidcXFxcdTI5OEQnLCdsY2Fyb24nOidcXFxcdTAxM0UnLCdMY2Fyb24nOidcXFxcdTAxM0QnLCdsY2VkaWwnOidcXFxcdTAxM0MnLCdMY2VkaWwnOidcXFxcdTAxM0InLCdsY2VpbCc6J1xcXFx1MjMwOCcsJ2xjdWInOid7JywnbGN5JzonXFxcXHUwNDNCJywnTGN5JzonXFxcXHUwNDFCJywnbGRjYSc6J1xcXFx1MjkzNicsJ2xkcXVvJzonXFxcXHUyMDFDJywnbGRxdW9yJzonXFxcXHUyMDFFJywnbGRyZGhhcic6J1xcXFx1Mjk2NycsJ2xkcnVzaGFyJzonXFxcXHUyOTRCJywnbGRzaCc6J1xcXFx1MjFCMicsJ2xlJzonXFxcXHUyMjY0JywnbEUnOidcXFxcdTIyNjYnLCdMZWZ0QW5nbGVCcmFja2V0JzonXFxcXHUyN0U4JywnbGVmdGFycm93JzonXFxcXHUyMTkwJywnTGVmdGFycm93JzonXFxcXHUyMUQwJywnTGVmdEFycm93JzonXFxcXHUyMTkwJywnTGVmdEFycm93QmFyJzonXFxcXHUyMUU0JywnTGVmdEFycm93UmlnaHRBcnJvdyc6J1xcXFx1MjFDNicsJ2xlZnRhcnJvd3RhaWwnOidcXFxcdTIxQTInLCdMZWZ0Q2VpbGluZyc6J1xcXFx1MjMwOCcsJ0xlZnREb3VibGVCcmFja2V0JzonXFxcXHUyN0U2JywnTGVmdERvd25UZWVWZWN0b3InOidcXFxcdTI5NjEnLCdMZWZ0RG93blZlY3Rvcic6J1xcXFx1MjFDMycsJ0xlZnREb3duVmVjdG9yQmFyJzonXFxcXHUyOTU5JywnTGVmdEZsb29yJzonXFxcXHUyMzBBJywnbGVmdGhhcnBvb25kb3duJzonXFxcXHUyMUJEJywnbGVmdGhhcnBvb251cCc6J1xcXFx1MjFCQycsJ2xlZnRsZWZ0YXJyb3dzJzonXFxcXHUyMUM3JywnbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxOTQnLCdMZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjFENCcsJ0xlZnRSaWdodEFycm93JzonXFxcXHUyMTk0JywnbGVmdHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM2JywnbGVmdHJpZ2h0aGFycG9vbnMnOidcXFxcdTIxQ0InLCdsZWZ0cmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMUFEJywnTGVmdFJpZ2h0VmVjdG9yJzonXFxcXHUyOTRFJywnTGVmdFRlZSc6J1xcXFx1MjJBMycsJ0xlZnRUZWVBcnJvdyc6J1xcXFx1MjFBNCcsJ0xlZnRUZWVWZWN0b3InOidcXFxcdTI5NUEnLCdsZWZ0dGhyZWV0aW1lcyc6J1xcXFx1MjJDQicsJ0xlZnRUcmlhbmdsZSc6J1xcXFx1MjJCMicsJ0xlZnRUcmlhbmdsZUJhcic6J1xcXFx1MjlDRicsJ0xlZnRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkI0JywnTGVmdFVwRG93blZlY3Rvcic6J1xcXFx1Mjk1MScsJ0xlZnRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk2MCcsJ0xlZnRVcFZlY3Rvcic6J1xcXFx1MjFCRicsJ0xlZnRVcFZlY3RvckJhcic6J1xcXFx1Mjk1OCcsJ0xlZnRWZWN0b3InOidcXFxcdTIxQkMnLCdMZWZ0VmVjdG9yQmFyJzonXFxcXHUyOTUyJywnbGVnJzonXFxcXHUyMkRBJywnbEVnJzonXFxcXHUyQThCJywnbGVxJzonXFxcXHUyMjY0JywnbGVxcSc6J1xcXFx1MjI2NicsJ2xlcXNsYW50JzonXFxcXHUyQTdEJywnbGVzJzonXFxcXHUyQTdEJywnbGVzY2MnOidcXFxcdTJBQTgnLCdsZXNkb3QnOidcXFxcdTJBN0YnLCdsZXNkb3RvJzonXFxcXHUyQTgxJywnbGVzZG90b3InOidcXFxcdTJBODMnLCdsZXNnJzonXFxcXHUyMkRBXFxcXHVGRTAwJywnbGVzZ2VzJzonXFxcXHUyQTkzJywnbGVzc2FwcHJveCc6J1xcXFx1MkE4NScsJ2xlc3Nkb3QnOidcXFxcdTIyRDYnLCdsZXNzZXFndHInOidcXFxcdTIyREEnLCdsZXNzZXFxZ3RyJzonXFxcXHUyQThCJywnTGVzc0VxdWFsR3JlYXRlcic6J1xcXFx1MjJEQScsJ0xlc3NGdWxsRXF1YWwnOidcXFxcdTIyNjYnLCdMZXNzR3JlYXRlcic6J1xcXFx1MjI3NicsJ2xlc3NndHInOidcXFxcdTIyNzYnLCdMZXNzTGVzcyc6J1xcXFx1MkFBMScsJ2xlc3NzaW0nOidcXFxcdTIyNzInLCdMZXNzU2xhbnRFcXVhbCc6J1xcXFx1MkE3RCcsJ0xlc3NUaWxkZSc6J1xcXFx1MjI3MicsJ2xmaXNodCc6J1xcXFx1Mjk3QycsJ2xmbG9vcic6J1xcXFx1MjMwQScsJ2xmcic6J1xcXFx1RDgzNVxcXFx1REQyOScsJ0xmcic6J1xcXFx1RDgzNVxcXFx1REQwRicsJ2xnJzonXFxcXHUyMjc2JywnbGdFJzonXFxcXHUyQTkxJywnbEhhcic6J1xcXFx1Mjk2MicsJ2xoYXJkJzonXFxcXHUyMUJEJywnbGhhcnUnOidcXFxcdTIxQkMnLCdsaGFydWwnOidcXFxcdTI5NkEnLCdsaGJsayc6J1xcXFx1MjU4NCcsJ2xqY3knOidcXFxcdTA0NTknLCdMSmN5JzonXFxcXHUwNDA5JywnbGwnOidcXFxcdTIyNkEnLCdMbCc6J1xcXFx1MjJEOCcsJ2xsYXJyJzonXFxcXHUyMUM3JywnbGxjb3JuZXInOidcXFxcdTIzMUUnLCdMbGVmdGFycm93JzonXFxcXHUyMURBJywnbGxoYXJkJzonXFxcXHUyOTZCJywnbGx0cmknOidcXFxcdTI1RkEnLCdsbWlkb3QnOidcXFxcdTAxNDAnLCdMbWlkb3QnOidcXFxcdTAxM0YnLCdsbW91c3QnOidcXFxcdTIzQjAnLCdsbW91c3RhY2hlJzonXFxcXHUyM0IwJywnbG5hcCc6J1xcXFx1MkE4OScsJ2xuYXBwcm94JzonXFxcXHUyQTg5JywnbG5lJzonXFxcXHUyQTg3JywnbG5FJzonXFxcXHUyMjY4JywnbG5lcSc6J1xcXFx1MkE4NycsJ2xuZXFxJzonXFxcXHUyMjY4JywnbG5zaW0nOidcXFxcdTIyRTYnLCdsb2FuZyc6J1xcXFx1MjdFQycsJ2xvYXJyJzonXFxcXHUyMUZEJywnbG9icmsnOidcXFxcdTI3RTYnLCdsb25nbGVmdGFycm93JzonXFxcXHUyN0Y1JywnTG9uZ2xlZnRhcnJvdyc6J1xcXFx1MjdGOCcsJ0xvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjUnLCdsb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RjcnLCdMb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RkEnLCdMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RjcnLCdsb25nbWFwc3RvJzonXFxcXHUyN0ZDJywnbG9uZ3JpZ2h0YXJyb3cnOidcXFxcdTI3RjYnLCdMb25ncmlnaHRhcnJvdyc6J1xcXFx1MjdGOScsJ0xvbmdSaWdodEFycm93JzonXFxcXHUyN0Y2JywnbG9vcGFycm93bGVmdCc6J1xcXFx1MjFBQicsJ2xvb3BhcnJvd3JpZ2h0JzonXFxcXHUyMUFDJywnbG9wYXInOidcXFxcdTI5ODUnLCdsb3BmJzonXFxcXHVEODM1XFxcXHVERDVEJywnTG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MycsJ2xvcGx1cyc6J1xcXFx1MkEyRCcsJ2xvdGltZXMnOidcXFxcdTJBMzQnLCdsb3dhc3QnOidcXFxcdTIyMTcnLCdsb3diYXInOidfJywnTG93ZXJMZWZ0QXJyb3cnOidcXFxcdTIxOTknLCdMb3dlclJpZ2h0QXJyb3cnOidcXFxcdTIxOTgnLCdsb3onOidcXFxcdTI1Q0EnLCdsb3plbmdlJzonXFxcXHUyNUNBJywnbG96Zic6J1xcXFx1MjlFQicsJ2xwYXInOicoJywnbHBhcmx0JzonXFxcXHUyOTkzJywnbHJhcnInOidcXFxcdTIxQzYnLCdscmNvcm5lcic6J1xcXFx1MjMxRicsJ2xyaGFyJzonXFxcXHUyMUNCJywnbHJoYXJkJzonXFxcXHUyOTZEJywnbHJtJzonXFxcXHUyMDBFJywnbHJ0cmknOidcXFxcdTIyQkYnLCdsc2FxdW8nOidcXFxcdTIwMzknLCdsc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MxJywnTHNjcic6J1xcXFx1MjExMicsJ2xzaCc6J1xcXFx1MjFCMCcsJ0xzaCc6J1xcXFx1MjFCMCcsJ2xzaW0nOidcXFxcdTIyNzInLCdsc2ltZSc6J1xcXFx1MkE4RCcsJ2xzaW1nJzonXFxcXHUyQThGJywnbHNxYic6J1snLCdsc3F1byc6J1xcXFx1MjAxOCcsJ2xzcXVvcic6J1xcXFx1MjAxQScsJ2xzdHJvayc6J1xcXFx1MDE0MicsJ0xzdHJvayc6J1xcXFx1MDE0MScsJ2x0JzonPCcsJ0x0JzonXFxcXHUyMjZBJywnTFQnOic8JywnbHRjYyc6J1xcXFx1MkFBNicsJ2x0Y2lyJzonXFxcXHUyQTc5JywnbHRkb3QnOidcXFxcdTIyRDYnLCdsdGhyZWUnOidcXFxcdTIyQ0InLCdsdGltZXMnOidcXFxcdTIyQzknLCdsdGxhcnInOidcXFxcdTI5NzYnLCdsdHF1ZXN0JzonXFxcXHUyQTdCJywnbHRyaSc6J1xcXFx1MjVDMycsJ2x0cmllJzonXFxcXHUyMkI0JywnbHRyaWYnOidcXFxcdTI1QzInLCdsdHJQYXInOidcXFxcdTI5OTYnLCdsdXJkc2hhcic6J1xcXFx1Mjk0QScsJ2x1cnVoYXInOidcXFxcdTI5NjYnLCdsdmVydG5lcXEnOidcXFxcdTIyNjhcXFxcdUZFMDAnLCdsdm5FJzonXFxcXHUyMjY4XFxcXHVGRTAwJywnbWFjcic6J1xcXFx4QUYnLCdtYWxlJzonXFxcXHUyNjQyJywnbWFsdCc6J1xcXFx1MjcyMCcsJ21hbHRlc2UnOidcXFxcdTI3MjAnLCdtYXAnOidcXFxcdTIxQTYnLCdNYXAnOidcXFxcdTI5MDUnLCdtYXBzdG8nOidcXFxcdTIxQTYnLCdtYXBzdG9kb3duJzonXFxcXHUyMUE3JywnbWFwc3RvbGVmdCc6J1xcXFx1MjFBNCcsJ21hcHN0b3VwJzonXFxcXHUyMUE1JywnbWFya2VyJzonXFxcXHUyNUFFJywnbWNvbW1hJzonXFxcXHUyQTI5JywnbWN5JzonXFxcXHUwNDNDJywnTWN5JzonXFxcXHUwNDFDJywnbWRhc2gnOidcXFxcdTIwMTQnLCdtRERvdCc6J1xcXFx1MjIzQScsJ21lYXN1cmVkYW5nbGUnOidcXFxcdTIyMjEnLCdNZWRpdW1TcGFjZSc6J1xcXFx1MjA1RicsJ01lbGxpbnRyZic6J1xcXFx1MjEzMycsJ21mcic6J1xcXFx1RDgzNVxcXFx1REQyQScsJ01mcic6J1xcXFx1RDgzNVxcXFx1REQxMCcsJ21obyc6J1xcXFx1MjEyNycsJ21pY3JvJzonXFxcXHhCNScsJ21pZCc6J1xcXFx1MjIyMycsJ21pZGFzdCc6JyonLCdtaWRjaXInOidcXFxcdTJBRjAnLCdtaWRkb3QnOidcXFxceEI3JywnbWludXMnOidcXFxcdTIyMTInLCdtaW51c2InOidcXFxcdTIyOUYnLCdtaW51c2QnOidcXFxcdTIyMzgnLCdtaW51c2R1JzonXFxcXHUyQTJBJywnTWludXNQbHVzJzonXFxcXHUyMjEzJywnbWxjcCc6J1xcXFx1MkFEQicsJ21sZHInOidcXFxcdTIwMjYnLCdtbnBsdXMnOidcXFxcdTIyMTMnLCdtb2RlbHMnOidcXFxcdTIyQTcnLCdtb3BmJzonXFxcXHVEODM1XFxcXHVERDVFJywnTW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0NCcsJ21wJzonXFxcXHUyMjEzJywnbXNjcic6J1xcXFx1RDgzNVxcXFx1RENDMicsJ01zY3InOidcXFxcdTIxMzMnLCdtc3Rwb3MnOidcXFxcdTIyM0UnLCdtdSc6J1xcXFx1MDNCQycsJ011JzonXFxcXHUwMzlDJywnbXVsdGltYXAnOidcXFxcdTIyQjgnLCdtdW1hcCc6J1xcXFx1MjJCOCcsJ25hYmxhJzonXFxcXHUyMjA3JywnbmFjdXRlJzonXFxcXHUwMTQ0JywnTmFjdXRlJzonXFxcXHUwMTQzJywnbmFuZyc6J1xcXFx1MjIyMFxcXFx1MjBEMicsJ25hcCc6J1xcXFx1MjI0OScsJ25hcEUnOidcXFxcdTJBNzBcXFxcdTAzMzgnLCduYXBpZCc6J1xcXFx1MjI0QlxcXFx1MDMzOCcsJ25hcG9zJzonXFxcXHUwMTQ5JywnbmFwcHJveCc6J1xcXFx1MjI0OScsJ25hdHVyJzonXFxcXHUyNjZFJywnbmF0dXJhbCc6J1xcXFx1MjY2RScsJ25hdHVyYWxzJzonXFxcXHUyMTE1JywnbmJzcCc6J1xcXFx4QTAnLCduYnVtcCc6J1xcXFx1MjI0RVxcXFx1MDMzOCcsJ25idW1wZSc6J1xcXFx1MjI0RlxcXFx1MDMzOCcsJ25jYXAnOidcXFxcdTJBNDMnLCduY2Fyb24nOidcXFxcdTAxNDgnLCdOY2Fyb24nOidcXFxcdTAxNDcnLCduY2VkaWwnOidcXFxcdTAxNDYnLCdOY2VkaWwnOidcXFxcdTAxNDUnLCduY29uZyc6J1xcXFx1MjI0NycsJ25jb25nZG90JzonXFxcXHUyQTZEXFxcXHUwMzM4JywnbmN1cCc6J1xcXFx1MkE0MicsJ25jeSc6J1xcXFx1MDQzRCcsJ05jeSc6J1xcXFx1MDQxRCcsJ25kYXNoJzonXFxcXHUyMDEzJywnbmUnOidcXFxcdTIyNjAnLCduZWFyaGsnOidcXFxcdTI5MjQnLCduZWFycic6J1xcXFx1MjE5NycsJ25lQXJyJzonXFxcXHUyMUQ3JywnbmVhcnJvdyc6J1xcXFx1MjE5NycsJ25lZG90JzonXFxcXHUyMjUwXFxcXHUwMzM4JywnTmVnYXRpdmVNZWRpdW1TcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpY2tTcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpblNwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBCJywnbmVxdWl2JzonXFxcXHUyMjYyJywnbmVzZWFyJzonXFxcXHUyOTI4JywnbmVzaW0nOidcXFxcdTIyNDJcXFxcdTAzMzgnLCdOZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QicsJ05lc3RlZExlc3NMZXNzJzonXFxcXHUyMjZBJywnTmV3TGluZSc6J1xcXFxuJywnbmV4aXN0JzonXFxcXHUyMjA0JywnbmV4aXN0cyc6J1xcXFx1MjIwNCcsJ25mcic6J1xcXFx1RDgzNVxcXFx1REQyQicsJ05mcic6J1xcXFx1RDgzNVxcXFx1REQxMScsJ25nZSc6J1xcXFx1MjI3MScsJ25nRSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXEnOidcXFxcdTIyNzEnLCduZ2VxcSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXFzbGFudCc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ25nZXMnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCduR2cnOidcXFxcdTIyRDlcXFxcdTAzMzgnLCduZ3NpbSc6J1xcXFx1MjI3NScsJ25ndCc6J1xcXFx1MjI2RicsJ25HdCc6J1xcXFx1MjI2QlxcXFx1MjBEMicsJ25ndHInOidcXFxcdTIyNkYnLCduR3R2JzonXFxcXHUyMjZCXFxcXHUwMzM4JywnbmhhcnInOidcXFxcdTIxQUUnLCduaEFycic6J1xcXFx1MjFDRScsJ25ocGFyJzonXFxcXHUyQUYyJywnbmknOidcXFxcdTIyMEInLCduaXMnOidcXFxcdTIyRkMnLCduaXNkJzonXFxcXHUyMkZBJywnbml2JzonXFxcXHUyMjBCJywnbmpjeSc6J1xcXFx1MDQ1QScsJ05KY3knOidcXFxcdTA0MEEnLCdubGFycic6J1xcXFx1MjE5QScsJ25sQXJyJzonXFxcXHUyMUNEJywnbmxkcic6J1xcXFx1MjAyNScsJ25sZSc6J1xcXFx1MjI3MCcsJ25sRSc6J1xcXFx1MjI2NlxcXFx1MDMzOCcsJ25sZWZ0YXJyb3cnOidcXFxcdTIxOUEnLCduTGVmdGFycm93JzonXFxcXHUyMUNEJywnbmxlZnRyaWdodGFycm93JzonXFxcXHUyMUFFJywnbkxlZnRyaWdodGFycm93JzonXFxcXHUyMUNFJywnbmxlcSc6J1xcXFx1MjI3MCcsJ25sZXFxJzonXFxcXHUyMjY2XFxcXHUwMzM4JywnbmxlcXNsYW50JzonXFxcXHUyQTdEXFxcXHUwMzM4Jywnbmxlcyc6J1xcXFx1MkE3RFxcXFx1MDMzOCcsJ25sZXNzJzonXFxcXHUyMjZFJywnbkxsJzonXFxcXHUyMkQ4XFxcXHUwMzM4JywnbmxzaW0nOidcXFxcdTIyNzQnLCdubHQnOidcXFxcdTIyNkUnLCduTHQnOidcXFxcdTIyNkFcXFxcdTIwRDInLCdubHRyaSc6J1xcXFx1MjJFQScsJ25sdHJpZSc6J1xcXFx1MjJFQycsJ25MdHYnOidcXFxcdTIyNkFcXFxcdTAzMzgnLCdubWlkJzonXFxcXHUyMjI0JywnTm9CcmVhayc6J1xcXFx1MjA2MCcsJ05vbkJyZWFraW5nU3BhY2UnOidcXFxceEEwJywnbm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1RicsJ05vcGYnOidcXFxcdTIxMTUnLCdub3QnOidcXFxceEFDJywnTm90JzonXFxcXHUyQUVDJywnTm90Q29uZ3J1ZW50JzonXFxcXHUyMjYyJywnTm90Q3VwQ2FwJzonXFxcXHUyMjZEJywnTm90RG91YmxlVmVydGljYWxCYXInOidcXFxcdTIyMjYnLCdOb3RFbGVtZW50JzonXFxcXHUyMjA5JywnTm90RXF1YWwnOidcXFxcdTIyNjAnLCdOb3RFcXVhbFRpbGRlJzonXFxcXHUyMjQyXFxcXHUwMzM4JywnTm90RXhpc3RzJzonXFxcXHUyMjA0JywnTm90R3JlYXRlcic6J1xcXFx1MjI2RicsJ05vdEdyZWF0ZXJFcXVhbCc6J1xcXFx1MjI3MScsJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjdcXFxcdTAzMzgnLCdOb3RHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QlxcXFx1MDMzOCcsJ05vdEdyZWF0ZXJMZXNzJzonXFxcXHUyMjc5JywnTm90R3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCdOb3RHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzUnLCdOb3RIdW1wRG93bkh1bXAnOidcXFxcdTIyNEVcXFxcdTAzMzgnLCdOb3RIdW1wRXF1YWwnOidcXFxcdTIyNEZcXFxcdTAzMzgnLCdub3Rpbic6J1xcXFx1MjIwOScsJ25vdGluZG90JzonXFxcXHUyMkY1XFxcXHUwMzM4Jywnbm90aW5FJzonXFxcXHUyMkY5XFxcXHUwMzM4Jywnbm90aW52YSc6J1xcXFx1MjIwOScsJ25vdGludmInOidcXFxcdTIyRjcnLCdub3RpbnZjJzonXFxcXHUyMkY2JywnTm90TGVmdFRyaWFuZ2xlJzonXFxcXHUyMkVBJywnTm90TGVmdFRyaWFuZ2xlQmFyJzonXFxcXHUyOUNGXFxcXHUwMzM4JywnTm90TGVmdFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyRUMnLCdOb3RMZXNzJzonXFxcXHUyMjZFJywnTm90TGVzc0VxdWFsJzonXFxcXHUyMjcwJywnTm90TGVzc0dyZWF0ZXInOidcXFxcdTIyNzgnLCdOb3RMZXNzTGVzcyc6J1xcXFx1MjI2QVxcXFx1MDMzOCcsJ05vdExlc3NTbGFudEVxdWFsJzonXFxcXHUyQTdEXFxcXHUwMzM4JywnTm90TGVzc1RpbGRlJzonXFxcXHUyMjc0JywnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXFxcdTJBQTJcXFxcdTAzMzgnLCdOb3ROZXN0ZWRMZXNzTGVzcyc6J1xcXFx1MkFBMVxcXFx1MDMzOCcsJ25vdG5pJzonXFxcXHUyMjBDJywnbm90bml2YSc6J1xcXFx1MjIwQycsJ25vdG5pdmInOidcXFxcdTIyRkUnLCdub3RuaXZjJzonXFxcXHUyMkZEJywnTm90UHJlY2VkZXMnOidcXFxcdTIyODAnLCdOb3RQcmVjZWRlc0VxdWFsJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnTm90UHJlY2VkZXNTbGFudEVxdWFsJzonXFxcXHUyMkUwJywnTm90UmV2ZXJzZUVsZW1lbnQnOidcXFxcdTIyMEMnLCdOb3RSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkVCJywnTm90UmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMFxcXFx1MDMzOCcsJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJFRCcsJ05vdFNxdWFyZVN1YnNldCc6J1xcXFx1MjI4RlxcXFx1MDMzOCcsJ05vdFNxdWFyZVN1YnNldEVxdWFsJzonXFxcXHUyMkUyJywnTm90U3F1YXJlU3VwZXJzZXQnOidcXFxcdTIyOTBcXFxcdTAzMzgnLCdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzonXFxcXHUyMkUzJywnTm90U3Vic2V0JzonXFxcXHUyMjgyXFxcXHUyMEQyJywnTm90U3Vic2V0RXF1YWwnOidcXFxcdTIyODgnLCdOb3RTdWNjZWVkcyc6J1xcXFx1MjI4MScsJ05vdFN1Y2NlZWRzRXF1YWwnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCdOb3RTdWNjZWVkc1NsYW50RXF1YWwnOidcXFxcdTIyRTEnLCdOb3RTdWNjZWVkc1RpbGRlJzonXFxcXHUyMjdGXFxcXHUwMzM4JywnTm90U3VwZXJzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCdOb3RTdXBlcnNldEVxdWFsJzonXFxcXHUyMjg5JywnTm90VGlsZGUnOidcXFxcdTIyNDEnLCdOb3RUaWxkZUVxdWFsJzonXFxcXHUyMjQ0JywnTm90VGlsZGVGdWxsRXF1YWwnOidcXFxcdTIyNDcnLCdOb3RUaWxkZVRpbGRlJzonXFxcXHUyMjQ5JywnTm90VmVydGljYWxCYXInOidcXFxcdTIyMjQnLCducGFyJzonXFxcXHUyMjI2JywnbnBhcmFsbGVsJzonXFxcXHUyMjI2JywnbnBhcnNsJzonXFxcXHUyQUZEXFxcXHUyMEU1JywnbnBhcnQnOidcXFxcdTIyMDJcXFxcdTAzMzgnLCducG9saW50JzonXFxcXHUyQTE0JywnbnByJzonXFxcXHUyMjgwJywnbnByY3VlJzonXFxcXHUyMkUwJywnbnByZSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25wcmVjJzonXFxcXHUyMjgwJywnbnByZWNlcSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25yYXJyJzonXFxcXHUyMTlCJywnbnJBcnInOidcXFxcdTIxQ0YnLCducmFycmMnOidcXFxcdTI5MzNcXFxcdTAzMzgnLCducmFycncnOidcXFxcdTIxOURcXFxcdTAzMzgnLCducmlnaHRhcnJvdyc6J1xcXFx1MjE5QicsJ25SaWdodGFycm93JzonXFxcXHUyMUNGJywnbnJ0cmknOidcXFxcdTIyRUInLCducnRyaWUnOidcXFxcdTIyRUQnLCduc2MnOidcXFxcdTIyODEnLCduc2NjdWUnOidcXFxcdTIyRTEnLCduc2NlJzonXFxcXHUyQUIwXFxcXHUwMzM4JywnbnNjcic6J1xcXFx1RDgzNVxcXFx1RENDMycsJ05zY3InOidcXFxcdUQ4MzVcXFxcdURDQTknLCduc2hvcnRtaWQnOidcXFxcdTIyMjQnLCduc2hvcnRwYXJhbGxlbCc6J1xcXFx1MjIyNicsJ25zaW0nOidcXFxcdTIyNDEnLCduc2ltZSc6J1xcXFx1MjI0NCcsJ25zaW1lcSc6J1xcXFx1MjI0NCcsJ25zbWlkJzonXFxcXHUyMjI0JywnbnNwYXInOidcXFxcdTIyMjYnLCduc3FzdWJlJzonXFxcXHUyMkUyJywnbnNxc3VwZSc6J1xcXFx1MjJFMycsJ25zdWInOidcXFxcdTIyODQnLCduc3ViZSc6J1xcXFx1MjI4OCcsJ25zdWJFJzonXFxcXHUyQUM1XFxcXHUwMzM4JywnbnN1YnNldCc6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ25zdWJzZXRlcSc6J1xcXFx1MjI4OCcsJ25zdWJzZXRlcXEnOidcXFxcdTJBQzVcXFxcdTAzMzgnLCduc3VjYyc6J1xcXFx1MjI4MScsJ25zdWNjZXEnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCduc3VwJzonXFxcXHUyMjg1JywnbnN1cGUnOidcXFxcdTIyODknLCduc3VwRSc6J1xcXFx1MkFDNlxcXFx1MDMzOCcsJ25zdXBzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCduc3Vwc2V0ZXEnOidcXFxcdTIyODknLCduc3Vwc2V0ZXFxJzonXFxcXHUyQUM2XFxcXHUwMzM4JywnbnRnbCc6J1xcXFx1MjI3OScsJ250aWxkZSc6J1xcXFx4RjEnLCdOdGlsZGUnOidcXFxceEQxJywnbnRsZyc6J1xcXFx1MjI3OCcsJ250cmlhbmdsZWxlZnQnOidcXFxcdTIyRUEnLCdudHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyRUMnLCdudHJpYW5nbGVyaWdodCc6J1xcXFx1MjJFQicsJ250cmlhbmdsZXJpZ2h0ZXEnOidcXFxcdTIyRUQnLCdudSc6J1xcXFx1MDNCRCcsJ051JzonXFxcXHUwMzlEJywnbnVtJzonIycsJ251bWVybyc6J1xcXFx1MjExNicsJ251bXNwJzonXFxcXHUyMDA3JywnbnZhcCc6J1xcXFx1MjI0RFxcXFx1MjBEMicsJ252ZGFzaCc6J1xcXFx1MjJBQycsJ252RGFzaCc6J1xcXFx1MjJBRCcsJ25WZGFzaCc6J1xcXFx1MjJBRScsJ25WRGFzaCc6J1xcXFx1MjJBRicsJ252Z2UnOidcXFxcdTIyNjVcXFxcdTIwRDInLCdudmd0JzonPlxcXFx1MjBEMicsJ252SGFycic6J1xcXFx1MjkwNCcsJ252aW5maW4nOidcXFxcdTI5REUnLCdudmxBcnInOidcXFxcdTI5MDInLCdudmxlJzonXFxcXHUyMjY0XFxcXHUyMEQyJywnbnZsdCc6JzxcXFxcdTIwRDInLCdudmx0cmllJzonXFxcXHUyMkI0XFxcXHUyMEQyJywnbnZyQXJyJzonXFxcXHUyOTAzJywnbnZydHJpZSc6J1xcXFx1MjJCNVxcXFx1MjBEMicsJ252c2ltJzonXFxcXHUyMjNDXFxcXHUyMEQyJywnbndhcmhrJzonXFxcXHUyOTIzJywnbndhcnInOidcXFxcdTIxOTYnLCdud0Fycic6J1xcXFx1MjFENicsJ253YXJyb3cnOidcXFxcdTIxOTYnLCdud25lYXInOidcXFxcdTI5MjcnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29hc3QnOidcXFxcdTIyOUInLCdvY2lyJzonXFxcXHUyMjlBJywnb2NpcmMnOidcXFxceEY0JywnT2NpcmMnOidcXFxceEQ0Jywnb2N5JzonXFxcXHUwNDNFJywnT2N5JzonXFxcXHUwNDFFJywnb2Rhc2gnOidcXFxcdTIyOUQnLCdvZGJsYWMnOidcXFxcdTAxNTEnLCdPZGJsYWMnOidcXFxcdTAxNTAnLCdvZGl2JzonXFxcXHUyQTM4Jywnb2RvdCc6J1xcXFx1MjI5OScsJ29kc29sZCc6J1xcXFx1MjlCQycsJ29lbGlnJzonXFxcXHUwMTUzJywnT0VsaWcnOidcXFxcdTAxNTInLCdvZmNpcic6J1xcXFx1MjlCRicsJ29mcic6J1xcXFx1RDgzNVxcXFx1REQyQycsJ09mcic6J1xcXFx1RDgzNVxcXFx1REQxMicsJ29nb24nOidcXFxcdTAyREInLCdvZ3JhdmUnOidcXFxceEYyJywnT2dyYXZlJzonXFxcXHhEMicsJ29ndCc6J1xcXFx1MjlDMScsJ29oYmFyJzonXFxcXHUyOUI1Jywnb2htJzonXFxcXHUwM0E5Jywnb2ludCc6J1xcXFx1MjIyRScsJ29sYXJyJzonXFxcXHUyMUJBJywnb2xjaXInOidcXFxcdTI5QkUnLCdvbGNyb3NzJzonXFxcXHUyOUJCJywnb2xpbmUnOidcXFxcdTIwM0UnLCdvbHQnOidcXFxcdTI5QzAnLCdvbWFjcic6J1xcXFx1MDE0RCcsJ09tYWNyJzonXFxcXHUwMTRDJywnb21lZ2EnOidcXFxcdTAzQzknLCdPbWVnYSc6J1xcXFx1MDNBOScsJ29taWNyb24nOidcXFxcdTAzQkYnLCdPbWljcm9uJzonXFxcXHUwMzlGJywnb21pZCc6J1xcXFx1MjlCNicsJ29taW51cyc6J1xcXFx1MjI5NicsJ29vcGYnOidcXFxcdUQ4MzVcXFxcdURENjAnLCdPb3BmJzonXFxcXHVEODM1XFxcXHVERDQ2Jywnb3Bhcic6J1xcXFx1MjlCNycsJ09wZW5DdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFDJywnT3BlbkN1cmx5UXVvdGUnOidcXFxcdTIwMTgnLCdvcGVycCc6J1xcXFx1MjlCOScsJ29wbHVzJzonXFxcXHUyMjk1Jywnb3InOidcXFxcdTIyMjgnLCdPcic6J1xcXFx1MkE1NCcsJ29yYXJyJzonXFxcXHUyMUJCJywnb3JkJzonXFxcXHUyQTVEJywnb3JkZXInOidcXFxcdTIxMzQnLCdvcmRlcm9mJzonXFxcXHUyMTM0Jywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29yaWdvZic6J1xcXFx1MjJCNicsJ29yb3InOidcXFxcdTJBNTYnLCdvcnNsb3BlJzonXFxcXHUyQTU3Jywnb3J2JzonXFxcXHUyQTVCJywnb1MnOidcXFxcdTI0QzgnLCdvc2NyJzonXFxcXHUyMTM0JywnT3Njcic6J1xcXFx1RDgzNVxcXFx1RENBQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3NvbCc6J1xcXFx1MjI5OCcsJ290aWxkZSc6J1xcXFx4RjUnLCdPdGlsZGUnOidcXFxceEQ1Jywnb3RpbWVzJzonXFxcXHUyMjk3JywnT3RpbWVzJzonXFxcXHUyQTM3Jywnb3RpbWVzYXMnOidcXFxcdTJBMzYnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2Jywnb3ZiYXInOidcXFxcdTIzM0QnLCdPdmVyQmFyJzonXFxcXHUyMDNFJywnT3ZlckJyYWNlJzonXFxcXHUyM0RFJywnT3ZlckJyYWNrZXQnOidcXFxcdTIzQjQnLCdPdmVyUGFyZW50aGVzaXMnOidcXFxcdTIzREMnLCdwYXInOidcXFxcdTIyMjUnLCdwYXJhJzonXFxcXHhCNicsJ3BhcmFsbGVsJzonXFxcXHUyMjI1JywncGFyc2ltJzonXFxcXHUyQUYzJywncGFyc2wnOidcXFxcdTJBRkQnLCdwYXJ0JzonXFxcXHUyMjAyJywnUGFydGlhbEQnOidcXFxcdTIyMDInLCdwY3knOidcXFxcdTA0M0YnLCdQY3knOidcXFxcdTA0MUYnLCdwZXJjbnQnOiclJywncGVyaW9kJzonLicsJ3Blcm1pbCc6J1xcXFx1MjAzMCcsJ3BlcnAnOidcXFxcdTIyQTUnLCdwZXJ0ZW5rJzonXFxcXHUyMDMxJywncGZyJzonXFxcXHVEODM1XFxcXHVERDJEJywnUGZyJzonXFxcXHVEODM1XFxcXHVERDEzJywncGhpJzonXFxcXHUwM0M2JywnUGhpJzonXFxcXHUwM0E2JywncGhpdic6J1xcXFx1MDNENScsJ3BobW1hdCc6J1xcXFx1MjEzMycsJ3Bob25lJzonXFxcXHUyNjBFJywncGknOidcXFxcdTAzQzAnLCdQaSc6J1xcXFx1MDNBMCcsJ3BpdGNoZm9yayc6J1xcXFx1MjJENCcsJ3Bpdic6J1xcXFx1MDNENicsJ3BsYW5jayc6J1xcXFx1MjEwRicsJ3BsYW5ja2gnOidcXFxcdTIxMEUnLCdwbGFua3YnOidcXFxcdTIxMEYnLCdwbHVzJzonKycsJ3BsdXNhY2lyJzonXFxcXHUyQTIzJywncGx1c2InOidcXFxcdTIyOUUnLCdwbHVzY2lyJzonXFxcXHUyQTIyJywncGx1c2RvJzonXFxcXHUyMjE0JywncGx1c2R1JzonXFxcXHUyQTI1JywncGx1c2UnOidcXFxcdTJBNzInLCdQbHVzTWludXMnOidcXFxceEIxJywncGx1c21uJzonXFxcXHhCMScsJ3BsdXNzaW0nOidcXFxcdTJBMjYnLCdwbHVzdHdvJzonXFxcXHUyQTI3JywncG0nOidcXFxceEIxJywnUG9pbmNhcmVwbGFuZSc6J1xcXFx1MjEwQycsJ3BvaW50aW50JzonXFxcXHUyQTE1JywncG9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MScsJ1BvcGYnOidcXFxcdTIxMTknLCdwb3VuZCc6J1xcXFx4QTMnLCdwcic6J1xcXFx1MjI3QScsJ1ByJzonXFxcXHUyQUJCJywncHJhcCc6J1xcXFx1MkFCNycsJ3ByY3VlJzonXFxcXHUyMjdDJywncHJlJzonXFxcXHUyQUFGJywncHJFJzonXFxcXHUyQUIzJywncHJlYyc6J1xcXFx1MjI3QScsJ3ByZWNhcHByb3gnOidcXFxcdTJBQjcnLCdwcmVjY3VybHllcSc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzJzonXFxcXHUyMjdBJywnUHJlY2VkZXNFcXVhbCc6J1xcXFx1MkFBRicsJ1ByZWNlZGVzU2xhbnRFcXVhbCc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzVGlsZGUnOidcXFxcdTIyN0UnLCdwcmVjZXEnOidcXFxcdTJBQUYnLCdwcmVjbmFwcHJveCc6J1xcXFx1MkFCOScsJ3ByZWNuZXFxJzonXFxcXHUyQUI1JywncHJlY25zaW0nOidcXFxcdTIyRTgnLCdwcmVjc2ltJzonXFxcXHUyMjdFJywncHJpbWUnOidcXFxcdTIwMzInLCdQcmltZSc6J1xcXFx1MjAzMycsJ3ByaW1lcyc6J1xcXFx1MjExOScsJ3BybmFwJzonXFxcXHUyQUI5JywncHJuRSc6J1xcXFx1MkFCNScsJ3BybnNpbSc6J1xcXFx1MjJFOCcsJ3Byb2QnOidcXFxcdTIyMEYnLCdQcm9kdWN0JzonXFxcXHUyMjBGJywncHJvZmFsYXInOidcXFxcdTIzMkUnLCdwcm9mbGluZSc6J1xcXFx1MjMxMicsJ3Byb2ZzdXJmJzonXFxcXHUyMzEzJywncHJvcCc6J1xcXFx1MjIxRCcsJ1Byb3BvcnRpb24nOidcXFxcdTIyMzcnLCdQcm9wb3J0aW9uYWwnOidcXFxcdTIyMUQnLCdwcm9wdG8nOidcXFxcdTIyMUQnLCdwcnNpbSc6J1xcXFx1MjI3RScsJ3BydXJlbCc6J1xcXFx1MjJCMCcsJ3BzY3InOidcXFxcdUQ4MzVcXFxcdURDQzUnLCdQc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FCJywncHNpJzonXFxcXHUwM0M4JywnUHNpJzonXFxcXHUwM0E4JywncHVuY3NwJzonXFxcXHUyMDA4JywncWZyJzonXFxcXHVEODM1XFxcXHVERDJFJywnUWZyJzonXFxcXHVEODM1XFxcXHVERDE0JywncWludCc6J1xcXFx1MkEwQycsJ3FvcGYnOidcXFxcdUQ4MzVcXFxcdURENjInLCdRb3BmJzonXFxcXHUyMTFBJywncXByaW1lJzonXFxcXHUyMDU3JywncXNjcic6J1xcXFx1RDgzNVxcXFx1RENDNicsJ1FzY3InOidcXFxcdUQ4MzVcXFxcdURDQUMnLCdxdWF0ZXJuaW9ucyc6J1xcXFx1MjEwRCcsJ3F1YXRpbnQnOidcXFxcdTJBMTYnLCdxdWVzdCc6Jz8nLCdxdWVzdGVxJzonXFxcXHUyMjVGJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JBYXJyJzonXFxcXHUyMURCJywncmFjZSc6J1xcXFx1MjIzRFxcXFx1MDMzMScsJ3JhY3V0ZSc6J1xcXFx1MDE1NScsJ1JhY3V0ZSc6J1xcXFx1MDE1NCcsJ3JhZGljJzonXFxcXHUyMjFBJywncmFlbXB0eXYnOidcXFxcdTI5QjMnLCdyYW5nJzonXFxcXHUyN0U5JywnUmFuZyc6J1xcXFx1MjdFQicsJ3JhbmdkJzonXFxcXHUyOTkyJywncmFuZ2UnOidcXFxcdTI5QTUnLCdyYW5nbGUnOidcXFxcdTI3RTknLCdyYXF1byc6J1xcXFx4QkInLCdyYXJyJzonXFxcXHUyMTkyJywnckFycic6J1xcXFx1MjFEMicsJ1JhcnInOidcXFxcdTIxQTAnLCdyYXJyYXAnOidcXFxcdTI5NzUnLCdyYXJyYic6J1xcXFx1MjFFNScsJ3JhcnJiZnMnOidcXFxcdTI5MjAnLCdyYXJyYyc6J1xcXFx1MjkzMycsJ3JhcnJmcyc6J1xcXFx1MjkxRScsJ3JhcnJoayc6J1xcXFx1MjFBQScsJ3JhcnJscCc6J1xcXFx1MjFBQycsJ3JhcnJwbCc6J1xcXFx1Mjk0NScsJ3JhcnJzaW0nOidcXFxcdTI5NzQnLCdyYXJydGwnOidcXFxcdTIxQTMnLCdSYXJydGwnOidcXFxcdTI5MTYnLCdyYXJydyc6J1xcXFx1MjE5RCcsJ3JhdGFpbCc6J1xcXFx1MjkxQScsJ3JBdGFpbCc6J1xcXFx1MjkxQycsJ3JhdGlvJzonXFxcXHUyMjM2JywncmF0aW9uYWxzJzonXFxcXHUyMTFBJywncmJhcnInOidcXFxcdTI5MEQnLCdyQmFycic6J1xcXFx1MjkwRicsJ1JCYXJyJzonXFxcXHUyOTEwJywncmJicmsnOidcXFxcdTI3NzMnLCdyYnJhY2UnOid9JywncmJyYWNrJzonXScsJ3JicmtlJzonXFxcXHUyOThDJywncmJya3NsZCc6J1xcXFx1Mjk4RScsJ3JicmtzbHUnOidcXFxcdTI5OTAnLCdyY2Fyb24nOidcXFxcdTAxNTknLCdSY2Fyb24nOidcXFxcdTAxNTgnLCdyY2VkaWwnOidcXFxcdTAxNTcnLCdSY2VkaWwnOidcXFxcdTAxNTYnLCdyY2VpbCc6J1xcXFx1MjMwOScsJ3JjdWInOid9JywncmN5JzonXFxcXHUwNDQwJywnUmN5JzonXFxcXHUwNDIwJywncmRjYSc6J1xcXFx1MjkzNycsJ3JkbGRoYXInOidcXFxcdTI5NjknLCdyZHF1byc6J1xcXFx1MjAxRCcsJ3JkcXVvcic6J1xcXFx1MjAxRCcsJ3Jkc2gnOidcXFxcdTIxQjMnLCdSZSc6J1xcXFx1MjExQycsJ3JlYWwnOidcXFxcdTIxMUMnLCdyZWFsaW5lJzonXFxcXHUyMTFCJywncmVhbHBhcnQnOidcXFxcdTIxMUMnLCdyZWFscyc6J1xcXFx1MjExRCcsJ3JlY3QnOidcXFxcdTI1QUQnLCdyZWcnOidcXFxceEFFJywnUkVHJzonXFxcXHhBRScsJ1JldmVyc2VFbGVtZW50JzonXFxcXHUyMjBCJywnUmV2ZXJzZUVxdWlsaWJyaXVtJzonXFxcXHUyMUNCJywnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkYnLCdyZmlzaHQnOidcXFxcdTI5N0QnLCdyZmxvb3InOidcXFxcdTIzMEInLCdyZnInOidcXFxcdUQ4MzVcXFxcdUREMkYnLCdSZnInOidcXFxcdTIxMUMnLCdySGFyJzonXFxcXHUyOTY0JywncmhhcmQnOidcXFxcdTIxQzEnLCdyaGFydSc6J1xcXFx1MjFDMCcsJ3JoYXJ1bCc6J1xcXFx1Mjk2QycsJ3Jobyc6J1xcXFx1MDNDMScsJ1Jobyc6J1xcXFx1MDNBMScsJ3Job3YnOidcXFxcdTAzRjEnLCdSaWdodEFuZ2xlQnJhY2tldCc6J1xcXFx1MjdFOScsJ3JpZ2h0YXJyb3cnOidcXFxcdTIxOTInLCdSaWdodGFycm93JzonXFxcXHUyMUQyJywnUmlnaHRBcnJvdyc6J1xcXFx1MjE5MicsJ1JpZ2h0QXJyb3dCYXInOidcXFxcdTIxRTUnLCdSaWdodEFycm93TGVmdEFycm93JzonXFxcXHUyMUM0JywncmlnaHRhcnJvd3RhaWwnOidcXFxcdTIxQTMnLCdSaWdodENlaWxpbmcnOidcXFxcdTIzMDknLCdSaWdodERvdWJsZUJyYWNrZXQnOidcXFxcdTI3RTcnLCdSaWdodERvd25UZWVWZWN0b3InOidcXFxcdTI5NUQnLCdSaWdodERvd25WZWN0b3InOidcXFxcdTIxQzInLCdSaWdodERvd25WZWN0b3JCYXInOidcXFxcdTI5NTUnLCdSaWdodEZsb29yJzonXFxcXHUyMzBCJywncmlnaHRoYXJwb29uZG93bic6J1xcXFx1MjFDMScsJ3JpZ2h0aGFycG9vbnVwJzonXFxcXHUyMUMwJywncmlnaHRsZWZ0YXJyb3dzJzonXFxcXHUyMUM0JywncmlnaHRsZWZ0aGFycG9vbnMnOidcXFxcdTIxQ0MnLCdyaWdodHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM5JywncmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMTlEJywnUmlnaHRUZWUnOidcXFxcdTIyQTInLCdSaWdodFRlZUFycm93JzonXFxcXHUyMUE2JywnUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUInLCdyaWdodHRocmVldGltZXMnOidcXFxcdTIyQ0MnLCdSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkIzJywnUmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMCcsJ1JpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJCNScsJ1JpZ2h0VXBEb3duVmVjdG9yJzonXFxcXHUyOTRGJywnUmlnaHRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk1QycsJ1JpZ2h0VXBWZWN0b3InOidcXFxcdTIxQkUnLCdSaWdodFVwVmVjdG9yQmFyJzonXFxcXHUyOTU0JywnUmlnaHRWZWN0b3InOidcXFxcdTIxQzAnLCdSaWdodFZlY3RvckJhcic6J1xcXFx1Mjk1MycsJ3JpbmcnOidcXFxcdTAyREEnLCdyaXNpbmdkb3RzZXEnOidcXFxcdTIyNTMnLCdybGFycic6J1xcXFx1MjFDNCcsJ3JsaGFyJzonXFxcXHUyMUNDJywncmxtJzonXFxcXHUyMDBGJywncm1vdXN0JzonXFxcXHUyM0IxJywncm1vdXN0YWNoZSc6J1xcXFx1MjNCMScsJ3JubWlkJzonXFxcXHUyQUVFJywncm9hbmcnOidcXFxcdTI3RUQnLCdyb2Fycic6J1xcXFx1MjFGRScsJ3JvYnJrJzonXFxcXHUyN0U3Jywncm9wYXInOidcXFxcdTI5ODYnLCdyb3BmJzonXFxcXHVEODM1XFxcXHVERDYzJywnUm9wZic6J1xcXFx1MjExRCcsJ3JvcGx1cyc6J1xcXFx1MkEyRScsJ3JvdGltZXMnOidcXFxcdTJBMzUnLCdSb3VuZEltcGxpZXMnOidcXFxcdTI5NzAnLCdycGFyJzonKScsJ3JwYXJndCc6J1xcXFx1Mjk5NCcsJ3JwcG9saW50JzonXFxcXHUyQTEyJywncnJhcnInOidcXFxcdTIxQzknLCdScmlnaHRhcnJvdyc6J1xcXFx1MjFEQicsJ3JzYXF1byc6J1xcXFx1MjAzQScsJ3JzY3InOidcXFxcdUQ4MzVcXFxcdURDQzcnLCdSc2NyJzonXFxcXHUyMTFCJywncnNoJzonXFxcXHUyMUIxJywnUnNoJzonXFxcXHUyMUIxJywncnNxYic6J10nLCdyc3F1byc6J1xcXFx1MjAxOScsJ3JzcXVvcic6J1xcXFx1MjAxOScsJ3J0aHJlZSc6J1xcXFx1MjJDQycsJ3J0aW1lcyc6J1xcXFx1MjJDQScsJ3J0cmknOidcXFxcdTI1QjknLCdydHJpZSc6J1xcXFx1MjJCNScsJ3J0cmlmJzonXFxcXHUyNUI4JywncnRyaWx0cmknOidcXFxcdTI5Q0UnLCdSdWxlRGVsYXllZCc6J1xcXFx1MjlGNCcsJ3J1bHVoYXInOidcXFxcdTI5NjgnLCdyeCc6J1xcXFx1MjExRScsJ3NhY3V0ZSc6J1xcXFx1MDE1QicsJ1NhY3V0ZSc6J1xcXFx1MDE1QScsJ3NicXVvJzonXFxcXHUyMDFBJywnc2MnOidcXFxcdTIyN0InLCdTYyc6J1xcXFx1MkFCQycsJ3NjYXAnOidcXFxcdTJBQjgnLCdzY2Fyb24nOidcXFxcdTAxNjEnLCdTY2Fyb24nOidcXFxcdTAxNjAnLCdzY2N1ZSc6J1xcXFx1MjI3RCcsJ3NjZSc6J1xcXFx1MkFCMCcsJ3NjRSc6J1xcXFx1MkFCNCcsJ3NjZWRpbCc6J1xcXFx1MDE1RicsJ1NjZWRpbCc6J1xcXFx1MDE1RScsJ3NjaXJjJzonXFxcXHUwMTVEJywnU2NpcmMnOidcXFxcdTAxNUMnLCdzY25hcCc6J1xcXFx1MkFCQScsJ3NjbkUnOidcXFxcdTJBQjYnLCdzY25zaW0nOidcXFxcdTIyRTknLCdzY3BvbGludCc6J1xcXFx1MkExMycsJ3Njc2ltJzonXFxcXHUyMjdGJywnc2N5JzonXFxcXHUwNDQxJywnU2N5JzonXFxcXHUwNDIxJywnc2RvdCc6J1xcXFx1MjJDNScsJ3Nkb3RiJzonXFxcXHUyMkExJywnc2RvdGUnOidcXFxcdTJBNjYnLCdzZWFyaGsnOidcXFxcdTI5MjUnLCdzZWFycic6J1xcXFx1MjE5OCcsJ3NlQXJyJzonXFxcXHUyMUQ4Jywnc2VhcnJvdyc6J1xcXFx1MjE5OCcsJ3NlY3QnOidcXFxceEE3Jywnc2VtaSc6JzsnLCdzZXN3YXInOidcXFxcdTI5MjknLCdzZXRtaW51cyc6J1xcXFx1MjIxNicsJ3NldG1uJzonXFxcXHUyMjE2Jywnc2V4dCc6J1xcXFx1MjczNicsJ3Nmcic6J1xcXFx1RDgzNVxcXFx1REQzMCcsJ1Nmcic6J1xcXFx1RDgzNVxcXFx1REQxNicsJ3Nmcm93bic6J1xcXFx1MjMyMicsJ3NoYXJwJzonXFxcXHUyNjZGJywnc2hjaGN5JzonXFxcXHUwNDQ5JywnU0hDSGN5JzonXFxcXHUwNDI5Jywnc2hjeSc6J1xcXFx1MDQ0OCcsJ1NIY3knOidcXFxcdTA0MjgnLCdTaG9ydERvd25BcnJvdyc6J1xcXFx1MjE5MycsJ1Nob3J0TGVmdEFycm93JzonXFxcXHUyMTkwJywnc2hvcnRtaWQnOidcXFxcdTIyMjMnLCdzaG9ydHBhcmFsbGVsJzonXFxcXHUyMjI1JywnU2hvcnRSaWdodEFycm93JzonXFxcXHUyMTkyJywnU2hvcnRVcEFycm93JzonXFxcXHUyMTkxJywnc2h5JzonXFxcXHhBRCcsJ3NpZ21hJzonXFxcXHUwM0MzJywnU2lnbWEnOidcXFxcdTAzQTMnLCdzaWdtYWYnOidcXFxcdTAzQzInLCdzaWdtYXYnOidcXFxcdTAzQzInLCdzaW0nOidcXFxcdTIyM0MnLCdzaW1kb3QnOidcXFxcdTJBNkEnLCdzaW1lJzonXFxcXHUyMjQzJywnc2ltZXEnOidcXFxcdTIyNDMnLCdzaW1nJzonXFxcXHUyQTlFJywnc2ltZ0UnOidcXFxcdTJBQTAnLCdzaW1sJzonXFxcXHUyQTlEJywnc2ltbEUnOidcXFxcdTJBOUYnLCdzaW1uZSc6J1xcXFx1MjI0NicsJ3NpbXBsdXMnOidcXFxcdTJBMjQnLCdzaW1yYXJyJzonXFxcXHUyOTcyJywnc2xhcnInOidcXFxcdTIxOTAnLCdTbWFsbENpcmNsZSc6J1xcXFx1MjIxOCcsJ3NtYWxsc2V0bWludXMnOidcXFxcdTIyMTYnLCdzbWFzaHAnOidcXFxcdTJBMzMnLCdzbWVwYXJzbCc6J1xcXFx1MjlFNCcsJ3NtaWQnOidcXFxcdTIyMjMnLCdzbWlsZSc6J1xcXFx1MjMyMycsJ3NtdCc6J1xcXFx1MkFBQScsJ3NtdGUnOidcXFxcdTJBQUMnLCdzbXRlcyc6J1xcXFx1MkFBQ1xcXFx1RkUwMCcsJ3NvZnRjeSc6J1xcXFx1MDQ0QycsJ1NPRlRjeSc6J1xcXFx1MDQyQycsJ3NvbCc6Jy8nLCdzb2xiJzonXFxcXHUyOUM0Jywnc29sYmFyJzonXFxcXHUyMzNGJywnc29wZic6J1xcXFx1RDgzNVxcXFx1REQ2NCcsJ1NvcGYnOidcXFxcdUQ4MzVcXFxcdURENEEnLCdzcGFkZXMnOidcXFxcdTI2NjAnLCdzcGFkZXN1aXQnOidcXFxcdTI2NjAnLCdzcGFyJzonXFxcXHUyMjI1Jywnc3FjYXAnOidcXFxcdTIyOTMnLCdzcWNhcHMnOidcXFxcdTIyOTNcXFxcdUZFMDAnLCdzcWN1cCc6J1xcXFx1MjI5NCcsJ3NxY3Vwcyc6J1xcXFx1MjI5NFxcXFx1RkUwMCcsJ1NxcnQnOidcXFxcdTIyMUEnLCdzcXN1Yic6J1xcXFx1MjI4RicsJ3Nxc3ViZSc6J1xcXFx1MjI5MScsJ3Nxc3Vic2V0JzonXFxcXHUyMjhGJywnc3FzdWJzZXRlcSc6J1xcXFx1MjI5MScsJ3Nxc3VwJzonXFxcXHUyMjkwJywnc3FzdXBlJzonXFxcXHUyMjkyJywnc3FzdXBzZXQnOidcXFxcdTIyOTAnLCdzcXN1cHNldGVxJzonXFxcXHUyMjkyJywnc3F1JzonXFxcXHUyNUExJywnc3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlSW50ZXJzZWN0aW9uJzonXFxcXHUyMjkzJywnU3F1YXJlU3Vic2V0JzonXFxcXHUyMjhGJywnU3F1YXJlU3Vic2V0RXF1YWwnOidcXFxcdTIyOTEnLCdTcXVhcmVTdXBlcnNldCc6J1xcXFx1MjI5MCcsJ1NxdWFyZVN1cGVyc2V0RXF1YWwnOidcXFxcdTIyOTInLCdTcXVhcmVVbmlvbic6J1xcXFx1MjI5NCcsJ3NxdWFyZic6J1xcXFx1MjVBQScsJ3NxdWYnOidcXFxcdTI1QUEnLCdzcmFycic6J1xcXFx1MjE5MicsJ3NzY3InOidcXFxcdUQ4MzVcXFxcdURDQzgnLCdTc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FFJywnc3NldG1uJzonXFxcXHUyMjE2Jywnc3NtaWxlJzonXFxcXHUyMzIzJywnc3N0YXJmJzonXFxcXHUyMkM2Jywnc3Rhcic6J1xcXFx1MjYwNicsJ1N0YXInOidcXFxcdTIyQzYnLCdzdGFyZic6J1xcXFx1MjYwNScsJ3N0cmFpZ2h0ZXBzaWxvbic6J1xcXFx1MDNGNScsJ3N0cmFpZ2h0cGhpJzonXFxcXHUwM0Q1Jywnc3RybnMnOidcXFxceEFGJywnc3ViJzonXFxcXHUyMjgyJywnU3ViJzonXFxcXHUyMkQwJywnc3ViZG90JzonXFxcXHUyQUJEJywnc3ViZSc6J1xcXFx1MjI4NicsJ3N1YkUnOidcXFxcdTJBQzUnLCdzdWJlZG90JzonXFxcXHUyQUMzJywnc3VibXVsdCc6J1xcXFx1MkFDMScsJ3N1Ym5lJzonXFxcXHUyMjhBJywnc3VibkUnOidcXFxcdTJBQ0InLCdzdWJwbHVzJzonXFxcXHUyQUJGJywnc3VicmFycic6J1xcXFx1Mjk3OScsJ3N1YnNldCc6J1xcXFx1MjI4MicsJ1N1YnNldCc6J1xcXFx1MjJEMCcsJ3N1YnNldGVxJzonXFxcXHUyMjg2Jywnc3Vic2V0ZXFxJzonXFxcXHUyQUM1JywnU3Vic2V0RXF1YWwnOidcXFxcdTIyODYnLCdzdWJzZXRuZXEnOidcXFxcdTIyOEEnLCdzdWJzZXRuZXFxJzonXFxcXHUyQUNCJywnc3Vic2ltJzonXFxcXHUyQUM3Jywnc3Vic3ViJzonXFxcXHUyQUQ1Jywnc3Vic3VwJzonXFxcXHUyQUQzJywnc3VjYyc6J1xcXFx1MjI3QicsJ3N1Y2NhcHByb3gnOidcXFxcdTJBQjgnLCdzdWNjY3VybHllcSc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzJzonXFxcXHUyMjdCJywnU3VjY2VlZHNFcXVhbCc6J1xcXFx1MkFCMCcsJ1N1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzVGlsZGUnOidcXFxcdTIyN0YnLCdzdWNjZXEnOidcXFxcdTJBQjAnLCdzdWNjbmFwcHJveCc6J1xcXFx1MkFCQScsJ3N1Y2NuZXFxJzonXFxcXHUyQUI2Jywnc3VjY25zaW0nOidcXFxcdTIyRTknLCdzdWNjc2ltJzonXFxcXHUyMjdGJywnU3VjaFRoYXQnOidcXFxcdTIyMEInLCdzdW0nOidcXFxcdTIyMTEnLCdTdW0nOidcXFxcdTIyMTEnLCdzdW5nJzonXFxcXHUyNjZBJywnc3VwJzonXFxcXHUyMjgzJywnU3VwJzonXFxcXHUyMkQxJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3VwZG90JzonXFxcXHUyQUJFJywnc3VwZHN1Yic6J1xcXFx1MkFEOCcsJ3N1cGUnOidcXFxcdTIyODcnLCdzdXBFJzonXFxcXHUyQUM2Jywnc3VwZWRvdCc6J1xcXFx1MkFDNCcsJ1N1cGVyc2V0JzonXFxcXHUyMjgzJywnU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI4NycsJ3N1cGhzb2wnOidcXFxcdTI3QzknLCdzdXBoc3ViJzonXFxcXHUyQUQ3Jywnc3VwbGFycic6J1xcXFx1Mjk3QicsJ3N1cG11bHQnOidcXFxcdTJBQzInLCdzdXBuZSc6J1xcXFx1MjI4QicsJ3N1cG5FJzonXFxcXHUyQUNDJywnc3VwcGx1cyc6J1xcXFx1MkFDMCcsJ3N1cHNldCc6J1xcXFx1MjI4MycsJ1N1cHNldCc6J1xcXFx1MjJEMScsJ3N1cHNldGVxJzonXFxcXHUyMjg3Jywnc3Vwc2V0ZXFxJzonXFxcXHUyQUM2Jywnc3Vwc2V0bmVxJzonXFxcXHUyMjhCJywnc3Vwc2V0bmVxcSc6J1xcXFx1MkFDQycsJ3N1cHNpbSc6J1xcXFx1MkFDOCcsJ3N1cHN1Yic6J1xcXFx1MkFENCcsJ3N1cHN1cCc6J1xcXFx1MkFENicsJ3N3YXJoayc6J1xcXFx1MjkyNicsJ3N3YXJyJzonXFxcXHUyMTk5Jywnc3dBcnInOidcXFxcdTIxRDknLCdzd2Fycm93JzonXFxcXHUyMTk5Jywnc3dud2FyJzonXFxcXHUyOTJBJywnc3psaWcnOidcXFxceERGJywnVGFiJzonXFxcXHQnLCd0YXJnZXQnOidcXFxcdTIzMTYnLCd0YXUnOidcXFxcdTAzQzQnLCdUYXUnOidcXFxcdTAzQTQnLCd0YnJrJzonXFxcXHUyM0I0JywndGNhcm9uJzonXFxcXHUwMTY1JywnVGNhcm9uJzonXFxcXHUwMTY0JywndGNlZGlsJzonXFxcXHUwMTYzJywnVGNlZGlsJzonXFxcXHUwMTYyJywndGN5JzonXFxcXHUwNDQyJywnVGN5JzonXFxcXHUwNDIyJywndGRvdCc6J1xcXFx1MjBEQicsJ3RlbHJlYyc6J1xcXFx1MjMxNScsJ3Rmcic6J1xcXFx1RDgzNVxcXFx1REQzMScsJ1Rmcic6J1xcXFx1RDgzNVxcXFx1REQxNycsJ3RoZXJlNCc6J1xcXFx1MjIzNCcsJ3RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ1RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ3RoZXRhJzonXFxcXHUwM0I4JywnVGhldGEnOidcXFxcdTAzOTgnLCd0aGV0YXN5bSc6J1xcXFx1MDNEMScsJ3RoZXRhdic6J1xcXFx1MDNEMScsJ3RoaWNrYXBwcm94JzonXFxcXHUyMjQ4JywndGhpY2tzaW0nOidcXFxcdTIyM0MnLCdUaGlja1NwYWNlJzonXFxcXHUyMDVGXFxcXHUyMDBBJywndGhpbnNwJzonXFxcXHUyMDA5JywnVGhpblNwYWNlJzonXFxcXHUyMDA5JywndGhrYXAnOidcXFxcdTIyNDgnLCd0aGtzaW0nOidcXFxcdTIyM0MnLCd0aG9ybic6J1xcXFx4RkUnLCdUSE9STic6J1xcXFx4REUnLCd0aWxkZSc6J1xcXFx1MDJEQycsJ1RpbGRlJzonXFxcXHUyMjNDJywnVGlsZGVFcXVhbCc6J1xcXFx1MjI0MycsJ1RpbGRlRnVsbEVxdWFsJzonXFxcXHUyMjQ1JywnVGlsZGVUaWxkZSc6J1xcXFx1MjI0OCcsJ3RpbWVzJzonXFxcXHhENycsJ3RpbWVzYic6J1xcXFx1MjJBMCcsJ3RpbWVzYmFyJzonXFxcXHUyQTMxJywndGltZXNkJzonXFxcXHUyQTMwJywndGludCc6J1xcXFx1MjIyRCcsJ3RvZWEnOidcXFxcdTI5MjgnLCd0b3AnOidcXFxcdTIyQTQnLCd0b3Bib3QnOidcXFxcdTIzMzYnLCd0b3BjaXInOidcXFxcdTJBRjEnLCd0b3BmJzonXFxcXHVEODM1XFxcXHVERDY1JywnVG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0QicsJ3RvcGZvcmsnOidcXFxcdTJBREEnLCd0b3NhJzonXFxcXHUyOTI5JywndHByaW1lJzonXFxcXHUyMDM0JywndHJhZGUnOidcXFxcdTIxMjInLCdUUkFERSc6J1xcXFx1MjEyMicsJ3RyaWFuZ2xlJzonXFxcXHUyNUI1JywndHJpYW5nbGVkb3duJzonXFxcXHUyNUJGJywndHJpYW5nbGVsZWZ0JzonXFxcXHUyNUMzJywndHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyQjQnLCd0cmlhbmdsZXEnOidcXFxcdTIyNUMnLCd0cmlhbmdsZXJpZ2h0JzonXFxcXHUyNUI5JywndHJpYW5nbGVyaWdodGVxJzonXFxcXHUyMkI1JywndHJpZG90JzonXFxcXHUyNUVDJywndHJpZSc6J1xcXFx1MjI1QycsJ3RyaW1pbnVzJzonXFxcXHUyQTNBJywnVHJpcGxlRG90JzonXFxcXHUyMERCJywndHJpcGx1cyc6J1xcXFx1MkEzOScsJ3RyaXNiJzonXFxcXHUyOUNEJywndHJpdGltZSc6J1xcXFx1MkEzQicsJ3RycGV6aXVtJzonXFxcXHUyM0UyJywndHNjcic6J1xcXFx1RDgzNVxcXFx1RENDOScsJ1RzY3InOidcXFxcdUQ4MzVcXFxcdURDQUYnLCd0c2N5JzonXFxcXHUwNDQ2JywnVFNjeSc6J1xcXFx1MDQyNicsJ3RzaGN5JzonXFxcXHUwNDVCJywnVFNIY3knOidcXFxcdTA0MEInLCd0c3Ryb2snOidcXFxcdTAxNjcnLCdUc3Ryb2snOidcXFxcdTAxNjYnLCd0d2l4dCc6J1xcXFx1MjI2QycsJ3R3b2hlYWRsZWZ0YXJyb3cnOidcXFxcdTIxOUUnLCd0d29oZWFkcmlnaHRhcnJvdyc6J1xcXFx1MjFBMCcsJ3VhY3V0ZSc6J1xcXFx4RkEnLCdVYWN1dGUnOidcXFxceERBJywndWFycic6J1xcXFx1MjE5MScsJ3VBcnInOidcXFxcdTIxRDEnLCdVYXJyJzonXFxcXHUyMTlGJywnVWFycm9jaXInOidcXFxcdTI5NDknLCd1YnJjeSc6J1xcXFx1MDQ1RScsJ1VicmN5JzonXFxcXHUwNDBFJywndWJyZXZlJzonXFxcXHUwMTZEJywnVWJyZXZlJzonXFxcXHUwMTZDJywndWNpcmMnOidcXFxceEZCJywnVWNpcmMnOidcXFxceERCJywndWN5JzonXFxcXHUwNDQzJywnVWN5JzonXFxcXHUwNDIzJywndWRhcnInOidcXFxcdTIxQzUnLCd1ZGJsYWMnOidcXFxcdTAxNzEnLCdVZGJsYWMnOidcXFxcdTAxNzAnLCd1ZGhhcic6J1xcXFx1Mjk2RScsJ3VmaXNodCc6J1xcXFx1Mjk3RScsJ3Vmcic6J1xcXFx1RDgzNVxcXFx1REQzMicsJ1Vmcic6J1xcXFx1RDgzNVxcXFx1REQxOCcsJ3VncmF2ZSc6J1xcXFx4RjknLCdVZ3JhdmUnOidcXFxceEQ5JywndUhhcic6J1xcXFx1Mjk2MycsJ3VoYXJsJzonXFxcXHUyMUJGJywndWhhcnInOidcXFxcdTIxQkUnLCd1aGJsayc6J1xcXFx1MjU4MCcsJ3VsY29ybic6J1xcXFx1MjMxQycsJ3VsY29ybmVyJzonXFxcXHUyMzFDJywndWxjcm9wJzonXFxcXHUyMzBGJywndWx0cmknOidcXFxcdTI1RjgnLCd1bWFjcic6J1xcXFx1MDE2QicsJ1VtYWNyJzonXFxcXHUwMTZBJywndW1sJzonXFxcXHhBOCcsJ1VuZGVyQmFyJzonXycsJ1VuZGVyQnJhY2UnOidcXFxcdTIzREYnLCdVbmRlckJyYWNrZXQnOidcXFxcdTIzQjUnLCdVbmRlclBhcmVudGhlc2lzJzonXFxcXHUyM0REJywnVW5pb24nOidcXFxcdTIyQzMnLCdVbmlvblBsdXMnOidcXFxcdTIyOEUnLCd1b2dvbic6J1xcXFx1MDE3MycsJ1VvZ29uJzonXFxcXHUwMTcyJywndW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NicsJ1VvcGYnOidcXFxcdUQ4MzVcXFxcdURENEMnLCd1cGFycm93JzonXFxcXHUyMTkxJywnVXBhcnJvdyc6J1xcXFx1MjFEMScsJ1VwQXJyb3cnOidcXFxcdTIxOTEnLCdVcEFycm93QmFyJzonXFxcXHUyOTEyJywnVXBBcnJvd0Rvd25BcnJvdyc6J1xcXFx1MjFDNScsJ3VwZG93bmFycm93JzonXFxcXHUyMTk1JywnVXBkb3duYXJyb3cnOidcXFxcdTIxRDUnLCdVcERvd25BcnJvdyc6J1xcXFx1MjE5NScsJ1VwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkUnLCd1cGhhcnBvb25sZWZ0JzonXFxcXHUyMUJGJywndXBoYXJwb29ucmlnaHQnOidcXFxcdTIxQkUnLCd1cGx1cyc6J1xcXFx1MjI4RScsJ1VwcGVyTGVmdEFycm93JzonXFxcXHUyMTk2JywnVXBwZXJSaWdodEFycm93JzonXFxcXHUyMTk3JywndXBzaSc6J1xcXFx1MDNDNScsJ1Vwc2knOidcXFxcdTAzRDInLCd1cHNpaCc6J1xcXFx1MDNEMicsJ3Vwc2lsb24nOidcXFxcdTAzQzUnLCdVcHNpbG9uJzonXFxcXHUwM0E1JywnVXBUZWUnOidcXFxcdTIyQTUnLCdVcFRlZUFycm93JzonXFxcXHUyMUE1JywndXB1cGFycm93cyc6J1xcXFx1MjFDOCcsJ3VyY29ybic6J1xcXFx1MjMxRCcsJ3VyY29ybmVyJzonXFxcXHUyMzFEJywndXJjcm9wJzonXFxcXHUyMzBFJywndXJpbmcnOidcXFxcdTAxNkYnLCdVcmluZyc6J1xcXFx1MDE2RScsJ3VydHJpJzonXFxcXHUyNUY5JywndXNjcic6J1xcXFx1RDgzNVxcXFx1RENDQScsJ1VzY3InOidcXFxcdUQ4MzVcXFxcdURDQjAnLCd1dGRvdCc6J1xcXFx1MjJGMCcsJ3V0aWxkZSc6J1xcXFx1MDE2OScsJ1V0aWxkZSc6J1xcXFx1MDE2OCcsJ3V0cmknOidcXFxcdTI1QjUnLCd1dHJpZic6J1xcXFx1MjVCNCcsJ3V1YXJyJzonXFxcXHUyMUM4JywndXVtbCc6J1xcXFx4RkMnLCdVdW1sJzonXFxcXHhEQycsJ3V3YW5nbGUnOidcXFxcdTI5QTcnLCd2YW5ncnQnOidcXFxcdTI5OUMnLCd2YXJlcHNpbG9uJzonXFxcXHUwM0Y1JywndmFya2FwcGEnOidcXFxcdTAzRjAnLCd2YXJub3RoaW5nJzonXFxcXHUyMjA1JywndmFycGhpJzonXFxcXHUwM0Q1JywndmFycGknOidcXFxcdTAzRDYnLCd2YXJwcm9wdG8nOidcXFxcdTIyMUQnLCd2YXJyJzonXFxcXHUyMTk1JywndkFycic6J1xcXFx1MjFENScsJ3ZhcnJobyc6J1xcXFx1MDNGMScsJ3ZhcnNpZ21hJzonXFxcXHUwM0MyJywndmFyc3Vic2V0bmVxJzonXFxcXHUyMjhBXFxcXHVGRTAwJywndmFyc3Vic2V0bmVxcSc6J1xcXFx1MkFDQlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcSc6J1xcXFx1MjI4QlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcXEnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCd2YXJ0aGV0YSc6J1xcXFx1MDNEMScsJ3ZhcnRyaWFuZ2xlbGVmdCc6J1xcXFx1MjJCMicsJ3ZhcnRyaWFuZ2xlcmlnaHQnOidcXFxcdTIyQjMnLCd2QmFyJzonXFxcXHUyQUU4JywnVmJhcic6J1xcXFx1MkFFQicsJ3ZCYXJ2JzonXFxcXHUyQUU5JywndmN5JzonXFxcXHUwNDMyJywnVmN5JzonXFxcXHUwNDEyJywndmRhc2gnOidcXFxcdTIyQTInLCd2RGFzaCc6J1xcXFx1MjJBOCcsJ1ZkYXNoJzonXFxcXHUyMkE5JywnVkRhc2gnOidcXFxcdTIyQUInLCdWZGFzaGwnOidcXFxcdTJBRTYnLCd2ZWUnOidcXFxcdTIyMjgnLCdWZWUnOidcXFxcdTIyQzEnLCd2ZWViYXInOidcXFxcdTIyQkInLCd2ZWVlcSc6J1xcXFx1MjI1QScsJ3ZlbGxpcCc6J1xcXFx1MjJFRScsJ3ZlcmJhcic6J3wnLCdWZXJiYXInOidcXFxcdTIwMTYnLCd2ZXJ0JzonfCcsJ1ZlcnQnOidcXFxcdTIwMTYnLCdWZXJ0aWNhbEJhcic6J1xcXFx1MjIyMycsJ1ZlcnRpY2FsTGluZSc6J3wnLCdWZXJ0aWNhbFNlcGFyYXRvcic6J1xcXFx1Mjc1OCcsJ1ZlcnRpY2FsVGlsZGUnOidcXFxcdTIyNDAnLCdWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBBJywndmZyJzonXFxcXHVEODM1XFxcXHVERDMzJywnVmZyJzonXFxcXHVEODM1XFxcXHVERDE5Jywndmx0cmknOidcXFxcdTIyQjInLCd2bnN1Yic6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ3Zuc3VwJzonXFxcXHUyMjgzXFxcXHUyMEQyJywndm9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NycsJ1ZvcGYnOidcXFxcdUQ4MzVcXFxcdURENEQnLCd2cHJvcCc6J1xcXFx1MjIxRCcsJ3ZydHJpJzonXFxcXHUyMkIzJywndnNjcic6J1xcXFx1RDgzNVxcXFx1RENDQicsJ1ZzY3InOidcXFxcdUQ4MzVcXFxcdURDQjEnLCd2c3VibmUnOidcXFxcdTIyOEFcXFxcdUZFMDAnLCd2c3VibkUnOidcXFxcdTJBQ0JcXFxcdUZFMDAnLCd2c3VwbmUnOidcXFxcdTIyOEJcXFxcdUZFMDAnLCd2c3VwbkUnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCdWdmRhc2gnOidcXFxcdTIyQUEnLCd2emlnemFnJzonXFxcXHUyOTlBJywnd2NpcmMnOidcXFxcdTAxNzUnLCdXY2lyYyc6J1xcXFx1MDE3NCcsJ3dlZGJhcic6J1xcXFx1MkE1RicsJ3dlZGdlJzonXFxcXHUyMjI3JywnV2VkZ2UnOidcXFxcdTIyQzAnLCd3ZWRnZXEnOidcXFxcdTIyNTknLCd3ZWllcnAnOidcXFxcdTIxMTgnLCd3ZnInOidcXFxcdUQ4MzVcXFxcdUREMzQnLCdXZnInOidcXFxcdUQ4MzVcXFxcdUREMUEnLCd3b3BmJzonXFxcXHVEODM1XFxcXHVERDY4JywnV29wZic6J1xcXFx1RDgzNVxcXFx1REQ0RScsJ3dwJzonXFxcXHUyMTE4Jywnd3InOidcXFxcdTIyNDAnLCd3cmVhdGgnOidcXFxcdTIyNDAnLCd3c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NDJywnV3Njcic6J1xcXFx1RDgzNVxcXFx1RENCMicsJ3hjYXAnOidcXFxcdTIyQzInLCd4Y2lyYyc6J1xcXFx1MjVFRicsJ3hjdXAnOidcXFxcdTIyQzMnLCd4ZHRyaSc6J1xcXFx1MjVCRCcsJ3hmcic6J1xcXFx1RDgzNVxcXFx1REQzNScsJ1hmcic6J1xcXFx1RDgzNVxcXFx1REQxQicsJ3hoYXJyJzonXFxcXHUyN0Y3JywneGhBcnInOidcXFxcdTI3RkEnLCd4aSc6J1xcXFx1MDNCRScsJ1hpJzonXFxcXHUwMzlFJywneGxhcnInOidcXFxcdTI3RjUnLCd4bEFycic6J1xcXFx1MjdGOCcsJ3htYXAnOidcXFxcdTI3RkMnLCd4bmlzJzonXFxcXHUyMkZCJywneG9kb3QnOidcXFxcdTJBMDAnLCd4b3BmJzonXFxcXHVEODM1XFxcXHVERDY5JywnWG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0RicsJ3hvcGx1cyc6J1xcXFx1MkEwMScsJ3hvdGltZSc6J1xcXFx1MkEwMicsJ3hyYXJyJzonXFxcXHUyN0Y2JywneHJBcnInOidcXFxcdTI3RjknLCd4c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NEJywnWHNjcic6J1xcXFx1RDgzNVxcXFx1RENCMycsJ3hzcWN1cCc6J1xcXFx1MkEwNicsJ3h1cGx1cyc6J1xcXFx1MkEwNCcsJ3h1dHJpJzonXFxcXHUyNUIzJywneHZlZSc6J1xcXFx1MjJDMScsJ3h3ZWRnZSc6J1xcXFx1MjJDMCcsJ3lhY3V0ZSc6J1xcXFx4RkQnLCdZYWN1dGUnOidcXFxceEREJywneWFjeSc6J1xcXFx1MDQ0RicsJ1lBY3knOidcXFxcdTA0MkYnLCd5Y2lyYyc6J1xcXFx1MDE3NycsJ1ljaXJjJzonXFxcXHUwMTc2JywneWN5JzonXFxcXHUwNDRCJywnWWN5JzonXFxcXHUwNDJCJywneWVuJzonXFxcXHhBNScsJ3lmcic6J1xcXFx1RDgzNVxcXFx1REQzNicsJ1lmcic6J1xcXFx1RDgzNVxcXFx1REQxQycsJ3lpY3knOidcXFxcdTA0NTcnLCdZSWN5JzonXFxcXHUwNDA3JywneW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QScsJ1lvcGYnOidcXFxcdUQ4MzVcXFxcdURENTAnLCd5c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NFJywnWXNjcic6J1xcXFx1RDgzNVxcXFx1RENCNCcsJ3l1Y3knOidcXFxcdTA0NEUnLCdZVWN5JzonXFxcXHUwNDJFJywneXVtbCc6J1xcXFx4RkYnLCdZdW1sJzonXFxcXHUwMTc4JywnemFjdXRlJzonXFxcXHUwMTdBJywnWmFjdXRlJzonXFxcXHUwMTc5JywnemNhcm9uJzonXFxcXHUwMTdFJywnWmNhcm9uJzonXFxcXHUwMTdEJywnemN5JzonXFxcXHUwNDM3JywnWmN5JzonXFxcXHUwNDE3JywnemRvdCc6J1xcXFx1MDE3QycsJ1pkb3QnOidcXFxcdTAxN0InLCd6ZWV0cmYnOidcXFxcdTIxMjgnLCdaZXJvV2lkdGhTcGFjZSc6J1xcXFx1MjAwQicsJ3pldGEnOidcXFxcdTAzQjYnLCdaZXRhJzonXFxcXHUwMzk2JywnemZyJzonXFxcXHVEODM1XFxcXHVERDM3JywnWmZyJzonXFxcXHUyMTI4JywnemhjeSc6J1xcXFx1MDQzNicsJ1pIY3knOidcXFxcdTA0MTYnLCd6aWdyYXJyJzonXFxcXHUyMUREJywnem9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QicsJ1pvcGYnOidcXFxcdTIxMjQnLCd6c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NGJywnWnNjcic6J1xcXFx1RDgzNVxcXFx1RENCNScsJ3p3aic6J1xcXFx1MjAwRCcsJ3p3bmonOidcXFxcdTIwMEMnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTGVnYWN5ID0geydhYWN1dGUnOidcXFxceEUxJywnQWFjdXRlJzonXFxcXHhDMScsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FncmF2ZSc6J1xcXFx4RTAnLCdBZ3JhdmUnOidcXFxceEMwJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhcmluZyc6J1xcXFx4RTUnLCdBcmluZyc6J1xcXFx4QzUnLCdhdGlsZGUnOidcXFxceEUzJywnQXRpbGRlJzonXFxcXHhDMycsJ2F1bWwnOidcXFxceEU0JywnQXVtbCc6J1xcXFx4QzQnLCdicnZiYXInOidcXFxceEE2JywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjZWRpbCc6J1xcXFx4QjgnLCdjZW50JzonXFxcXHhBMicsJ2NvcHknOidcXFxceEE5JywnQ09QWSc6J1xcXFx4QTknLCdjdXJyZW4nOidcXFxceEE0JywnZGVnJzonXFxcXHhCMCcsJ2RpdmlkZSc6J1xcXFx4RjcnLCdlYWN1dGUnOidcXFxceEU5JywnRWFjdXRlJzonXFxcXHhDOScsJ2VjaXJjJzonXFxcXHhFQScsJ0VjaXJjJzonXFxcXHhDQScsJ2VncmF2ZSc6J1xcXFx4RTgnLCdFZ3JhdmUnOidcXFxceEM4JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZnJhYzEyJzonXFxcXHhCRCcsJ2ZyYWMxNCc6J1xcXFx4QkMnLCdmcmFjMzQnOidcXFxceEJFJywnZ3QnOic+JywnR1QnOic+JywnaWFjdXRlJzonXFxcXHhFRCcsJ0lhY3V0ZSc6J1xcXFx4Q0QnLCdpY2lyYyc6J1xcXFx4RUUnLCdJY2lyYyc6J1xcXFx4Q0UnLCdpZXhjbCc6J1xcXFx4QTEnLCdpZ3JhdmUnOidcXFxceEVDJywnSWdyYXZlJzonXFxcXHhDQycsJ2lxdWVzdCc6J1xcXFx4QkYnLCdpdW1sJzonXFxcXHhFRicsJ0l1bWwnOidcXFxceENGJywnbGFxdW8nOidcXFxceEFCJywnbHQnOic8JywnTFQnOic8JywnbWFjcic6J1xcXFx4QUYnLCdtaWNybyc6J1xcXFx4QjUnLCdtaWRkb3QnOidcXFxceEI3JywnbmJzcCc6J1xcXFx4QTAnLCdub3QnOidcXFxceEFDJywnbnRpbGRlJzonXFxcXHhGMScsJ050aWxkZSc6J1xcXFx4RDEnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29jaXJjJzonXFxcXHhGNCcsJ09jaXJjJzonXFxcXHhENCcsJ29ncmF2ZSc6J1xcXFx4RjInLCdPZ3JhdmUnOidcXFxceEQyJywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3RpbGRlJzonXFxcXHhGNScsJ090aWxkZSc6J1xcXFx4RDUnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2JywncGFyYSc6J1xcXFx4QjYnLCdwbHVzbW4nOidcXFxceEIxJywncG91bmQnOidcXFxceEEzJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JhcXVvJzonXFxcXHhCQicsJ3JlZyc6J1xcXFx4QUUnLCdSRUcnOidcXFxceEFFJywnc2VjdCc6J1xcXFx4QTcnLCdzaHknOidcXFxceEFEJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3psaWcnOidcXFxceERGJywndGhvcm4nOidcXFxceEZFJywnVEhPUk4nOidcXFxceERFJywndGltZXMnOidcXFxceEQ3JywndWFjdXRlJzonXFxcXHhGQScsJ1VhY3V0ZSc6J1xcXFx4REEnLCd1Y2lyYyc6J1xcXFx4RkInLCdVY2lyYyc6J1xcXFx4REInLCd1Z3JhdmUnOidcXFxceEY5JywnVWdyYXZlJzonXFxcXHhEOScsJ3VtbCc6J1xcXFx4QTgnLCd1dW1sJzonXFxcXHhGQycsJ1V1bWwnOidcXFxceERDJywneWFjdXRlJzonXFxcXHhGRCcsJ1lhY3V0ZSc6J1xcXFx4REQnLCd5ZW4nOidcXFxceEE1JywneXVtbCc6J1xcXFx4RkYnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTnVtZXJpYyA9IHsnMCc6J1xcXFx1RkZGRCcsJzEyOCc6J1xcXFx1MjBBQycsJzEzMCc6J1xcXFx1MjAxQScsJzEzMSc6J1xcXFx1MDE5MicsJzEzMic6J1xcXFx1MjAxRScsJzEzMyc6J1xcXFx1MjAyNicsJzEzNCc6J1xcXFx1MjAyMCcsJzEzNSc6J1xcXFx1MjAyMScsJzEzNic6J1xcXFx1MDJDNicsJzEzNyc6J1xcXFx1MjAzMCcsJzEzOCc6J1xcXFx1MDE2MCcsJzEzOSc6J1xcXFx1MjAzOScsJzE0MCc6J1xcXFx1MDE1MicsJzE0Mic6J1xcXFx1MDE3RCcsJzE0NSc6J1xcXFx1MjAxOCcsJzE0Nic6J1xcXFx1MjAxOScsJzE0Nyc6J1xcXFx1MjAxQycsJzE0OCc6J1xcXFx1MjAxRCcsJzE0OSc6J1xcXFx1MjAyMicsJzE1MCc6J1xcXFx1MjAxMycsJzE1MSc6J1xcXFx1MjAxNCcsJzE1Mic6J1xcXFx1MDJEQycsJzE1Myc6J1xcXFx1MjEyMicsJzE1NCc6J1xcXFx1MDE2MScsJzE1NSc6J1xcXFx1MjAzQScsJzE1Nic6J1xcXFx1MDE1MycsJzE1OCc6J1xcXFx1MDE3RScsJzE1OSc6J1xcXFx1MDE3OCd9O1xcblxcdHZhciBpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cyA9IFsxLDIsMyw0LDUsNiw3LDgsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksNjQ5NzYsNjQ5NzcsNjQ5NzgsNjQ5NzksNjQ5ODAsNjQ5ODEsNjQ5ODIsNjQ5ODMsNjQ5ODQsNjQ5ODUsNjQ5ODYsNjQ5ODcsNjQ5ODgsNjQ5ODksNjQ5OTAsNjQ5OTEsNjQ5OTIsNjQ5OTMsNjQ5OTQsNjQ5OTUsNjQ5OTYsNjQ5OTcsNjQ5OTgsNjQ5OTksNjUwMDAsNjUwMDEsNjUwMDIsNjUwMDMsNjUwMDQsNjUwMDUsNjUwMDYsNjUwMDcsNjU1MzQsNjU1MzUsMTMxMDcwLDEzMTA3MSwxOTY2MDYsMTk2NjA3LDI2MjE0MiwyNjIxNDMsMzI3Njc4LDMyNzY3OSwzOTMyMTQsMzkzMjE1LDQ1ODc1MCw0NTg3NTEsNTI0Mjg2LDUyNDI4Nyw1ODk4MjIsNTg5ODIzLDY1NTM1OCw2NTUzNTksNzIwODk0LDcyMDg5NSw3ODY0MzAsNzg2NDMxLDg1MTk2Niw4NTE5NjcsOTE3NTAyLDkxNzUwMyw5ODMwMzgsOTgzMDM5LDEwNDg1NzQsMTA0ODU3NSwxMTE0MTEwLDExMTQxMTFdO1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xcblxcblxcdHZhciBvYmplY3QgPSB7fTtcXG5cXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XFxuXFx0dmFyIGhhcyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XFxuXFx0XFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eU5hbWUpO1xcblxcdH07XFxuXFxuXFx0dmFyIGNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XFxuXFx0XFx0dmFyIGluZGV4ID0gLTE7XFxuXFx0XFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcblxcdFxcdFxcdGlmIChhcnJheVtpbmRleF0gPT0gdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9O1xcblxcblxcdHZhciBtZXJnZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XFxuXFx0XFx0aWYgKCFvcHRpb25zKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGRlZmF1bHRzO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgcmVzdWx0ID0ge307XFxuXFx0XFx0dmFyIGtleTtcXG5cXHRcXHRmb3IgKGtleSBpbiBkZWZhdWx0cykge1xcblxcdFxcdFxcdC8vIEEgYGhhc093blByb3BlcnR5YCBjaGVjayBpcyBub3QgbmVlZGVkIGhlcmUsIHNpbmNlIG9ubHkgcmVjb2duaXplZFxcblxcdFxcdFxcdC8vIG9wdGlvbiBuYW1lcyBhcmUgdXNlZCBhbnl3YXkuIEFueSBvdGhlcnMgYXJlIGlnbm9yZWQuXFxuXFx0XFx0XFx0cmVzdWx0W2tleV0gPSBoYXMob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXG5cXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGB1Y3MyZW5jb2RlYDsgc2VlIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZS5cXG5cXHR2YXIgY29kZVBvaW50VG9TeW1ib2wgPSBmdW5jdGlvbihjb2RlUG9pbnQsIHN0cmljdCkge1xcblxcdFxcdHZhciBvdXRwdXQgPSAnJztcXG5cXHRcXHRpZiAoKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcXG5cXHRcXHRcXHQvLyBTZWUgaXNzdWUgIzQ6XFxuXFx0XFx0XFx0Ly8g4oCcT3RoZXJ3aXNlLCBpZiB0aGUgbnVtYmVyIGlzIGluIHRoZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGIG9yIGlzXFxuXFx0XFx0XFx0Ly8gZ3JlYXRlciB0aGFuIDB4MTBGRkZGLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvci4gUmV0dXJuIGEgVStGRkZEXFxuXFx0XFx0XFx0Ly8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLuKAnVxcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIG91dHNpZGUgdGhlIHBlcm1pc3NpYmxlIFVuaWNvZGUgcmFuZ2UnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuICdcXFxcdUZGRkQnO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoaGFzKGRlY29kZU1hcE51bWVyaWMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBOdW1lcmljW2NvZGVQb2ludF07XFxuXFx0XFx0fVxcblxcdFxcdGlmIChzdHJpY3QgJiYgY29udGFpbnMoaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcblxcdFxcdFxcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xcblxcdFxcdFxcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcXG5cXHRcXHRcXHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcXG5cXHRcXHR9XFxuXFx0XFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xcblxcdFxcdHJldHVybiBvdXRwdXQ7XFxuXFx0fTtcXG5cXG5cXHR2YXIgaGV4RXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XFxuXFx0XFx0cmV0dXJuICcmI3gnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIGRlY0VzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xcblxcdFxcdHJldHVybiAnJiMnICsgY29kZVBvaW50ICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIHBhcnNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XFxuXFx0XFx0dGhyb3cgRXJyb3IoJ1BhcnNlIGVycm9yOiAnICsgbWVzc2FnZSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XFxuXFx0XFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGVuY29kZS5vcHRpb25zKTtcXG5cXHRcXHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XFxuXFx0XFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRSYXdDb2RlUG9pbnQudGVzdChzdHJpbmcpKSB7XFxuXFx0XFx0XFx0cGFyc2VFcnJvcignZm9yYmlkZGVuIGNvZGUgcG9pbnQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmFyIGVuY29kZUV2ZXJ5dGhpbmcgPSBvcHRpb25zLmVuY29kZUV2ZXJ5dGhpbmc7XFxuXFx0XFx0dmFyIHVzZU5hbWVkUmVmZXJlbmNlcyA9IG9wdGlvbnMudXNlTmFtZWRSZWZlcmVuY2VzO1xcblxcdFxcdHZhciBhbGxvd1Vuc2FmZVN5bWJvbHMgPSBvcHRpb25zLmFsbG93VW5zYWZlU3ltYm9scztcXG5cXHRcXHR2YXIgZXNjYXBlQ29kZVBvaW50ID0gb3B0aW9ucy5kZWNpbWFsID8gZGVjRXNjYXBlIDogaGV4RXNjYXBlO1xcblxcblxcdFxcdHZhciBlc2NhcGVCbXBTeW1ib2wgPSBmdW5jdGlvbihzeW1ib2wpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KHN5bWJvbC5jaGFyQ29kZUF0KDApKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChlbmNvZGVFdmVyeXRoaW5nKSB7XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIEFTQ0lJIHN5bWJvbHMuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhBc2NpaVdoaXRlbGlzdCwgZnVuY3Rpb24oc3ltYm9sKSB7XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG5hbWVkIHJlZmVyZW5jZXMgaWYgcmVxdWVzdGVkICYgcG9zc2libGUuXFxuXFx0XFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcyAmJiBoYXMoZW5jb2RlTWFwLCBzeW1ib2wpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzeW1ib2xdICsgJzsnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXNjYXBlQm1wU3ltYm9sKHN5bWJvbCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBhIGZldyBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcXG5cXHRcXHRcXHQvLyBpcyB3aXRoaW4gdGhlIEFTQ0lJIHJhbmdlLlxcblxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmd0O1xcXFx1MjBEMi9nLCAnJm52Z3Q7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmx0O1xcXFx1MjBEMi9nLCAnJm52bHQ7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJiN4NjY7JiN4NkE7L2csICcmZmpsaWc7Jyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scy5cXG5cXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIE5vdGU6IGFueSByZW1haW5pbmcgbm9uLUFTQ0lJIHN5bWJvbHMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgYGlmYC5cXG5cXHRcXHR9IGVsc2UgaWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdC8vIEFwcGx5IG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdC8vIEVuY29kZSBgPD5cXFwiJyZgIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JzsgLy8gbm8gbmVlZCB0byBjaGVjayBgaGFzKClgIGhlcmVcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmUgaXNcXG5cXHRcXHRcXHQvLyBgPD5cXFwiJyZgLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZ1xcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mZ3Q7XFxcXHUyMEQyL2csICcmbnZndDsnKVxcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mbHQ7XFxcXHUyMEQyL2csICcmbnZsdDsnKTtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxcblxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JztcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYDw+XFxcIicmYCB1c2luZyBoZXhhZGVjaW1hbCBlc2NhcGVzLCBub3cgdGhhdCB0aGV54oCZcmUgbm90IGhhbmRsZWRcXG5cXHRcXHRcXHQvLyB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZXNjYXBlQm1wU3ltYm9sKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHN0cmluZ1xcblxcdFxcdFxcdC8vIEVuY29kZSBhc3RyYWwgc3ltYm9scy5cXG5cXHRcXHRcXHQucmVwbGFjZShyZWdleEFzdHJhbFN5bWJvbHMsIGZ1bmN0aW9uKCQwKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXFxuXFx0XFx0XFx0XFx0dmFyIGhpZ2ggPSAkMC5jaGFyQ29kZUF0KDApO1xcblxcdFxcdFxcdFxcdHZhciBsb3cgPSAkMC5jaGFyQ29kZUF0KDEpO1xcblxcdFxcdFxcdFxcdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChjb2RlUG9pbnQpO1xcblxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGFueSByZW1haW5pbmcgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IHByaW50YWJsZSBBU0NJSSBzeW1ib2xzXFxuXFx0XFx0XFx0Ly8gdXNpbmcgYSBoZXhhZGVjaW1hbCBlc2NhcGUuXFxuXFx0XFx0XFx0LnJlcGxhY2UocmVnZXhCbXBXaGl0ZWxpc3QsIGVzY2FwZUJtcFN5bWJvbCk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRlbmNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnYWxsb3dVbnNhZmVTeW1ib2xzJzogZmFsc2UsXFxuXFx0XFx0J2VuY29kZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcXG5cXHRcXHQnc3RyaWN0JzogZmFsc2UsXFxuXFx0XFx0J3VzZU5hbWVkUmVmZXJlbmNlcyc6IGZhbHNlLFxcblxcdFxcdCdkZWNpbWFsJyA6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVjb2RlID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xcblxcdFxcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWNvZGUub3B0aW9ucyk7XFxuXFx0XFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xcblxcdFxcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkRW50aXR5LnRlc3QoaHRtbCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdtYWxmb3JtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gaHRtbC5yZXBsYWNlKHJlZ2V4RGVjb2RlLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcpIHtcXG5cXHRcXHRcXHR2YXIgY29kZVBvaW50O1xcblxcdFxcdFxcdHZhciBzZW1pY29sb247XFxuXFx0XFx0XFx0dmFyIGRlY0RpZ2l0cztcXG5cXHRcXHRcXHR2YXIgaGV4RGlnaXRzO1xcblxcdFxcdFxcdHZhciByZWZlcmVuY2U7XFxuXFx0XFx0XFx0dmFyIG5leHQ7XFxuXFx0XFx0XFx0aWYgKCQxKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVjb2RlIGRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiMxMTk1NTg7YC5cXG5cXHRcXHRcXHRcXHRkZWNEaWdpdHMgPSAkMTtcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkMjtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChkZWNEaWdpdHMsIDEwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDMpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgaGV4YWRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiN4MUQzMDY7YC5cXG5cXHRcXHRcXHRcXHRoZXhEaWdpdHMgPSAkMztcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkNDtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDUpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aCB0cmFpbGluZyBgO2AsIGUuZy4gYCZjb3B5O2AuXFxuXFx0XFx0XFx0XFx0cmVmZXJlbmNlID0gJDU7XFxuXFx0XFx0XFx0XFx0aWYgKGhhcyhkZWNvZGVNYXAsIHJlZmVyZW5jZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGVjb2RlTWFwW3JlZmVyZW5jZV07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBBbWJpZ3VvdXMgYW1wZXJzYW5kLiBodHRwczovL210aHMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gSWYgd2XigJlyZSBzdGlsbCBoZXJlLCBpdOKAmXMgYSBsZWdhY3kgcmVmZXJlbmNlIGZvciBzdXJlLiBObyBuZWVkIGZvciBhblxcblxcdFxcdFxcdC8vIGV4dHJhIGBpZmAgY2hlY2suXFxuXFx0XFx0XFx0Ly8gRGVjb2RlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIHdpdGhvdXQgdHJhaWxpbmcgYDtgLCBlLmcuIGAmYW1wYFxcblxcdFxcdFxcdC8vIFRoaXMgaXMgb25seSBhIHBhcnNlIGVycm9yIGlmIGl0IGdldHMgY29udmVydGVkIHRvIGAmYCwgb3IgaWYgaXQgaXNcXG5cXHRcXHRcXHQvLyBmb2xsb3dlZCBieSBgPWAgaW4gYW4gYXR0cmlidXRlIGNvbnRleHQuXFxuXFx0XFx0XFx0cmVmZXJlbmNlID0gJDY7XFxuXFx0XFx0XFx0bmV4dCA9ICQ3O1xcblxcdFxcdFxcdGlmIChuZXh0ICYmIG9wdGlvbnMuaXNBdHRyaWJ1dGVWYWx1ZSkge1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgbmV4dCA9PSAnPScpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdgJmAgZGlkIG5vdCBzdGFydCBhIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXBMZWdhY3ksIHJlZmVyZW5jZSlgLlxcblxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBMZWdhY3lbcmVmZXJlbmNlXSArIChuZXh0IHx8ICcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRkZWNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnaXNBdHRyaWJ1dGVWYWx1ZSc6IGZhbHNlLFxcblxcdFxcdCdzdHJpY3QnOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0dmFyIGVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oJDApIHtcXG5cXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZXNjYXBlTWFwLCAkMClgIGhlcmUuXFxuXFx0XFx0XFx0cmV0dXJuIGVzY2FwZU1hcFskMF07XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgaGUgPSB7XFxuXFx0XFx0J3ZlcnNpb24nOiAnMS4xLjEnLFxcblxcdFxcdCdlbmNvZGUnOiBlbmNvZGUsXFxuXFx0XFx0J2RlY29kZSc6IGRlY29kZSxcXG5cXHRcXHQnZXNjYXBlJzogZXNjYXBlLFxcblxcdFxcdCd1bmVzY2FwZSc6IGRlY29kZVxcblxcdH07XFxuXFxuXFx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXFxuXFx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxcblxcdGlmIChcXG5cXHRcXHRmYWxzZVxcblxcdCkge1xcblxcdFxcdGRlZmluZShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaGU7XFxuXFx0XFx0fSk7XFxuXFx0fVxcdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xcblxcdFxcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcXG5cXHRcXHRcXHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBoZTtcXG5cXHRcXHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxcblxcdFxcdFxcdGZvciAodmFyIGtleSBpbiBoZSkge1xcblxcdFxcdFxcdFxcdGhhcyhoZSwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGhlW2tleV0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxcblxcdFxcdHJvb3QuaGUgPSBoZTtcXG5cXHR9XFxuXFxufSh0aGlzKSk7XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XFxuICB2YXIgZSwgbVxcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXFxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcXG4gIHZhciBuQml0cyA9IC03XFxuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXFxuXFxuICBpICs9IGRcXG5cXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXFxuICBzID4+PSAoLW5CaXRzKVxcbiAgbkJpdHMgKz0gZUxlblxcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cXG5cXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXFxuICBlID4+PSAoLW5CaXRzKVxcbiAgbkJpdHMgKz0gbUxlblxcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cXG5cXG4gIGlmIChlID09PSAwKSB7XFxuICAgIGUgPSAxIC0gZUJpYXNcXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcXG4gIH0gZWxzZSB7XFxuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcXG4gICAgZSA9IGUgLSBlQmlhc1xcbiAgfVxcbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcXG59XFxuXFxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG0sIGNcXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXFxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXFxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXFxuXFxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxcblxcbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcXG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXFxuICAgIGUgPSBlTWF4XFxuICB9IGVsc2Uge1xcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xcbiAgICAgIGUtLVxcbiAgICAgIGMgKj0gMlxcbiAgICB9XFxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxcbiAgICB9XFxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xcbiAgICAgIGUrK1xcbiAgICAgIGMgLz0gMlxcbiAgICB9XFxuXFxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xcbiAgICAgIG0gPSAwXFxuICAgICAgZSA9IGVNYXhcXG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICAgIGUgPSBlICsgZUJpYXNcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gMFxcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxcblxcbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxcbiAgZUxlbiArPSBtTGVuXFxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XFxuXFxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcXG59XFxuXFxufSx7fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XFxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXFxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XFxuICAgICAgY29uc3RydWN0b3I6IHtcXG4gICAgICAgIHZhbHVlOiBjdG9yLFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cXG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXFxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxcbiAgfVxcbn1cXG5cXG59LHt9XSw2NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyohXFxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcblxcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3NpbmdcXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxcbn1cXG5cXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxcbn1cXG5cXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxcbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcXG59XFxuXFxufSx7fV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG59LHt9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cXG47KGZ1bmN0aW9uICgpIHtcXG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cXG4gIHZhciBpc0xvYWRlciA9IGZhbHNlO1xcblxcbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcXG4gICAgXFxcImZ1bmN0aW9uXFxcIjogdHJ1ZSxcXG4gICAgXFxcIm9iamVjdFxcXCI6IHRydWVcXG4gIH07XFxuXFxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXFxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xcblxcbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXFxuICAvLyBpbnN0ZWFkLlxcbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcXFwib2JqZWN0XFxcIiAmJiBnbG9iYWw7XFxuXFxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcXFwiZ2xvYmFsXFxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcXFwid2luZG93XFxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcXFwic2VsZlxcXCJdID09PSBmcmVlR2xvYmFsKSkge1xcbiAgICByb290ID0gZnJlZUdsb2JhbDtcXG4gIH1cXG5cXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXFxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxcbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcXG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXFxcIk9iamVjdFxcXCJdKCkpO1xcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcXFwiT2JqZWN0XFxcIl0oKSk7XFxuXFxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxcbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcXFwiTnVtYmVyXFxcIl0gfHwgcm9vdFtcXFwiTnVtYmVyXFxcIl0sXFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1xcXCJTdHJpbmdcXFwiXSB8fCByb290W1xcXCJTdHJpbmdcXFwiXSxcXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXFxcIk9iamVjdFxcXCJdIHx8IHJvb3RbXFxcIk9iamVjdFxcXCJdLFxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXFxcIkRhdGVcXFwiXSB8fCByb290W1xcXCJEYXRlXFxcIl0sXFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXFxcIlN5bnRheEVycm9yXFxcIl0gfHwgcm9vdFtcXFwiU3ludGF4RXJyb3JcXFwiXSxcXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXFxcIlR5cGVFcnJvclxcXCJdIHx8IHJvb3RbXFxcIlR5cGVFcnJvclxcXCJdLFxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXFxcIk1hdGhcXFwiXSB8fCByb290W1xcXCJNYXRoXFxcIl0sXFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcXFwiSlNPTlxcXCJdIHx8IHJvb3RbXFxcIkpTT05cXFwiXTtcXG5cXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXFxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcXFwib2JqZWN0XFxcIiAmJiBuYXRpdmVKU09OKSB7XFxuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcXG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcXG4gICAgfVxcblxcbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxcbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xcblxcbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXFxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xcbiAgICB0cnkge1xcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXFxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XFxuXFxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcXG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxcbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcXG4gICAgICB9XFxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xcbiAgICAgIGlmIChuYW1lID09IFxcXCJidWctc3RyaW5nLWNoYXItaW5kZXhcXFwiKSB7XFxuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXFxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXFxcImFcXFwiWzBdICE9IFxcXCJhXFxcIjtcXG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXFxcImpzb25cXFwiKSB7XFxuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFxcXCJqc29uLXN0cmluZ2lmeVxcXCIpICYmIGhhcyhcXFwianNvbi1wYXJzZVxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1xcXCJhXFxcIjpbMSx0cnVlLGZhbHNlLG51bGwsXFxcIlxcXFxcXFxcdTAwMDBcXFxcXFxcXGJcXFxcXFxcXG5cXFxcXFxcXGZcXFxcXFxcXHJcXFxcXFxcXHRcXFwiXX0nO1xcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxcbiAgICAgICAgaWYgKG5hbWUgPT0gXFxcImpzb24tc3RyaW5naWZ5XFxcIikge1xcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBpc0V4dGVuZGVkO1xcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XFxuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gMTtcXG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxcbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcXFwiMFxcXCIgJiZcXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXFxcIjBcXFwiICYmXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcXFwiXFxcIicgJiZcXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXFxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFxcXCJ1bmRlZmluZWRcXFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXFxuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFxcXCIxXFxcIiAmJlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXFxcIlsxXVxcXCIgJiZcXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXFxcIltdXFxcImAgaW5zdGVhZCBvZlxcbiAgICAgICAgICAgICAgICAvLyBgXFxcIltudWxsXVxcXCJgLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXFxcIltudWxsXVxcXCIgJiZcXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFxcXCJudWxsXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XFxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFxcXCJbMSx0cnVlLF0sXFxcIi4gRkYgMy4xYjNcXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFxcXCJbbnVsbCxudWxsLG51bGxdXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcXFxiYCA9PiBgXFxcXHUwMDA4YCkuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFxcXCJhXFxcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXFxcIlxcXFx4MDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XFxcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFxcXCIxXFxcIiAmJlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcXFwiW1xcXFxuIDEsXFxcXG4gMlxcXFxuXVxcXCIgJiZcXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcXFwiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXFxcIicgJiZcXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXFxcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlxcXCInICYmXFxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcXFwiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXFxcIicgJiZcXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXFxcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlxcXCInO1xcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXFxuICAgICAgICBpZiAobmFtZSA9PSBcXFwianNvbi1wYXJzZVxcXCIpIHtcXG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xcbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcXFwiMFxcXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXFxcImFcXFwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcXFwiYVxcXCJdWzBdID09PSAxO1xcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcXG4gICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1xcXCJcXFxcdFxcXCInKTtcXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XFxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXFxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXFxcIjAxXFxcIikgIT09IDE7XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFxcXCIxLlxcXCIpICE9PSAxO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFoYXMoXFxcImpzb25cXFwiKSkge1xcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXFxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiLFxcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcXFwiW29iamVjdCBEYXRlXVxcXCIsXFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXFxcIltvYmplY3QgTnVtYmVyXVxcXCIsXFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXFxcIltvYmplY3QgU3RyaW5nXVxcXCIsXFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcXFwiW29iamVjdCBBcnJheV1cXFwiLFxcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcXFwiW29iamVjdCBCb29sZWFuXVxcXCI7XFxuXFxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxcbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcXFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XFxcIik7XFxuXFxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXFxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XFxuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXFxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcXG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXFxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XFxuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXFxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXFxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcXG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxcbiAgICAgICAgICAgIFxcXCJ0b1N0cmluZ1xcXCI6IDFcXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcXG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXFxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcXG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XFxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXFxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XFxuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcXG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcXG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XFxuXFxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXFxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xcblxcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXFxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcXG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxcbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xcbiAgICAgICAgICAgIHNpemUrKztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xcblxcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxcbiAgICAgICAgaWYgKCFzaXplKSB7XFxuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cXG4gICAgICAgICAgbWVtYmVycyA9IFtcXFwidmFsdWVPZlxcXCIsIFxcXCJ0b1N0cmluZ1xcXCIsIFxcXCJ0b0xvY2FsZVN0cmluZ1xcXCIsIFxcXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVxcXCIsIFxcXCJpc1Byb3RvdHlwZU9mXFxcIiwgXFxcImhhc093blByb3BlcnR5XFxcIiwgXFxcImNvbnN0cnVjdG9yXFxcIl07XFxuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcXG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXFxcInByb3RvdHlwZVxcXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxcbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XFxuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXFxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XFxuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcXG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXFxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxcbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcXFwicHJvdG90eXBlXFxcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxcbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcXG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcXFwicHJvdG90eXBlXFxcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcXFwiY29uc3RydWN0b3JcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xcbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcXFwiY29uc3RydWN0b3JcXFwiKSkpIHtcXG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcXG4gICAgICB9O1xcblxcbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxcbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXFxuICAgICAgaWYgKCFoYXMoXFxcImpzb24tc3RyaW5naWZ5XFxcIikpIHtcXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXFxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcXG4gICAgICAgICAgOTI6IFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIixcXG4gICAgICAgICAgMzQ6ICdcXFxcXFxcXFxcXCInLFxcbiAgICAgICAgICA4OiBcXFwiXFxcXFxcXFxiXFxcIixcXG4gICAgICAgICAgMTI6IFxcXCJcXFxcXFxcXGZcXFwiLFxcbiAgICAgICAgICAxMDogXFxcIlxcXFxcXFxcblxcXCIsXFxuICAgICAgICAgIDEzOiBcXFwiXFxcXFxcXFxyXFxcIixcXG4gICAgICAgICAgOTogXFxcIlxcXFxcXFxcdFxcXCJcXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXFxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFxcXCIwMDAwMDBcXFwiO1xcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXFxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXFxcIjBcXFwiYC5cXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXFxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFxcXCJcXFxcXFxcXHUwMFxcXCI7XFxuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcXFwiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcXG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXFxcIlxcXCIpIDogdmFsdWUpO1xcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXFxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1xcXCInO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxcbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XFxuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcXG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFxcXCJvYmplY3RcXFwiICYmIHZhbHVlKSB7XFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XFxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXFxcInRvSlNPTlxcXCIpKSB7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XFxuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXFxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxcbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcXG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XFxuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XFxuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XFxuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcXG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XFxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcXG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XFxuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcXG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXFxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFxcXCItXFxcIiA6IFxcXCIrXFxcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xcbiAgICAgICAgICAgICAgICAgIFxcXCItXFxcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcXFwiLVxcXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXFxuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xcbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxcbiAgICAgICAgICAgICAgICAgIFxcXCJUXFxcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFxcXCI6XFxcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXFxcIjpcXFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxcbiAgICAgICAgICAgICAgICAgIFxcXCIuXFxcIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcXFwiWlxcXCI7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFxcXCJmdW5jdGlvblxcXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFxcXCJ0b0pTT05cXFwiKSkpIHtcXG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJudWxsXFxcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcXG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcXG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxcbiAgICAgICAgICAgIHJldHVybiBcXFwiXFxcIiArIHZhbHVlO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcXG4gICAgICAgICAgICAvLyBgXFxcIm51bGxcXFwiYC5cXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFxcXCJcXFwiICsgdmFsdWUgOiBcXFwibnVsbFxcXCI7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XFxuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXFxcIlxcXCIgKyB2YWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXFxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XFxuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgICByZXN1bHRzID0gW107XFxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxcbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XFxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XFxuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXFxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFxcXCJudWxsXFxcIiA6IGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFxcXCJbXFxcXG5cXFwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXFxcIixcXFxcblxcXCIgKyBpbmRlbnRhdGlvbikgKyBcXFwiXFxcXG5cXFwiICsgcHJlZml4ICsgXFxcIl1cXFwiIDogKFxcXCJbXFxcIiArIHJlc3VsdHMuam9pbihcXFwiLFxcXCIpICsgXFxcIl1cXFwiKSkgOiBcXFwiW11cXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcXG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XFxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcXFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XFxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXFxcIjpcXFwifVxcbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXFxcIlxcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcXFwiYHNwYWNlYCBjaGFyYWN0ZXJcXFwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcXFwiOlxcXCIgKyAod2hpdGVzcGFjZSA/IFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcXFwie1xcXFxuXFxcIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFxcXCIsXFxcXG5cXFwiICsgaW5kZW50YXRpb24pICsgXFxcIlxcXFxuXFxcIiArIHByZWZpeCArIFxcXCJ9XFxcIiA6IChcXFwie1xcXCIgKyByZXN1bHRzLmpvaW4oXFxcIixcXFwiKSArIFxcXCJ9XFxcIikpIDogXFxcInt9XFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcXG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XFxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XFxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHdpZHRoKSB7XFxuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXFxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XFxuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFxcXCJcXFwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XFxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xcbiAgICAgICAgICAvLyAoYFxcXCJcXFwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcXG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFxcXCJcXFwiIGluIHsgXFxcIlxcXCI6IDF9KWApLlxcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFxcXCJcXFwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXFxcIlxcXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcXFwiXFxcIiwgW10pO1xcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXFxuICAgICAgaWYgKCFoYXMoXFxcImpzb24tcGFyc2VcXFwiKSkge1xcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XFxuXFxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXFxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xcbiAgICAgICAgICA5MjogXFxcIlxcXFxcXFxcXFxcIixcXG4gICAgICAgICAgMzQ6ICdcXFwiJyxcXG4gICAgICAgICAgNDc6IFxcXCIvXFxcIixcXG4gICAgICAgICAgOTg6IFxcXCJcXFxcYlxcXCIsXFxuICAgICAgICAgIDExNjogXFxcIlxcXFx0XFxcIixcXG4gICAgICAgICAgMTEwOiBcXFwiXFxcXG5cXFwiLFxcbiAgICAgICAgICAxMDI6IFxcXCJcXFxcZlxcXCIsXFxuICAgICAgICAgIDExNDogXFxcIlxcXFxyXFxcIlxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxcbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XFxuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcXFwiJFxcXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxcbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XFxuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XFxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXFxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XFxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXFxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XFxuICAgICAgICAgICAgICAgIEluZGV4Kys7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgICAgICAgIGNhc2UgMzQ6XFxuICAgICAgICAgICAgICAgIC8vIGBcXFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXFxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcXFwiQFxcXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXFxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXFxcImAsIGBcXFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcXFwiMHhcXFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXFxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XFxuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxcbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXFxuICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcXG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcXG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXFxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXFxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XFxuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXFxuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXFxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XFxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxcbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcXFwidHJ1ZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcXFwiZmFsc2VcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFxcXCJudWxsXFxcIikge1xcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxcbiAgICAgICAgICByZXR1cm4gXFxcIiRcXFwiO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXFxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIiRcXFwiKSB7XFxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXFxuICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcXFwiQFxcXCIpIHtcXG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIltcXFwiKSB7XFxuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcXG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XFxuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIl1cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXFxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcXG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIixcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFxcXCJdXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFxcXCIsXFxcIikge1xcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcXFwie1xcXCIpIHtcXG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXFxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XFxuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwifVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxcbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiLFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIn1cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcXG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiLFxcXCIgfHwgdHlwZW9mIHZhbHVlICE9IFxcXCJzdHJpbmdcXFwiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcXFwiQFxcXCIgfHwgbGV4KCkgIT0gXFxcIjpcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cXG4gICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcXG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXFxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXFxcIm9iamVjdFxcXCIgJiYgdmFsdWUpIHtcXG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFxcXCIwXFxcIilgKS5cXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcXG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXFxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XFxuICAgICAgICAgIEluZGV4ID0gMDtcXG4gICAgICAgICAgU291cmNlID0gXFxcIlxcXCIgKyBzb3VyY2U7XFxuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XFxuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxcbiAgICAgICAgICBpZiAobGV4KCkgIT0gXFxcIiRcXFwiKSB7XFxuICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXFxcIlxcXCJdID0gcmVzdWx0LCB2YWx1ZSksIFxcXCJcXFwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBleHBvcnRzW1xcXCJydW5JbkNvbnRleHRcXFwiXSA9IHJ1bkluQ29udGV4dDtcXG4gICAgcmV0dXJuIGV4cG9ydHM7XFxuICB9XFxuXFxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XFxuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxcbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1xcXCJKU09OM1xcXCJdLFxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xcblxcbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXFxcIkpTT04zXFxcIl0gPSB7XFxuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxcbiAgICAgIFxcXCJub0NvbmZsaWN0XFxcIjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XFxuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xcbiAgICAgICAgICByb290W1xcXCJKU09OM1xcXCJdID0gcHJldmlvdXNKU09OO1xcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBKU09OMztcXG4gICAgICB9XFxuICAgIH0pKTtcXG5cXG4gICAgcm9vdC5KU09OID0ge1xcbiAgICAgIFxcXCJwYXJzZVxcXCI6IEpTT04zLnBhcnNlLFxcbiAgICAgIFxcXCJzdHJpbmdpZnlcXFwiOiBKU09OMy5zdHJpbmdpZnlcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxcbiAgaWYgKGlzTG9hZGVyKSB7XFxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIEpTT04zO1xcbiAgICB9KTtcXG4gIH1cXG59KS5jYWxsKHRoaXMpO1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICovXFxudmFyIGJhc2VDb3B5ID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlY29weScpLFxcbiAgICBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKTtcXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICovXFxuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xcbiAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXFxuICAgID8gb2JqZWN0XFxuICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcXG5cXG59LHtcXFwibG9kYXNoLl9iYXNlY29weVxcXCI6NzEsXFxcImxvZGFzaC5rZXlzXFxcIjo3OH1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICovXFxuXFxuLyoqXFxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gKi9cXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcXG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xcblxcbiAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xcblxcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcXG4gICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcXG4gIH1cXG4gIHJldHVybiBvYmplY3Q7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gYmFzZUNvcHk7XFxuXFxufSx7fV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjAuMyAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXFxuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gKi9cXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XFxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XFxuICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XFxuICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcXG4gICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQgfHwge307XFxuICB9O1xcbn0oKSk7XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNPYmplY3Qoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KDEpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXFxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xcblxcbn0se31dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBsb2Rhc2ggMy45LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICovXFxuXFxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xcbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxcXF0kLztcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4vKipcXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxcbiAqIG9mIHZhbHVlcy5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xcbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXFxuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXFxcXF4kLiorPygpW1xcXFxde318XS9nLCAnXFxcXFxcXFwkJicpXFxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXFxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcXG4pO1xcblxcbi8qKlxcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXFxuICovXFxuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XFxuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNGdW5jdGlvbihfKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXFxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxcbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoMSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc05hdGl2ZShfKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcXG4gIH1cXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XFxuXFxufSx7fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjAuOSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXFxudmFyIHJlSXNVaW50ID0gL15cXFxcZCskLztcXG5cXG4vKipcXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxcbiAqL1xcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XFxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgXFxcImxlbmd0aFxcXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXFxuICpcXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXFxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcXFwibGVuZ3RoXFxcIiB2YWx1ZS5cXG4gKi9cXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XFxuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XFxuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XFxuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxcbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXFxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCwgZWxzZSBgZmFsc2VgLlxcbiAqL1xcbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XFxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XFxuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xcbiAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXFxuICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpKSB7XFxuICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XFxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxcbiAqXFxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aCkuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxcbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoMSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xcblxcbn0se31dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBsb2Rhc2ggMy4xLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICovXFxudmFyIGJhc2VBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vhc3NpZ24nKSxcXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWNyZWF0ZScpLFxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJ2xvZGFzaC5faXNpdGVyYXRlZWNhbGwnKTtcXG5cXG4vKipcXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxcbiAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXFxuICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IE9iamVjdFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXFxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBmdW5jdGlvbiBTaGFwZSgpIHtcXG4gKiAgIHRoaXMueCA9IDA7XFxuICogICB0aGlzLnkgPSAwO1xcbiAqIH1cXG4gKlxcbiAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcXG4gKiAgIFNoYXBlLmNhbGwodGhpcyk7XFxuICogfVxcbiAqXFxuICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xcbiAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXFxuICogfSk7XFxuICpcXG4gKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcXG4gKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XFxuICogLy8gPT4gdHJ1ZVxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XFxuICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XFxuICAgIHByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XFxuICB9XFxuICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XFxuXFxufSx7XFxcImxvZGFzaC5fYmFzZWFzc2lnblxcXCI6NzAsXFxcImxvZGFzaC5fYmFzZWNyZWF0ZVxcXCI6NzIsXFxcImxvZGFzaC5faXNpdGVyYXRlZWNhbGxcXFwiOjc0fV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXFxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xcblxcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcXG5cXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXFxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4vKipcXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXFxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXFxuICogb2YgdmFsdWVzLlxcbiAqL1xcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xcblxcbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgMC4xLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcXG4gKiAgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XFxuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXFxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XFxufVxcblxcbi8qKlxcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcXG4gKiBpcyBhbiBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxcbiAqICBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgMC4xLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0Z1bmN0aW9uKF8pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XFxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXFxuICpcXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxcbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNMZW5ndGgoMyk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKlxcbiAqIF8uaXNMZW5ndGgoJzMnKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXFxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXFxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSAwLjEuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNPYmplY3Qoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChudWxsKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XFxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXFxcIm9iamVjdFxcXCIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XFxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XFxuXFxufSx7fV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXFxudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXFxdJC87XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XFxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XFxufVxcblxcbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXFxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXFxudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXFxudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XFxuXFxuLyoqXFxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcXG4gKiBvZiB2YWx1ZXMuXFxuICovXFxudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXFxcXFxeJC4qKz8oKVtcXFxcXXt9fF0vZywgJ1xcXFxcXFxcJCYnKVxcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFxcXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXFxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXFxuKTtcXG5cXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xcbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xcblxcbi8qKlxcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXFxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cXG4gKi9cXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cXG4gKi9cXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcXG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XFxuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXFxuICpcXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxcbiAqL1xcbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxudmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzRnVuY3Rpb24oXyk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcXG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNPYmplY3Qoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KDEpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXFxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNOYXRpdmUoXyk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XFxuICB9XFxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcXG5cXG59LHt9XSw3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxcbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqL1xcbnZhciBnZXROYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guX2dldG5hdGl2ZScpLFxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKTtcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXFxudmFyIHJlSXNVaW50ID0gL15cXFxcZCskLztcXG5cXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXFxudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XFxuXFxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XFxuXFxuLyoqXFxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxcbiAqL1xcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XFxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgXFxcImxlbmd0aFxcXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXFxuICpcXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXFxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcXFwibGVuZ3RoXFxcIiB2YWx1ZS5cXG4gKi9cXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XFxuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XFxuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XFxuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cXG4gKlxcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xcbn1cXG5cXG4vKipcXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXFxuICovXFxuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XFxuICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcXG4gICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xcblxcbiAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcXG5cXG4gIHZhciBpbmRleCA9IC0xLFxcbiAgICAgIHJlc3VsdCA9IFtdO1xcblxcbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xcbiAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxcbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoMSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXFxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxcbiAqIGZvciBtb3JlIGRldGFpbHMuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gKiAgIHRoaXMuYSA9IDE7XFxuICogICB0aGlzLmIgPSAyO1xcbiAqIH1cXG4gKlxcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XFxuICpcXG4gKiBfLmtleXMobmV3IEZvbyk7XFxuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAqXFxuICogXy5rZXlzKCdoaScpO1xcbiAqIC8vID0+IFsnMCcsICcxJ11cXG4gKi9cXG52YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcXG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XFxuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcXG4gICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XFxuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xcbiAgfVxcbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXFxuICpcXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBPYmplY3RcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogZnVuY3Rpb24gRm9vKCkge1xcbiAqICAgdGhpcy5hID0gMTtcXG4gKiAgIHRoaXMuYiA9IDI7XFxuICogfVxcbiAqXFxuICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gKlxcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAqL1xcbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xcbiAgICByZXR1cm4gW107XFxuICB9XFxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcXG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XFxuICB9XFxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcXG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcXG5cXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxcbiAgICAgIGluZGV4ID0gLTEsXFxuICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcXG5cXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XFxuICB9XFxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ga2V5cztcXG5cXG59LHtcXFwibG9kYXNoLl9nZXRuYXRpdmVcXFwiOjczLFxcXCJsb2Rhc2guaXNhcmd1bWVudHNcXFwiOjc2LFxcXCJsb2Rhc2guaXNhcnJheVxcXCI6Nzd9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBfMDc3NyA9IHBhcnNlSW50KCcwNzc3JywgOCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcXG5cXG5mdW5jdGlvbiBta2RpclAgKHAsIG9wdHMsIGYsIG1hZGUpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBmID0gb3B0cztcXG4gICAgICAgIG9wdHMgPSB7fTtcXG4gICAgfVxcbiAgICBlbHNlIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuICAgIFxcbiAgICB2YXIgY2IgPSBmIHx8IGZ1bmN0aW9uICgpIHt9O1xcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcbiAgICBcXG4gICAgeGZzLm1rZGlyKHAsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xcbiAgICAgICAgaWYgKCFlcikge1xcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG1hZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJzpcXG4gICAgICAgICAgICAgICAgbWtkaXJQKHBhdGguZGlybmFtZShwKSwgb3B0cywgZnVuY3Rpb24gKGVyLCBtYWRlKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbWtkaXJQKHAsIG9wdHMsIGNiLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcblxcbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XFxuICAgIH1cXG4gICAgXFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcXG4gICAgXFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcXG4gICAgfVxcbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xcblxcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcblxcbiAgICB0cnkge1xcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcXG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycjApIHtcXG4gICAgICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJyA6XFxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIHN5bmMocCwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHZhciBzdGF0O1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hZGU7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJmc1xcXCI6NDIsXFxcInBhdGhcXFwiOjQyfV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcXG5cXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXFxuICAgIH1cXG4gICAgZWxzZSByZXR1cm4gJyc7XFxufTtcXG5cXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xcblxcbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xcblxcbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XFxufTtcXG5cXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcXG59O1xcblxcbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XFxuXFxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XFxuXFxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcXG4gICAgfVxcbiAgICByZXR1cm4gJyc7XFxufTtcXG5cXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXFxuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXFxuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xcblxcbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xcblxcbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcXG5cXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gJy90bXAnO1xcbn07XFxuXFxuZXhwb3J0cy5FT0wgPSAnXFxcXG4nO1xcblxcbn0se31dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcXG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xcbn0gZWxzZSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XFxufVxcblxcbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XFxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJjYWxsYmFja1xcXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuICB9XFxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBhcmdzLCBpO1xcbiAgc3dpdGNoIChsZW4pIHtcXG4gIGNhc2UgMDpcXG4gIGNhc2UgMTpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xcbiAgY2FzZSAyOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcXG4gICAgfSk7XFxuICBjYXNlIDM6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xcbiAgICB9KTtcXG4gIGNhc2UgNDpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcXG4gICAgfSk7XFxuICBkZWZhdWx0OlxcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xcbiAgICBpID0gMDtcXG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XFxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XFxuXFxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxcblxcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcblxcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XFxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XFxuXFxufSx7fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjg0fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXFxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3NcXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXFxuLy8gV3JpdGFibGUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XFxuICB2YXIga2V5cyA9IFtdO1xcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICBrZXlzLnB1c2goa2V5KTtcXG4gIH1yZXR1cm4ga2V5cztcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xcblxcbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XFxuXFxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XFxuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XFxuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcXG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcXG59XFxuXFxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcXG5cXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XFxuXFxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XFxuXFxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcXG59XFxuXFxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxcbmZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcXG4gIC8vIHRoZW4gd2UncmUgb2suXFxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcXG5cXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxcbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcXG4gIHNlbGYuZW5kKCk7XFxufVxcblxcbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGYoeHNbaV0sIGkpO1xcbiAgfVxcbn1cXG59LHtcXFwiLi9fc3RyZWFtX3JlYWRhYmxlXFxcIjo4NixcXFwiLi9fc3RyZWFtX3dyaXRhYmxlXFxcIjo4OCxcXFwiY29yZS11dGlsLWlzXFxcIjo0NCxcXFwiaW5oZXJpdHNcXFwiOjY2LFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6ODF9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXFxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXFxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcXG5cXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xcblxcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XFxuXFxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcXG59XFxuXFxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobnVsbCwgY2h1bmspO1xcbn07XFxufSx7XFxcIi4vX3N0cmVhbV90cmFuc2Zvcm1cXFwiOjg3LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQ0LFxcXCJpbmhlcml0c1xcXCI6NjZ9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRHVwbGV4O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xcbn0gZWxzZSB7XFxuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xcbn1cXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XFxudmFyIFN0cmluZ0RlY29kZXI7XFxuXFxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcXG5cXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xcblxcbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcXG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXFxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XFxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXFxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xcbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcXFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclxcXCJcXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XFxuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XFxuXFxuICAvLyBjYXN0IHRvIGludHMuXFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcXG5cXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXFxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxcbiAgLy8gYXJyYXkuc2hpZnQoKVxcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xcbiAgdGhpcy5sZW5ndGggPSAwO1xcbiAgdGhpcy5waXBlcyA9IG51bGw7XFxuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XFxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcXG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxcbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XFxuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXFxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxcbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcXG5cXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXFxuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xcblxcbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xcblxcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcXG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcXG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XFxuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeVxcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XFxuXFxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxcbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcXG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gICAgICBlbmNvZGluZyA9ICcnO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XFxufTtcXG5cXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XFxufTtcXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcXG59O1xcblxcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XFxuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcXG4gIGlmIChlcikge1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XFxuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcXG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XFxuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHNraXBBZGQ7XFxuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XFxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuXFxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXFxuICAgICAgaWYgKCFza2lwQWRkKSB7XFxuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxcbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XFxuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG5cXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XFxufVxcblxcbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXFxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXFxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XFxufVxcblxcbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxcblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcXG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XFxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xcbiAgICBuID0gTUFYX0hXTTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxcbiAgICAvLyB0aW55IGFtb3VudHNcXG4gICAgbi0tO1xcbiAgICBuIHw9IG4gPj4+IDE7XFxuICAgIG4gfD0gbiA+Pj4gMjtcXG4gICAgbiB8PSBuID4+PiA0O1xcbiAgICBuIHw9IG4gPj4+IDg7XFxuICAgIG4gfD0gbiA+Pj4gMTY7XFxuICAgIG4rKztcXG4gIH1cXG4gIHJldHVybiBuO1xcbn1cXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xcbiAgaWYgKG4gIT09IG4pIHtcXG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXFxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcXG4gIH1cXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxcbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XFxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIDA7XFxuICB9XFxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbn1cXG5cXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxcblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIGRlYnVnKCdyZWFkJywgbik7XFxuICBuID0gcGFyc2VJbnQobiwgMTApO1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBuT3JpZyA9IG47XFxuXFxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuXFxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXFxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXFxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XFxuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xcblxcbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXFxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXFxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxcbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXFxuICAvL1xcbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XFxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXFxuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxcbiAgLy9cXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXFxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxcbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXFxuICAvL1xcbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxcblxcbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxcbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcXG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcXG5cXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkb1JlYWQgPSB0cnVlO1xcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xcbiAgfVxcblxcbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcXG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XFxuICAgIGRvUmVhZCA9IGZhbHNlO1xcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XFxuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcXG4gICAgc3RhdGUuc3luYyA9IHRydWU7XFxuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXFxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHZhciByZXQ7XFxuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XFxuXFxuICBpZiAocmV0ID09PSBudWxsKSB7XFxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIG4gPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgc3RhdGUubGVuZ3RoIC09IG47XFxuICB9XFxuXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXFxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuXFxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gIH1cXG5cXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xcbiAgdmFyIGVyID0gbnVsbDtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XFxuICB9XFxuICByZXR1cm4gZXI7XFxufVxcblxcbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XFxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XFxuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcblxcbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXFxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG59XFxuXFxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXFxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXFxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcXG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XFxuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XFxuICBmbG93KHN0cmVhbSk7XFxufVxcblxcbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXFxuLy8gaXQncyBpbiBwcm9ncmVzcy5cXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XFxuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxcbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcXG59XFxuXFxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXFxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFxcXCJsZW5ndGhcXFwiIGlzIHNvbWV3aGF0XFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxcblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcXG59O1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XFxuICB2YXIgc3JjID0gdGhpcztcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcXG4gICAgY2FzZSAwOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAxOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xcbiAgICAgIGJyZWFrO1xcbiAgfVxcbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcXG5cXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XFxuXFxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xcblxcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcXG4gICAgZGVidWcoJ29udW5waXBlJyk7XFxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XFxuICAgICAgY2xlYW51cCgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgZGVidWcoJ29uZW5kJyk7XFxuICAgIGRlc3QuZW5kKCk7XFxuICB9XFxuXFxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXFxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXFxuICAvLyB0b28gc2xvdy5cXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XFxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xcblxcbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xcblxcbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXFxuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxcbiAgICAvLyBmbG93aW5nIGFnYWluLlxcbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXFxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xcbiAgfVxcblxcbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXFxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxcbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxcbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XFxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcXG4gICAgZGVidWcoJ29uZGF0YScpO1xcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XFxuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcXG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcXG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXFxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXFxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XFxuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgc3JjLnBhdXNlKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxcbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcXG4gICAgdW5waXBlKCk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XFxuICB9XFxuXFxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXFxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxcbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgdW5waXBlKCk7XFxuICB9XFxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG5cXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcXG4gICAgZGVidWcoJ3VucGlwZScpO1xcbiAgICBzcmMudW5waXBlKGRlc3QpO1xcbiAgfVxcblxcbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XFxuXFxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XFxuICAgIHNyYy5yZXN1bWUoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXN0O1xcbn07XFxuXFxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XFxuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XFxuICAgICAgZmxvdyhzcmMpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xcblxcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcXG5cXG4gICAgLy8gZ290IGEgbWF0Y2guXFxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cXG5cXG4gIGlmICghZGVzdCkge1xcbiAgICAvLyByZW1vdmUgYWxsLlxcbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcXG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XFxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xcbiAgICB9cmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxcbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XFxuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcXG5cXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XFxuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcXG5cXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3JcXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcXG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcXG5cXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XFxuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcXG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXM7XFxufTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XFxuXFxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XFxuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XFxuICBzZWxmLnJlYWQoMCk7XFxufVxcblxcbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZScpO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XFxuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICB9XFxuXFxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xcbiAgZmxvdyhzdHJlYW0pO1xcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwYXVzZScpO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XFxufVxcblxcbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXFxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxcbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxcblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICB9XFxuXFxuICAgIHNlbGYucHVzaChudWxsKTtcXG4gIH0pO1xcblxcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuXFxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XFxuXFxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICBpZiAoIXJldCkge1xcbiAgICAgIHBhdXNlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLnBhdXNlKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxcbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXFxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgICAgfShpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcXG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgc2VsZi5lbWl0LmJpbmQoc2VsZiwga1Byb3h5RXZlbnRzW25dKSk7XFxuICB9XFxuXFxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXFxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xcbiAgICBpZiAocGF1c2VkKSB7XFxuICAgICAgcGF1c2VkID0gZmFsc2U7XFxuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIHNlbGY7XFxufTtcXG5cXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXFxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XFxuXFxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XFxuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcXG5cXG4gIHZhciByZXQ7XFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcXG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcXG4gIHZhciByZXQ7XFxuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcXG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcXG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XFxuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXFxuLy8gY2h1bmtzLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHZhciByZXQgPSBwLmRhdGE7XFxuICBuIC09IHJldC5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xcbiAgICBuIC09IG5iO1xcbiAgICBpZiAobiA9PT0gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xcbiAgICAgICAgKytjO1xcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcXG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgICsrYztcXG4gIH1cXG4gIGxpc3QubGVuZ3RoIC09IGM7XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcXG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHAuZGF0YS5jb3B5KHJldCk7XFxuICBuIC09IHAuZGF0YS5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XFxuICAgIG4gLT0gbmI7XFxuICAgIGlmIChuID09PSAwKSB7XFxuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XFxuICAgICAgICArK2M7XFxuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaXN0LmhlYWQgPSBwO1xcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgKytjO1xcbiAgfVxcbiAgbGlzdC5sZW5ndGggLT0gYztcXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXFxcImVuZFJlYWRhYmxlKClcXFwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XFxuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcXG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBmKHhzW2ldLCBpKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcXG4gIH1cXG4gIHJldHVybiAtMTtcXG59XFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vX3N0cmVhbV9kdXBsZXhcXFwiOjg0LFxcXCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdFxcXCI6ODksXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cXFwiOjkwLFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDQsXFxcImV2ZW50c1xcXCI6NjIsXFxcImluaGVyaXRzXFxcIjo2NixcXFwiaXNhcnJheVxcXCI6NjgsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo4MSxcXFwic2FmZS1idWZmZXJcXFwiOjk1LFxcXCJzdHJpbmdfZGVjb2Rlci9cXFwiOjk3LFxcXCJ1dGlsXFxcIjo0MH1dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXFxuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcXFwiZmlsdGVyXFxcIixcXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXFxuLy9cXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXFxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXFxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxcbi8vXFxuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxcbi8vXFxuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXFxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxcbi8vXFxuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXFxuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5Llxcbi8vXFxuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXFxuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXFxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5Llxcbi8vXFxuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XFxuXFxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XFxuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XFxuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcXG4gIH07XFxuXFxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcXG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcXG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcXG5cXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XFxuXFxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcXG5cXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xcbiAgdHMud3JpdGVjYiA9IG51bGw7XFxuXFxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xcblxcbiAgY2IoZXIpO1xcblxcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcXG5cXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XFxuXFxuICB2YXIgc3RyZWFtID0gdGhpcztcXG5cXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXFxuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXFxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcXG4gIH1cXG5cXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcXG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcXG4gIH0pO1xcbn1cXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XFxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XFxuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcXG59O1xcblxcbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxcbi8vXFxuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cXG4vL1xcbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXFxuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xcbn07XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuICB0cy53cml0ZWNiID0gY2I7XFxuICB0cy53cml0ZWNodW5rID0gY2h1bms7XFxuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59O1xcblxcbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXFxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXFxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XFxuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuXFxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xcblxcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xcblxcbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcXG5cXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xcblxcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xcbn1cXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6ODQsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDQsXFxcImluaGVyaXRzXFxcIjo2Nn1dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxcbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIER1cGxleDtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgaW50ZXJuYWxVdGlsID0ge1xcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcXG5cXG5mdW5jdGlvbiBub3AoKSB7fVxcblxcbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcXG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcXG4gIHRoaXMubmV4dCA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xcblxcbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XFxuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcXG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XFxuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXFxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xcbiAgLy8gc29ja2V0IG9yIGZpbGUuXFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxcbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XFxuXFxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXFxuICB0aGlzLmNvcmtlZCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XFxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcXG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxcbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXFxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcXG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcXG4gIH07XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuXFxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXFxuICB0aGlzLndyaXRlbGVuID0gMDtcXG5cXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuXFxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XFxuXFxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXFxuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XFxuXFxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XFxuXFxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXFxuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXFxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xcbn1cXG5cXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XFxuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgd2hpbGUgKGN1cnJlbnQpIHtcXG4gICAgb3V0LnB1c2goY3VycmVudCk7XFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XFxuICB9XFxuICByZXR1cm4gb3V0O1xcbn07XFxuXFxuKGZ1bmN0aW9uICgpIHtcXG4gIHRyeSB7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcXG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XFxuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxcbiAgICB9KTtcXG4gIH0gY2F0Y2ggKF8pIHt9XFxufSkoKTtcXG5cXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXFxudmFyIHJlYWxIYXNJbnN0YW5jZTtcXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XFxuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XFxuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XFxuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xcblxcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcXG4gICAgfVxcbiAgfSk7XFxufSBlbHNlIHtcXG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXFxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cXG5cXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXFxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXFxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XFxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XFxuICB9XFxuXFxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3kuXFxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcXG4gIH1cXG5cXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xcbn1cXG5cXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXFxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xcbn07XFxuXFxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XFxuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xcbn1cXG5cXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXFxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcXG4gIHZhciBlciA9IGZhbHNlO1xcblxcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xcbiAgfVxcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxuICAgIHZhbGlkID0gZmFsc2U7XFxuICB9XFxuICByZXR1cm4gdmFsaWQ7XFxufVxcblxcbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHJldCA9IGZhbHNlO1xcbiAgdmFyIGlzQnVmID0gQnVmZmVyLmlzQnVmZmVyKGNodW5rKTtcXG5cXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBlbmNvZGluZztcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XFxuXFxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcXG5cXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIHN0YXRlLmNvcmtlZCsrO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZC0tO1xcblxcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XFxuICB9XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XFxuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XFxuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcXG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xcbiAgfVxcbiAgcmV0dXJuIGNodW5rO1xcbn1cXG5cXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXFxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgaWYgKCFpc0J1Zikge1xcbiAgICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcXG4gIH1cXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XFxuXFxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxcbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XFxuXFxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcXG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgICBpZiAobGFzdCkge1xcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfVxcbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xcbiAgfSBlbHNlIHtcXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XFxuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcXG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcXG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XFxuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XFxuXFxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XFxuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XFxuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcXG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcXG4gIHN0YXRlLndyaXRlbGVuID0gMDtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XFxuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xcblxcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcXG5cXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XFxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xcblxcbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XFxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN5bmMpIHtcXG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xcbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcXG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cXG4gICAgfSBlbHNlIHtcXG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcXG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcXG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgY2IoKTtcXG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbn1cXG5cXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxcbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XFxuICB9XFxufVxcblxcbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XFxuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XFxuXFxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXFxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XFxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XFxuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XFxuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xcblxcbiAgICB2YXIgY291bnQgPSAwO1xcbiAgICB3aGlsZSAoZW50cnkpIHtcXG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIGNvdW50ICs9IDE7XFxuICAgIH1cXG5cXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xcblxcbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcXG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxcbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXFxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxcbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIH1cXG5cXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xcbn1cXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBjaHVuaztcXG4gICAgY2h1bmsgPSBudWxsO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xcblxcbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkID0gMTtcXG4gICAgdGhpcy51bmNvcmsoKTtcXG4gIH1cXG5cXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcXG59O1xcblxcbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcXG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XFxufVxcblxcbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XFxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xcbiAgaWYgKG5lZWQpIHtcXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5lZWQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XFxuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICBpZiAoY2IpIHtcXG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcXG4gIH1cXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xcbn1cXG5cXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3RcXG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG4gIHRoaXMuZW50cnkgPSBudWxsO1xcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgICAgIGNiKGVycik7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICB9XFxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xcbiAgICB9XFxuICB9O1xcbn1cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6ODQsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cXFwiOjkwLFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDQsXFxcImluaGVyaXRzXFxcIjo2NixcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjgxLFxcXCJzYWZlLWJ1ZmZlclxcXCI6OTUsXFxcInV0aWwtZGVwcmVjYXRlXFxcIjo5OX1dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0O1xcblxcbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XFxuICB0aGlzLmhlYWQgPSBudWxsO1xcbiAgdGhpcy50YWlsID0gbnVsbDtcXG4gIHRoaXMubGVuZ3RoID0gMDtcXG59XFxuXFxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XFxuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcXG4gIHRoaXMudGFpbCA9IGVudHJ5O1xcbiAgKyt0aGlzLmxlbmd0aDtcXG59O1xcblxcbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XFxuICB0aGlzLmhlYWQgPSBlbnRyeTtcXG4gICsrdGhpcy5sZW5ndGg7XFxufTtcXG5cXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XFxuICAtLXRoaXMubGVuZ3RoO1xcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcXG4gIHRoaXMubGVuZ3RoID0gMDtcXG59O1xcblxcbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XFxuICB2YXIgcCA9IHRoaXMuaGVhZDtcXG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcXG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgIHJldCArPSBzICsgcC5kYXRhO1xcbiAgfXJldHVybiByZXQ7XFxufTtcXG5cXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XFxuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XFxuICB2YXIgaSA9IDA7XFxuICB3aGlsZSAocCkge1xcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XFxuICAgIHAgPSBwLm5leHQ7XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn07XFxufSx7XFxcInNhZmUtYnVmZmVyXFxcIjo5NX1dLDkwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo2Mn1dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxcblxcbn0se1xcXCIuL3JlYWRhYmxlXFxcIjo5Mn1dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XFxuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XFxuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcXG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xcXCI6ODQsXFxcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcXFwiOjg1LFxcXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXFxcIjo4NixcXFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcXFwiOjg3LFxcXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXFxcIjo4OH1dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cXG5cXG59LHtcXFwiLi9yZWFkYWJsZVxcXCI6OTJ9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjg4fV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnVmZmVyJylcXG5cXG59LHtcXFwiYnVmZmVyXFxcIjo0M31dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcXG5cXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG5cXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcXG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcXG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcXG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XFxuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcXG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xcblxcblxcblxcbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcXG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxcblxcbmZ1bmN0aW9uIFN0cmVhbSgpIHtcXG4gIEVFLmNhbGwodGhpcyk7XFxufVxcblxcblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcXG4gIHZhciBzb3VyY2UgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XFxuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XFxuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcXG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcXG5cXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XFxuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxcbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XFxuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XFxuICB9XFxuXFxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcXG4gICAgZGlkT25FbmQgPSB0cnVlO1xcblxcbiAgICBkZXN0LmVuZCgpO1xcbiAgfVxcblxcblxcbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xcbiAgfVxcblxcbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xcbiAgICBjbGVhbnVwKCk7XFxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XFxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cXG4gICAgfVxcbiAgfVxcblxcbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXFxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XFxuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcXG5cXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXFxuICByZXR1cm4gZGVzdDtcXG59O1xcblxcbn0se1xcXCJldmVudHNcXFwiOjYyLFxcXCJpbmhlcml0c1xcXCI6NjYsXFxcInJlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcXFwiOjgzLFxcXCJyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanNcXFwiOjkxLFxcXCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcXFwiOjkyLFxcXCJyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzXFxcIjo5MyxcXFwicmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzXFxcIjo5NH1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcblxcbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XFxuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XFxuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XFxuICB2YXIgcmV0cmllZDtcXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jKSB7XFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuICd1dGY4JztcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBlbmM7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcXG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XFxuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcXG4gIHJldHVybiBuZW5jIHx8IGVuYztcXG59XFxuXFxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxcbi8vIGNoYXJhY3RlcnMuXFxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcXG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XFxuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xcbiAgdmFyIG5iO1xcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xcbiAgICAgIG5iID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcXG4gICAgICBuYiA9IDQ7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcXG4gICAgICBuYiA9IDM7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xcbiAgICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMubGFzdE5lZWQgPSAwO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XFxufVxcblxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcXG4gIHZhciByO1xcbiAgdmFyIGk7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkge1xcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XFxuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIGkgPSAwO1xcbiAgfVxcbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xcbiAgcmV0dXJuIHIgfHwgJyc7XFxufTtcXG5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xcblxcbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xcblxcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xcbiAgfVxcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcXG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcXG59O1xcblxcbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcXG4vLyBjb250aW51YXRpb24gYnl0ZS5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcXG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xcbiAgcmV0dXJuIC0xO1xcbn1cXG5cXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXFxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XFxuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcXG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcXG4gIGlmIChuYiA+PSAwKSB7XFxuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XFxuICAgIHJldHVybiBuYjtcXG4gIH1cXG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcXG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XFxuICBpZiAobmIgPj0gMCkge1xcbiAgICBpZiAobmIgPiAwKSB7XFxuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xcbiAgICB9XFxuICAgIHJldHVybiBuYjtcXG4gIH1cXG4gIHJldHVybiAwO1xcbn1cXG5cXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxcbi8vIG9uZSwgd2UgXFxcInJlcGxhY2VcXFwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcXG4vLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXFxcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmdcXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXFxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXFxuLy8gbG9vcC5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcXG4gICAgcmV0dXJuICdcXFxcdWZmZmQnLnJlcGVhdChwKTtcXG4gIH1cXG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XFxuICAgICAgcmV0dXJuICdcXFxcdWZmZmQnLnJlcGVhdChwICsgMSk7XFxuICAgIH1cXG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XFxuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XFxuICAgICAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxcbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcXG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XFxuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XFxuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcXG4gIH1cXG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xcbn1cXG5cXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcXG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcXG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcXG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XFxufVxcblxcbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKVxcbi8vIGNoYXJhY3RlciBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgb3V0cHV0LlxcbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFxcXHVmZmZkJy5yZXBlYXQodGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIHJldHVybiByO1xcbn1cXG5cXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxcbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXFxuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XFxuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcXG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcXG4gICAgaWYgKHIpIHtcXG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XFxuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XFxuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcXG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcjtcXG4gIH1cXG4gIHRoaXMubGFzdE5lZWQgPSAxO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xcbn1cXG5cXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxcbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcXG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcXG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcXG4gIH1cXG4gIHJldHVybiByO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcXG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcXG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcXG4gIHRoaXMubGFzdFRvdGFsID0gMztcXG4gIGlmIChuID09PSAxKSB7XFxuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XFxuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgfVxcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XFxuICByZXR1cm4gcjtcXG59XFxuXFxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcXG59XFxuXFxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxufVxcbn0se1xcXCJzYWZlLWJ1ZmZlclxcXCI6OTh9XSw5ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xcbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXFxuXFxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcXG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcXG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxcbiAgfVxcbn1cXG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxcbn0gZWxzZSB7XFxuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXFxuXFxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgfSBlbHNlIHtcXG4gICAgICBidWYuZmlsbChmaWxsKVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBidWYuZmlsbCgwKVxcbiAgfVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gQnVmZmVyKHNpemUpXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcXG59XFxuXFxufSx7XFxcImJ1ZmZlclxcXCI6NDN9XSw5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcblxcbi8qKlxcbiAqIE1vZHVsZSBleHBvcnRzLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xcblxcbi8qKlxcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXFxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXFxuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFxcXCJkZXByZWNhdGVkXFxcIiB2ZXJzaW9uIG9mIGBmbmBcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcXG4gIHRyeSB7XFxuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xcbiAgfSBjYXRjaCAoXykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcXG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sMTAwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5hcmd1bWVudHNbNF1bNjZdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxcbn0se1xcXCJkdXBcXFwiOjY2fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXFxuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xcbn1cXG59LHt9XSwxMDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcXG4gIH1cXG5cXG4gIHZhciBpID0gMTtcXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcXG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcXG4gICAgc3dpdGNoICh4KSB7XFxuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWonOlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XFxuICAgICAgICB9IGNhdGNoIChfKSB7XFxuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICAgICAgICB9XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiB4O1xcbiAgICB9XFxuICB9KTtcXG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XFxuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XFxuICAgICAgc3RyICs9ICcgJyArIHg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBzdHI7XFxufTtcXG5cXG5cXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxcbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXFxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXFxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XFxuICAgICAgfVxcbiAgICAgIHdhcm5lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVwcmVjYXRlZDtcXG59O1xcblxcblxcbnZhciBkZWJ1Z3MgPSB7fTtcXG52YXIgZGVidWdFbnZpcm9uO1xcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcXG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XFxuICBpZiAoIWRlYnVnc1tzZXRdKSB7XFxuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcXFxcXGInICsgc2V0ICsgJ1xcXFxcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XFxuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGVidWdzW3NldF07XFxufTtcXG5cXG5cXG4vKipcXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXFxuICovXFxuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xcbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XFxuICAvLyBkZWZhdWx0IG9wdGlvbnNcXG4gIHZhciBjdHggPSB7XFxuICAgIHNlZW46IFtdLFxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxcbiAgfTtcXG4gIC8vIGxlZ2FjeS4uLlxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcXG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcXG4gICAgLy8gbGVnYWN5Li4uXFxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcXG4gIH0gZWxzZSBpZiAob3B0cykge1xcbiAgICAvLyBnb3QgYW4gXFxcIm9wdGlvbnNcXFwiIG9iamVjdFxcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcXG4gIH1cXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcXG59XFxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcXG5cXG5cXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcXG5pbnNwZWN0LmNvbG9ycyA9IHtcXG4gICdib2xkJyA6IFsxLCAyMl0sXFxuICAnaXRhbGljJyA6IFszLCAyM10sXFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXFxuICAnYmxhY2snIDogWzMwLCAzOV0sXFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcXG4gICdjeWFuJyA6IFszNiwgMzldLFxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXFxuICAncmVkJyA6IFszMSwgMzldLFxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxcbn07XFxuXFxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXFxuaW5zcGVjdC5zdHlsZXMgPSB7XFxuICAnc3BlY2lhbCc6ICdjeWFuJyxcXG4gICdudW1iZXInOiAneWVsbG93JyxcXG4gICdib29sZWFuJzogJ3llbGxvdycsXFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxcbiAgJ251bGwnOiAnYm9sZCcsXFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcXG4gICdkYXRlJzogJ21hZ2VudGEnLFxcbiAgLy8gXFxcIm5hbWVcXFwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXFxuICAncmVnZXhwJzogJ3JlZCdcXG59O1xcblxcblxcbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XFxuXFxuICBpZiAoc3R5bGUpIHtcXG4gICAgcmV0dXJuICdcXFxcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXFxuICAgICAgICAgICAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcbn1cXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xcbiAgcmV0dXJuIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcXG4gIHZhciBoYXNoID0ge307XFxuXFxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XFxuICAgIGhhc2hbdmFsXSA9IHRydWU7XFxuICB9KTtcXG5cXG4gIHJldHVybiBoYXNoO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcXG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXFxuICAgICAgdmFsdWUgJiZcXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXFxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXFxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXFxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XFxuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcXG4gIGlmIChwcmltaXRpdmUpIHtcXG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcXG4gIH1cXG5cXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XFxuXFxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcXG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcXG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcXG5cXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xcbiAgICBhcnJheSA9IHRydWU7XFxuICAgIGJyYWNlcyA9IFsnWycsICddJ107XFxuICB9XFxuXFxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcXG4gIH1cXG5cXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXFxuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXFxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXFxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcXG4gIH1cXG5cXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuXFxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcXG5cXG4gIHZhciBvdXRwdXQ7XFxuICBpZiAoYXJyYXkpIHtcXG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XFxuICB9IGVsc2Uge1xcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgY3R4LnNlZW4ucG9wKCk7XFxuXFxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XFxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XFxuICAgIHZhciBzaW1wbGUgPSAnXFxcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cXFwifFxcXCIkL2csICcnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKSArICdcXFxcJyc7XFxuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcXG4gIH1cXG4gIGlmIChpc051bWJlcih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XFxuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XFxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXFxcIm9iamVjdFxcXCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxcbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XFxuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XFxuICB2YXIgb3V0cHV0ID0gW107XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRwdXQucHVzaCgnJyk7XFxuICAgIH1cXG4gIH1cXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcXG4gICAgaWYgKCFrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBrZXksIHRydWUpKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gb3V0cHV0O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XFxuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xcbiAgaWYgKGRlc2MuZ2V0KSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcXG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcXG4gIH1cXG4gIGlmICghc3RyKSB7XFxuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXFxcbicpID4gLTEpIHtcXG4gICAgICAgIGlmIChhcnJheSkge1xcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJykuc3Vic3RyKDIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RyID0gJ1xcXFxuJyArIHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XFxuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XFxuICAgIGlmIChuYW1lLm1hdGNoKC9eXFxcIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVxcXCIkLykpIHtcXG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcXFxcIi9nLCAnXFxcIicpXFxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cXFwifFxcXCIkKS9nLCBcXFwiJ1xcXCIpO1xcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcXG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XFxuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcXG4gICAgbnVtTGluZXNFc3QrKztcXG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXFxcbicpID49IDApIG51bUxpbmVzRXN0Kys7XFxuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcXFx1MDAxYlxcXFxbXFxcXGRcXFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xcbiAgfSwgMCk7XFxuXFxuICBpZiAobGVuZ3RoID4gNjApIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArXFxuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxcXG4gJykgK1xcbiAgICAgICAgICAgJyAnICtcXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxcXG4gICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBicmFjZXNbMV07XFxuICB9XFxuXFxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xcbn1cXG5cXG5cXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XFxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XFxufVxcbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcXG5cXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XFxufVxcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xcblxcbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXFxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIHBhZChuKSB7XFxuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcXG59XFxuXFxuXFxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XFxuXFxuLy8gMjYgRmViIDE2OjE5OjM0XFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcXG59XFxuXFxuXFxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XFxuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcXG59O1xcblxcblxcbi8qKlxcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cXG4gKlxcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxcbiAqXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxcbiAqICAgICBwcm90b3R5cGUuXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXFxuICovXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcXG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xcblxcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcXG4gIHdoaWxlIChpLS0pIHtcXG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xcbiAgfVxcbiAgcmV0dXJuIG9yaWdpbjtcXG59O1xcblxcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL3N1cHBvcnQvaXNCdWZmZXJcXFwiOjEwMSxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJpbmhlcml0c1xcXCI6MTAwfV19LHt9LFsxXSk7XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vbW9jaGEvbW9jaGEuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdGRlbGV0ZSByZXF1aXJlLmNhY2hlW21vZHVsZS5pZF07XG5cdGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm1vY2hhUGhhbnRvbUpTKVxuXHRcdG1vY2hhUGhhbnRvbUpTLnJ1bigpO1xuXHRlbHNlXG5cdFx0bW9jaGEucnVuKCk7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tb2NoYS1sb2FkZXIvc3RhcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9